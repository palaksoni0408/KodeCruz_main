{"version":3,"sources":["../../../../../../src/lib/stack-app/apps/implementations/server-app-impl.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { KnownErrors, StackServerInterface } from \"@stackframe/stack-shared\";\nimport { ContactChannelsCrud } from \"@stackframe/stack-shared/dist/interface/crud/contact-channels\";\nimport { ItemCrud } from \"@stackframe/stack-shared/dist/interface/crud/items\";\nimport { NotificationPreferenceCrud } from \"@stackframe/stack-shared/dist/interface/crud/notification-preferences\";\nimport { OAuthProviderCrud } from \"@stackframe/stack-shared/dist/interface/crud/oauth-providers\";\nimport type { CustomerProductsListResponse } from \"@stackframe/stack-shared/dist/interface/crud/products\";\nimport { TeamApiKeysCrud, UserApiKeysCrud, teamApiKeysCreateOutputSchema, userApiKeysCreateOutputSchema } from \"@stackframe/stack-shared/dist/interface/crud/project-api-keys\";\nimport { ProjectPermissionDefinitionsCrud, ProjectPermissionsCrud } from \"@stackframe/stack-shared/dist/interface/crud/project-permissions\";\nimport { TeamInvitationCrud } from \"@stackframe/stack-shared/dist/interface/crud/team-invitation\";\nimport { TeamMemberProfilesCrud } from \"@stackframe/stack-shared/dist/interface/crud/team-member-profiles\";\nimport { TeamPermissionDefinitionsCrud, TeamPermissionsCrud } from \"@stackframe/stack-shared/dist/interface/crud/team-permissions\";\nimport { TeamsCrud } from \"@stackframe/stack-shared/dist/interface/crud/teams\";\nimport { UsersCrud } from \"@stackframe/stack-shared/dist/interface/crud/users\";\nimport { InternalSession } from \"@stackframe/stack-shared/dist/sessions\";\nimport type { AsyncCache } from \"@stackframe/stack-shared/dist/utils/caches\";\nimport { captureError, StackAssertionError, throwErr } from \"@stackframe/stack-shared/dist/utils/errors\";\nimport { ProviderType } from \"@stackframe/stack-shared/dist/utils/oauth\";\nimport { runAsynchronously } from \"@stackframe/stack-shared/dist/utils/promises\";\nimport { suspend } from \"@stackframe/stack-shared/dist/utils/react\";\nimport { Result } from \"@stackframe/stack-shared/dist/utils/results\";\nimport { useMemo } from \"react\"; // THIS_LINE_PLATFORM react-like\nimport * as yup from \"yup\";\nimport { constructRedirectUrl } from \"../../../../utils/url\";\nimport { ApiKey, ApiKeyCreationOptions, ApiKeyUpdateOptions, apiKeyCreationOptionsToCrud, apiKeyUpdateOptionsToCrud } from \"../../api-keys\";\nimport { ConvexCtx, GetCurrentUserOptions } from \"../../common\";\nimport { OAuthConnection } from \"../../connected-accounts\";\nimport { ServerContactChannel, ServerContactChannelCreateOptions, ServerContactChannelUpdateOptions, serverContactChannelCreateOptionsToCrud, serverContactChannelUpdateOptionsToCrud } from \"../../contact-channels\";\nimport { Customer, InlineProduct, ServerItem } from \"../../customers\";\nimport { DataVaultStore } from \"../../data-vault\";\nimport { SendEmailOptions } from \"../../email\";\nimport { NotificationCategory } from \"../../notification-categories\";\nimport { AdminProjectPermissionDefinition, AdminTeamPermission, AdminTeamPermissionDefinition } from \"../../permissions\";\nimport { EditableTeamMemberProfile, ServerListUsersOptions, ServerTeam, ServerTeamCreateOptions, ServerTeamUpdateOptions, ServerTeamUser, Team, TeamInvitation, serverTeamCreateOptionsToCrud, serverTeamUpdateOptionsToCrud } from \"../../teams\";\nimport { ProjectCurrentServerUser, ServerOAuthProvider, ServerUser, ServerUserCreateOptions, ServerUserUpdateOptions, attachUserDestructureGuard, serverUserCreateOptionsToCrud, serverUserUpdateOptionsToCrud } from \"../../users\";\nimport { StackServerAppConstructorOptions } from \"../interfaces/server-app\";\nimport { _StackClientAppImplIncomplete } from \"./client-app-impl\";\nimport { clientVersion, createCache, createCacheBySession, getBaseUrl, getDefaultExtraRequestHeaders, getDefaultProjectId, getDefaultPublishableClientKey, getDefaultSecretServerKey, resolveConstructorOptions } from \"./common\";\nimport { startRegistration, WebAuthnError } from \"@simplewebauthn/browser\";\n\nimport { useAsyncCache } from \"./common\"; // THIS_LINE_PLATFORM react-like\n\nexport class _StackServerAppImplIncomplete<HasTokenStore extends boolean, ProjectId extends string> extends _StackClientAppImplIncomplete<HasTokenStore, ProjectId> {\n  declare protected _interface: StackServerInterface;\n\n  // TODO override the client user cache to use the server user cache, so we save some requests\n  private readonly _currentServerUserCache = createCacheBySession(async (session) => {\n    if (session.isKnownToBeInvalid()) {\n      // see comment in _currentUserCache for more details on why we do this\n      return null;\n    }\n    return await this._interface.getServerUserByToken(session);\n  });\n  private readonly _serverUsersCache = createCache<[\n    cursor?: string,\n    limit?: number,\n    orderBy?: 'signedUpAt',\n    desc?: boolean,\n    query?: string,\n    includeAnonymous?: boolean,\n  ], UsersCrud['Server']['List']>(async ([cursor, limit, orderBy, desc, query, includeAnonymous]) => {\n    return await this._interface.listServerUsers({ cursor, limit, orderBy, desc, query, includeAnonymous });\n  });\n  private readonly _serverUserCache = createCache<string[], UsersCrud['Server']['Read'] | null>(async ([userId]) => {\n    const user = await this._interface.getServerUserById(userId);\n    return Result.or(user, null);\n  });\n  private readonly _serverTeamsCache = createCache<[string | undefined], TeamsCrud['Server']['Read'][]>(async ([userId]) => {\n    return await this._interface.listServerTeams({ userId });\n  });\n  private readonly _serverTeamUserPermissionsCache = createCache<\n    [string, string, boolean],\n    TeamPermissionsCrud['Server']['Read'][]\n  >(async ([teamId, userId, recursive]) => {\n    return await this._interface.listServerTeamPermissions({ teamId, userId, recursive }, null);\n  });\n  private readonly _serverUserProjectPermissionsCache = createCache<\n    [string, boolean],\n    ProjectPermissionsCrud['Server']['Read'][]\n  >(async ([userId, recursive]) => {\n    return await this._interface.listServerProjectPermissions({ userId, recursive }, null);\n  });\n  private readonly _serverUserOAuthConnectionAccessTokensCache = createCache<[string, string, string], { accessToken: string } | null>(\n    async ([userId, providerId, scope]) => {\n      try {\n        const result = await this._interface.createServerProviderAccessToken(userId, providerId, scope || \"\");\n        return { accessToken: result.access_token };\n      } catch (err) {\n        if (!(KnownErrors.OAuthConnectionDoesNotHaveRequiredScope.isInstance(err) || KnownErrors.OAuthConnectionNotConnectedToUser.isInstance(err))) {\n          throw err;\n        }\n      }\n      return null;\n    }\n  );\n  private readonly _serverUserOAuthConnectionCache = createCache<[string, ProviderType, string, boolean], OAuthConnection | null>(\n    async ([userId, providerId, scope, redirect]) => {\n      return await this._getUserOAuthConnectionCacheFn({\n        getUser: async () => Result.orThrow(await this._serverUserCache.getOrWait([userId], \"write-only\")),\n        getOrWaitOAuthToken: async () => Result.orThrow(await this._serverUserOAuthConnectionAccessTokensCache.getOrWait([userId, providerId, scope || \"\"] as const, \"write-only\")),\n        useOAuthToken: () => useAsyncCache(this._serverUserOAuthConnectionAccessTokensCache, [userId, providerId, scope || \"\"] as const, \"user.useConnectedAccount()\"),\n        providerId,\n        scope,\n        redirect,\n        session: null,\n      });\n    }\n  );\n  private readonly _serverTeamMemberProfilesCache = createCache<[string], TeamMemberProfilesCrud['Server']['Read'][]>(\n    async ([teamId]) => {\n      return await this._interface.listServerTeamMemberProfiles({ teamId });\n    }\n  );\n  private readonly _serverTeamInvitationsCache = createCache<[string], TeamInvitationCrud['Server']['Read'][]>(\n    async ([teamId]) => {\n      return await this._interface.listServerTeamInvitations({ teamId });\n    }\n  );\n  private readonly _serverUserTeamProfileCache = createCache<[string, string], TeamMemberProfilesCrud['Client']['Read']>(\n    async ([teamId, userId]) => {\n      return await this._interface.getServerTeamMemberProfile({ teamId, userId });\n    }\n  );\n  private readonly _serverContactChannelsCache = createCache<[string], ContactChannelsCrud['Server']['Read'][]>(\n    async ([userId]) => {\n      return await this._interface.listServerContactChannels(userId);\n    }\n  );\n  private readonly _serverNotificationCategoriesCache = createCache<[string], NotificationPreferenceCrud['Server']['Read'][]>(\n    async ([userId]) => {\n      return await this._interface.listServerNotificationCategories(userId);\n    }\n  );\n  private readonly _serverDataVaultStoreValueCache = createCache<[string, string, string], string | null>(async ([storeId, key, secret]) => {\n    return await this._interface.getDataVaultStoreValue(secret, storeId, key);\n  });\n\n  private readonly _serverUserApiKeysCache = createCache<[string], UserApiKeysCrud['Server']['Read'][]>(\n    async ([userId]) => {\n      const result = await this._interface.listProjectApiKeys({\n        user_id: userId,\n      }, null, \"server\");\n      return result as UserApiKeysCrud['Server']['Read'][];\n    }\n  );\n\n  private readonly _serverTeamApiKeysCache = createCache<[string], TeamApiKeysCrud['Server']['Read'][]>(\n    async ([teamId]) => {\n      const result = await this._interface.listProjectApiKeys({\n        team_id: teamId,\n      }, null, \"server\");\n      return result as TeamApiKeysCrud['Server']['Read'][];\n    }\n  );\n\n  private readonly _convexIdentitySubjectCache = createCache<[ConvexCtx], string | null>(\n    async ([ctx]) => {\n      const identity = await ctx.auth.getUserIdentity();\n      return identity ? identity.subject : null;\n    }\n  );\n\n  private readonly _serverCheckApiKeyCache = createCache<[\"user\" | \"team\", string], UserApiKeysCrud['Server']['Read'] | TeamApiKeysCrud['Server']['Read'] | null>(async ([type, apiKey]) => {\n    const result = await this._interface.checkProjectApiKey(\n      type,\n      apiKey,\n      null,\n      \"server\",\n    );\n    return result;\n  });\n\n  private readonly _serverOAuthProvidersCache = createCache<[string], OAuthProviderCrud['Server']['Read'][]>(\n    async ([userId]) => {\n      return await this._interface.listServerOAuthProviders({ user_id: userId });\n    }\n  );\n\n  private readonly _serverTeamItemsCache = createCache<[string, string], ItemCrud['Client']['Read']>(\n    async ([teamId, itemId]) => {\n      return await this._interface.getItem({ teamId, itemId }, null);\n    }\n  );\n\n  private readonly _serverUserItemsCache = createCache<[string, string], ItemCrud['Client']['Read']>(\n    async ([userId, itemId]) => {\n      return await this._interface.getItem({ userId, itemId }, null);\n    }\n  );\n\n  private readonly _serverCustomItemsCache = createCache<[string, string], ItemCrud['Client']['Read']>(\n    async ([customCustomerId, itemId]) => {\n      return await this._interface.getItem({ customCustomerId, itemId }, null);\n    }\n  );\n\n  private readonly _serverUserProductsCache = createCache<[string, string | null, number | null], CustomerProductsListResponse>(\n    async ([userId, cursor, limit]) => {\n      return await this._interface.listProducts({\n        customer_type: \"user\",\n        customer_id: userId,\n        cursor: cursor ?? undefined,\n        limit: limit ?? undefined,\n      }, null);\n    }\n  );\n\n  private readonly _serverTeamProductsCache = createCache<[string, string | null, number | null], CustomerProductsListResponse>(\n    async ([teamId, cursor, limit]) => {\n      return await this._interface.listProducts({\n        customer_type: \"team\",\n        customer_id: teamId,\n        cursor: cursor ?? undefined,\n        limit: limit ?? undefined,\n      }, null);\n    }\n  );\n\n  private readonly _serverCustomProductsCache = createCache<[string, string | null, number | null], CustomerProductsListResponse>(\n    async ([customCustomerId, cursor, limit]) => {\n      return await this._interface.listProducts({\n        customer_type: \"custom\",\n        customer_id: customCustomerId,\n        cursor: cursor ?? undefined,\n        limit: limit ?? undefined,\n      }, null);\n    }\n  );\n\n  protected _createServerCustomer(userIdOrTeamId: string, type: \"user\" | \"team\"): Omit<Customer<true>, \"id\"> {\n    const app = this;\n    const productsCache = type === \"user\" ? app._serverUserProductsCache : app._serverTeamProductsCache;\n    const customerOptions = type === \"user\" ? { userId: userIdOrTeamId } : { teamId: userIdOrTeamId };\n    return {\n      ...this._createCustomer(userIdOrTeamId, type, null),\n      async getItem(itemId: string) {\n        return await app.getItem({ itemId, ...customerOptions });\n      },\n      useItem(itemId: string) {\n        return app.useItem({ itemId, ...customerOptions });\n      },\n      async grantProduct(productOptions: { productId: string, quantity?: number } | { product: InlineProduct, quantity?: number }) {\n        if (type === \"user\") {\n          if (\"productId\" in productOptions) {\n            await app.grantProduct({ userId: userIdOrTeamId, productId: productOptions.productId, quantity: productOptions.quantity });\n          } else {\n            await app.grantProduct({ userId: userIdOrTeamId, product: productOptions.product, quantity: productOptions.quantity });\n          }\n        } else {\n          if (\"productId\" in productOptions) {\n            await app.grantProduct({ teamId: userIdOrTeamId, productId: productOptions.productId, quantity: productOptions.quantity });\n          } else {\n            await app.grantProduct({ teamId: userIdOrTeamId, product: productOptions.product, quantity: productOptions.quantity });\n          }\n        }\n        await productsCache.refresh([userIdOrTeamId, null, null]);\n      },\n      async createCheckoutUrl(options: { productId: string, returnUrl?: string } | { product: InlineProduct, returnUrl?: string }) {\n        const productIdOrInline = \"productId\" in options ? options.productId : options.product;\n        return await app._interface.createCheckoutUrl(type, userIdOrTeamId, productIdOrInline, null, options.returnUrl);\n      },\n    };\n  }\n\n  private async _updateServerUser(userId: string, update: ServerUserUpdateOptions): Promise<UsersCrud['Server']['Read']> {\n    const result = await this._interface.updateServerUser(userId, serverUserUpdateOptionsToCrud(update));\n    await this._refreshUsers();\n    return result;\n  }\n\n  protected _serverEditableTeamProfileFromCrud(crud: TeamMemberProfilesCrud['Client']['Read']): EditableTeamMemberProfile {\n    const app = this;\n    return {\n      displayName: crud.display_name,\n      profileImageUrl: crud.profile_image_url,\n      async update(update: { displayName?: string, profileImageUrl?: string }) {\n        await app._interface.updateServerTeamMemberProfile({\n          teamId: crud.team_id,\n          userId: crud.user_id,\n          profile: {\n            display_name: update.displayName,\n            profile_image_url: update.profileImageUrl,\n          },\n        });\n        await app._serverUserTeamProfileCache.refresh([crud.team_id, crud.user_id]);\n      }\n    };\n  }\n\n  protected _serverContactChannelFromCrud(userId: string, crud: ContactChannelsCrud['Server']['Read']): ServerContactChannel {\n    const app = this;\n    return {\n      id: crud.id,\n      value: crud.value,\n      type: crud.type,\n      isVerified: crud.is_verified,\n      isPrimary: crud.is_primary,\n      usedForAuth: crud.used_for_auth,\n      async sendVerificationEmail(options?: { callbackUrl?: string }) {\n        await app._interface.sendServerContactChannelVerificationEmail(userId, crud.id, options?.callbackUrl ?? constructRedirectUrl(app.urls.emailVerification, \"callbackUrl\"));\n      },\n      async update(data: ServerContactChannelUpdateOptions) {\n        await app._interface.updateServerContactChannel(userId, crud.id, serverContactChannelUpdateOptionsToCrud(data));\n        await Promise.all([\n          app._serverContactChannelsCache.refresh([userId]),\n          app._serverUserCache.refresh([userId])\n        ]);\n      },\n      async delete() {\n        await app._interface.deleteServerContactChannel(userId, crud.id);\n        await Promise.all([\n          app._serverContactChannelsCache.refresh([userId]),\n          app._serverUserCache.refresh([userId])\n        ]);\n      },\n    };\n  }\n\n  protected _serverNotificationCategoryFromCrud(userId: string, crud: NotificationPreferenceCrud['Server']['Read']): NotificationCategory {\n    const app = this;\n    return {\n      id: crud.notification_category_id,\n      name: crud.notification_category_name,\n      enabled: crud.enabled,\n      canDisable: crud.can_disable,\n\n      async setEnabled(enabled: boolean) {\n        await app._interface.setServerNotificationsEnabled(userId, crud.notification_category_id, enabled);\n        await app._serverNotificationCategoriesCache.refresh([userId]);\n      },\n    };\n  }\n\n  protected _serverOAuthProviderFromCrud(crud: OAuthProviderCrud['Server']['Read']) {\n    const app = this;\n    return {\n      id: crud.id,\n      type: crud.type,\n      userId: crud.user_id,\n      accountId: crud.account_id,\n      email: crud.email,\n      allowSignIn: crud.allow_sign_in,\n      allowConnectedAccounts: crud.allow_connected_accounts,\n\n      async update(data: { accountId?: string, email?: string, allowSignIn?: boolean, allowConnectedAccounts?: boolean }): Promise<Result<void,\n        InstanceType<typeof KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn>\n      >> {\n        try {\n          await app._interface.updateServerOAuthProvider(crud.user_id, crud.id, {\n            account_id: data.accountId,\n            email: data.email,\n            allow_sign_in: data.allowSignIn,\n            allow_connected_accounts: data.allowConnectedAccounts,\n          });\n          await app._serverOAuthProvidersCache.refresh([crud.user_id]);\n          return Result.ok(undefined);\n        } catch (error) {\n          if (KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn.isInstance(error)) {\n            return Result.error(error);\n          }\n          throw error;\n        }\n      },\n\n      async delete() {\n        await app._interface.deleteServerOAuthProvider(crud.user_id, crud.id);\n        await app._serverOAuthProvidersCache.refresh([crud.user_id]);\n      },\n    };\n  }\n\n  constructor(options: StackServerAppConstructorOptions<HasTokenStore, ProjectId>, extraOptions?: { uniqueIdentifier?: string, checkString?: string, interface?: StackServerInterface }) {\n    const resolvedOptions = resolveConstructorOptions(options);\n\n    super(resolvedOptions, {\n      ...extraOptions,\n      interface: extraOptions?.interface ?? new StackServerInterface({\n        getBaseUrl: () => getBaseUrl(resolvedOptions.baseUrl),\n        projectId: resolvedOptions.projectId ?? getDefaultProjectId(),\n        extraRequestHeaders: resolvedOptions.extraRequestHeaders ?? getDefaultExtraRequestHeaders(),\n        clientVersion,\n        publishableClientKey: resolvedOptions.publishableClientKey ?? getDefaultPublishableClientKey(),\n        secretServerKey: resolvedOptions.secretServerKey ?? getDefaultSecretServerKey(),\n      }),\n    });\n  }\n\n\n  protected _serverApiKeyFromCrud(crud: TeamApiKeysCrud['Client']['Read']): ApiKey<\"team\">;\n  protected _serverApiKeyFromCrud(crud: UserApiKeysCrud['Client']['Read']): ApiKey<\"user\">;\n  protected _serverApiKeyFromCrud(crud: yup.InferType<typeof teamApiKeysCreateOutputSchema>): ApiKey<\"team\", true>;\n  protected _serverApiKeyFromCrud(crud: yup.InferType<typeof userApiKeysCreateOutputSchema>): ApiKey<\"user\", true>;\n  protected _serverApiKeyFromCrud(crud: TeamApiKeysCrud['Client']['Read'] | UserApiKeysCrud['Client']['Read'] | yup.InferType<typeof teamApiKeysCreateOutputSchema> | yup.InferType<typeof userApiKeysCreateOutputSchema>): ApiKey<\"user\" | \"team\", boolean> {\n    return {\n      ...this._baseApiKeyFromCrud(crud),\n      async revoke() {\n        await this.update({ revoked: true });\n      },\n      update: async (options: ApiKeyUpdateOptions) => {\n        await this._interface.updateProjectApiKey(\n          crud.type === \"team\" ? { team_id: crud.team_id } : { user_id: crud.user_id },\n          crud.id,\n          await apiKeyUpdateOptionsToCrud(crud.type, options),\n          null,\n          \"server\");\n        if (crud.type === \"team\") {\n          await this._serverTeamApiKeysCache.refresh([crud.team_id]);\n        } else {\n          await this._serverUserApiKeysCache.refresh([crud.user_id]);\n        }\n      },\n    };\n  }\n\n  protected _serverUserFromCrud(crud: UsersCrud['Server']['Read']): ServerUser {\n    const app = this;\n\n    async function getConnectedAccount(id: ProviderType, options?: { scopes?: string[] }): Promise<OAuthConnection | null>;\n    async function getConnectedAccount(id: ProviderType, options: { or: 'redirect', scopes?: string[] }): Promise<OAuthConnection>;\n    async function getConnectedAccount(id: ProviderType, options?: { or?: 'redirect', scopes?: string[] }): Promise<OAuthConnection | null> {\n      const scopeString = options?.scopes?.join(\" \");\n      return Result.orThrow(await app._serverUserOAuthConnectionCache.getOrWait([crud.id, id, scopeString || \"\", options?.or === 'redirect'], \"write-only\"));\n    }\n\n    function useConnectedAccount(id: ProviderType, options?: { scopes?: string[] }): OAuthConnection | null;\n    function useConnectedAccount(id: ProviderType, options: { or: 'redirect', scopes?: string[] }): OAuthConnection;\n    function useConnectedAccount(id: ProviderType, options?: { or?: 'redirect', scopes?: string[] }): OAuthConnection | null {\n      const scopeString = options?.scopes?.join(\" \");\n      return useAsyncCache(app._serverUserOAuthConnectionCache, [crud.id, id, scopeString || \"\", options?.or === 'redirect'] as const, \"user.useConnectedAccount()\");\n    }\n\n    const serverUser = {\n      ...super._createBaseUser(crud),\n      lastActiveAt: new Date(crud.last_active_at_millis),\n      serverMetadata: crud.server_metadata,\n      async setPrimaryEmail(email: string | null, options?: { verified?: boolean }) {\n        await app._updateServerUser(crud.id, { primaryEmail: email, primaryEmailVerified: options?.verified });\n      },\n      async grantPermission(scopeOrPermissionId: Team | string, permissionId?: string): Promise<void> {\n        if (scopeOrPermissionId && typeof scopeOrPermissionId !== 'string' && permissionId) {\n          const scope = scopeOrPermissionId;\n          await app._interface.grantServerTeamUserPermission(scope.id, crud.id, permissionId);\n\n          for (const recursive of [true, false]) {\n            await app._serverTeamUserPermissionsCache.refresh([scope.id, crud.id, recursive]);\n          }\n        } else {\n          const pId = scopeOrPermissionId as string;\n          await app._interface.grantServerProjectPermission(crud.id, pId);\n\n          for (const recursive of [true, false]) {\n            await app._serverUserProjectPermissionsCache.refresh([crud.id, recursive]);\n          }\n        }\n      },\n      async revokePermission(scopeOrPermissionId: Team | string, permissionId?: string): Promise<void> {\n        if (scopeOrPermissionId && typeof scopeOrPermissionId !== 'string' && permissionId) {\n          const scope = scopeOrPermissionId;\n          await app._interface.revokeServerTeamUserPermission(scope.id, crud.id, permissionId);\n\n          for (const recursive of [true, false]) {\n            await app._serverTeamUserPermissionsCache.refresh([scope.id, crud.id, recursive]);\n          }\n        } else {\n          const pId = scopeOrPermissionId as string;\n          await app._interface.revokeServerProjectPermission(crud.id, pId);\n\n          for (const recursive of [true, false]) {\n            await app._serverUserProjectPermissionsCache.refresh([crud.id, recursive]);\n          }\n        }\n      },\n      async delete() {\n        const res = await app._interface.deleteServerUser(crud.id);\n        await app._refreshUsers();\n        return res;\n      },\n      async createSession(options: { expiresInMillis?: number, isImpersonation?: boolean }) {\n        // TODO this should also refresh the access token when it expires (like InternalSession)\n        const tokens = await app._interface.createServerUserSession(crud.id, options.expiresInMillis ?? 1000 * 60 * 60 * 24 * 365, options.isImpersonation ?? false);\n        return {\n          async getTokens() {\n            return tokens;\n          },\n        };\n      },\n\n      async getActiveSessions() {\n        const sessions = await app._interface.listServerSessions(crud.id);\n        return sessions.map((session) => app._clientSessionFromCrud(session));\n      },\n\n      async revokeSession(sessionId: string) {\n        await app._interface.deleteServerSession(sessionId);\n      },\n      async setDisplayName(displayName: string) {\n        return await this.update({ displayName });\n      },\n      async setClientMetadata(metadata: Record<string, any>) {\n        return await this.update({ clientMetadata: metadata });\n      },\n      async setClientReadOnlyMetadata(metadata: Record<string, any>) {\n        return await this.update({ clientReadOnlyMetadata: metadata });\n      },\n      async setServerMetadata(metadata: Record<string, any>) {\n        return await this.update({ serverMetadata: metadata });\n      },\n      async setSelectedTeam(team: Team | null) {\n        return await this.update({ selectedTeamId: team?.id ?? null });\n      },\n      getConnectedAccount,\n      useConnectedAccount, // THIS_LINE_PLATFORM react-like\n      selectedTeam: crud.selected_team ? app._serverTeamFromCrud(crud.selected_team) : null,\n      async getTeam(teamId: string) {\n        const teams = await this.listTeams();\n        return teams.find((t) => t.id === teamId) ?? null;\n      },\n      useTeam(teamId: string) {\n        const teams = this.useTeams();\n        return useMemo(() => {\n          return teams.find((t) => t.id === teamId) ?? null;\n        }, [teams, teamId]);\n      },\n      async listTeams() {\n        const teams = Result.orThrow(await app._serverTeamsCache.getOrWait([crud.id], \"write-only\"));\n        return teams.map((t) => app._serverTeamFromCrud(t));\n      },\n      useTeams() {\n        const teams = useAsyncCache(app._serverTeamsCache, [crud.id], \"user.useTeams()\");\n        return useMemo(() => teams.map((t) => app._serverTeamFromCrud(t)), [teams]);\n      },\n      createTeam: async (data: Omit<ServerTeamCreateOptions, \"creatorUserId\">) => {\n        const team = await app._interface.createServerTeam(serverTeamCreateOptionsToCrud({\n          creatorUserId: crud.id,\n          ...data,\n        }));\n        await app._serverTeamsCache.refresh([undefined]);\n        await app._updateServerUser(crud.id, { selectedTeamId: team.id });\n        return app._serverTeamFromCrud(team);\n      },\n      leaveTeam: async (team: Team) => {\n        await app._interface.leaveServerTeam({ teamId: team.id, userId: crud.id });\n        // TODO: refresh cache\n      },\n      async listPermissions(scopeOrOptions?: Team | { recursive?: boolean }, options?: { recursive?: boolean }): Promise<AdminTeamPermission[]> {\n        if (scopeOrOptions && 'id' in scopeOrOptions) {\n          const scope = scopeOrOptions;\n          const recursive = options?.recursive ?? true;\n          const permissions = Result.orThrow(await app._serverTeamUserPermissionsCache.getOrWait([scope.id, crud.id, recursive], \"write-only\"));\n          return permissions.map((crud) => app._serverPermissionFromCrud(crud));\n        } else {\n          const opts = scopeOrOptions;\n          const recursive = opts?.recursive ?? true;\n          const permissions = Result.orThrow(await app._serverUserProjectPermissionsCache.getOrWait([crud.id, recursive], \"write-only\"));\n          return permissions.map((crud) => app._serverPermissionFromCrud(crud));\n        }\n      },\n      usePermissions(scopeOrOptions?: Team | { recursive?: boolean }, options?: { recursive?: boolean }): AdminTeamPermission[] {\n        if (scopeOrOptions && 'id' in scopeOrOptions) {\n          const scope = scopeOrOptions;\n          const recursive = options?.recursive ?? true;\n          const permissions = useAsyncCache(app._serverTeamUserPermissionsCache, [scope.id, crud.id, recursive] as const, \"user.usePermissions()\");\n          return useMemo(() => permissions.map((crud) => app._serverPermissionFromCrud(crud)), [permissions]);\n        } else {\n          const opts = scopeOrOptions;\n          const recursive = opts?.recursive ?? true;\n          const permissions = useAsyncCache(app._serverUserProjectPermissionsCache, [crud.id, recursive] as const, \"user.usePermissions()\");\n          return useMemo(() => permissions.map((crud) => app._serverPermissionFromCrud(crud)), [permissions]);\n        }\n      },\n      async getPermission(scopeOrPermissionId: Team | string, permissionId?: string): Promise<AdminTeamPermission | null> {\n        if (scopeOrPermissionId && typeof scopeOrPermissionId !== 'string') {\n          const scope = scopeOrPermissionId;\n          const permissions = await this.listPermissions(scope);\n          return permissions.find((p) => p.id === permissionId) ?? null;\n        } else {\n          const pid = scopeOrPermissionId;\n          const permissions = await this.listPermissions();\n          return permissions.find((p) => p.id === pid) ?? null;\n        }\n      },\n      usePermission(scopeOrPermissionId: Team | string, permissionId?: string): AdminTeamPermission | null {\n        if (scopeOrPermissionId && typeof scopeOrPermissionId !== 'string') {\n          const scope = scopeOrPermissionId;\n          const permissions = this.usePermissions(scope);\n          return useMemo(() => permissions.find((p) => p.id === permissionId) ?? null, [permissions, permissionId]);\n        } else {\n          const pid = scopeOrPermissionId;\n          const permissions = this.usePermissions();\n          return useMemo(() => permissions.find((p) => p.id === pid) ?? null, [permissions, pid]);\n        }\n      },\n      async hasPermission(scopeOrPermissionId: Team | string, permissionId?: string): Promise<boolean> {\n        if (scopeOrPermissionId && typeof scopeOrPermissionId !== 'string') {\n          const scope = scopeOrPermissionId;\n          return (await this.getPermission(scope, permissionId as string)) !== null;\n        } else {\n          const pid = scopeOrPermissionId;\n          return (await this.getPermission(pid)) !== null;\n        }\n      },\n      async update(update: ServerUserUpdateOptions) {\n        await app._updateServerUser(crud.id, update);\n      },\n      async sendVerificationEmail() {\n        return await app._checkFeatureSupport(\"sendVerificationEmail() on ServerUser\", {});\n      },\n      async updatePassword(options: { oldPassword: string, newPassword: string }) {\n        const result = await app._interface.updatePassword(options);\n        await app._serverUserCache.refresh([crud.id]);\n        return result;\n      },\n      async setPassword(options: { password: string }) {\n        const result = await this.update(options);\n        await app._serverUserCache.refresh([crud.id]);\n        return result;\n      },\n      async getTeamProfile(team: Team) {\n        const result = Result.orThrow(await app._serverUserTeamProfileCache.getOrWait([team.id, crud.id], \"write-only\"));\n        return app._serverEditableTeamProfileFromCrud(result);\n      },\n      useTeamProfile(team: Team) {\n        const result = useAsyncCache(app._serverUserTeamProfileCache, [team.id, crud.id] as const, \"user.useTeamProfile()\");\n        return useMemo(() => app._serverEditableTeamProfileFromCrud(result), [result]);\n      },\n      async listContactChannels() {\n        const result = Result.orThrow(await app._serverContactChannelsCache.getOrWait([crud.id], \"write-only\"));\n        return result.map((data) => app._serverContactChannelFromCrud(crud.id, data));\n      },\n      useContactChannels() {\n        const result = useAsyncCache(app._serverContactChannelsCache, [crud.id] as const, \"user.useContactChannels()\");\n        return useMemo(() => result.map((data) => app._serverContactChannelFromCrud(crud.id, data)), [result]);\n      },\n      createContactChannel: async (data: ServerContactChannelCreateOptions) => {\n        const contactChannel = await app._interface.createServerContactChannel(serverContactChannelCreateOptionsToCrud(crud.id, data));\n        await Promise.all([\n          app._serverContactChannelsCache.refresh([crud.id]),\n          app._serverUserCache.refresh([crud.id])\n        ]);\n        return app._serverContactChannelFromCrud(crud.id, contactChannel);\n      },\n      useNotificationCategories() {\n        const results = useAsyncCache(app._serverNotificationCategoriesCache, [crud.id] as const, \"user.useNotificationCategories()\");\n        return results.map((category) => app._serverNotificationCategoryFromCrud(crud.id, category));\n      },\n      async listNotificationCategories() {\n        const results = Result.orThrow(await app._serverNotificationCategoriesCache.getOrWait([crud.id], \"write-only\"));\n        return results.map((category) => app._serverNotificationCategoryFromCrud(crud.id, category));\n      },\n      useApiKeys() {\n        const result = useAsyncCache(app._serverUserApiKeysCache, [crud.id] as const, \"user.useApiKeys()\");\n        return result.map((apiKey) => app._serverApiKeyFromCrud(apiKey));\n      },\n      async listApiKeys() {\n        const result = Result.orThrow(await app._serverUserApiKeysCache.getOrWait([crud.id], \"write-only\"));\n        return result.map((apiKey) => app._serverApiKeyFromCrud(apiKey));\n      },\n      async createApiKey(options: ApiKeyCreationOptions<\"user\">) {\n        const result = await app._interface.createProjectApiKey(\n          await apiKeyCreationOptionsToCrud(\"user\", crud.id, options),\n          null,\n          \"server\",\n        );\n        await app._serverUserApiKeysCache.refresh([crud.id]);\n        return app._serverApiKeyFromCrud(result);\n      },\n      useOAuthProviders() {\n        const results = useAsyncCache(app._serverOAuthProvidersCache, [crud.id] as const, \"user.useOAuthProviders()\");\n        return useMemo(() => results.map((oauthCrud) => app._serverOAuthProviderFromCrud(oauthCrud)), [results]);\n      },\n\n      async listOAuthProviders() {\n        const results = Result.orThrow(await app._serverOAuthProvidersCache.getOrWait([crud.id], \"write-only\"));\n        return results.map((oauthCrud) => app._serverOAuthProviderFromCrud(oauthCrud));\n      },\n\n      useOAuthProvider(id: string) {\n        const providers = this.useOAuthProviders();\n        return useMemo(() => providers.find((p) => p.id === id) ?? null, [providers, id]);\n      },\n      async getOAuthProvider(id: string) {\n        const providers = await this.listOAuthProviders();\n        return providers.find((p) => p.id === id) ?? null;\n      },\n      async registerPasskey(options?: { hostname?: string }): Promise<Result<undefined, KnownErrors[\"PasskeyRegistrationFailed\"] | KnownErrors[\"PasskeyWebAuthnError\"]>> {\n        // TODO remove duplicated code between this and the function in client-app-impl.ts\n        const hostname = options?.hostname || (await app._getCurrentUrl())?.hostname;\n        if (!hostname) {\n          throw new StackAssertionError(\"hostname must be provided if the Stack App does not have a redirect method\");\n        }\n\n        // Use server interface to initiate passkey registration for this specific user\n        const initiationResult = await app._interface.initiateServerPasskeyRegistration(crud.id);\n\n        if (initiationResult.status !== \"ok\") {\n          return Result.error(new KnownErrors.PasskeyRegistrationFailed(\"Failed to get initiation options for passkey registration\"));\n        }\n\n        const { options_json, code } = initiationResult.data;\n\n        // HACK: Override the rpID to be the actual domain\n        if (options_json.rp.id !== \"THIS_VALUE_WILL_BE_REPLACED.example.com\") {\n          throw new StackAssertionError(`Expected returned RP ID from server to equal sentinel, but found ${options_json.rp.id}`);\n        }\n\n        options_json.rp.id = hostname;\n\n        let attResp;\n        try {\n          attResp = await startRegistration({ optionsJSON: options_json });\n        } catch (error: any) {\n          if (error instanceof WebAuthnError) {\n            return Result.error(new KnownErrors.PasskeyWebAuthnError(error.message, error.name));\n          } else {\n            // This should never happen\n            captureError(\"passkey-registration-failed\", error);\n            return Result.error(new KnownErrors.PasskeyRegistrationFailed(\"Failed to start passkey registration due to unknown error\"));\n          }\n        }\n\n        // Create a temporary session to complete the registration\n        // TODO instead of creating a new session, this should just call the endpoint in a way in which it doesn't require a session\n        // (currently this shows up on session history etc... not ideal)\n        const { accessToken, refreshToken } = await app._interface.createServerUserSession(crud.id, 60000 * 2, false);\n        const tempSession = new InternalSession({\n          accessToken,\n          refreshToken,\n          refreshAccessTokenCallback: async () => null,\n        });\n\n        const registrationResult = await app._interface.registerPasskey({ credential: attResp, code }, tempSession);\n\n        await app._serverUserCache.refresh([crud.id]);\n        return registrationResult;\n      },\n      ...app._createServerCustomer(crud.id, \"user\"),\n    } satisfies ServerUser;\n\n    attachUserDestructureGuard(serverUser);\n\n    return serverUser;\n  }\n\n  protected _serverTeamUserFromCrud(crud: TeamMemberProfilesCrud[\"Server\"][\"Read\"]): ServerTeamUser {\n    const teamUser = {\n      ...this._serverUserFromCrud(crud.user),\n      teamProfile: {\n        displayName: crud.display_name,\n        profileImageUrl: crud.profile_image_url,\n      },\n    } satisfies ServerTeamUser;\n\n    attachUserDestructureGuard(teamUser);\n    return teamUser;\n  }\n\n  protected _serverTeamInvitationFromCrud(crud: TeamInvitationCrud['Server']['Read']): TeamInvitation {\n    return {\n      id: crud.id,\n      recipientEmail: crud.recipient_email,\n      expiresAt: new Date(crud.expires_at_millis),\n      revoke: async () => {\n        await this._interface.revokeServerTeamInvitation(crud.id, crud.team_id);\n        await this._serverTeamInvitationsCache.refresh([crud.team_id]);\n      },\n    };\n  }\n\n  protected override _currentUserFromCrud(crud: UsersCrud['Server']['Read'], session: InternalSession): ProjectCurrentServerUser<ProjectId> {\n    const currentUser = {\n      ...this._serverUserFromCrud(crud),\n      ...this._createAuth(session),\n      ...this._isInternalProject() ? this._createInternalUserExtra(session) : {},\n    } satisfies ServerUser;\n\n    attachUserDestructureGuard(currentUser);\n    Object.freeze(currentUser);\n    return currentUser as ProjectCurrentServerUser<ProjectId>;\n  }\n\n  protected _serverTeamFromCrud(crud: TeamsCrud['Server']['Read']): ServerTeam {\n    const app = this;\n    return {\n      id: crud.id,\n      displayName: crud.display_name,\n      profileImageUrl: crud.profile_image_url,\n      createdAt: new Date(crud.created_at_millis),\n      clientMetadata: crud.client_metadata,\n      clientReadOnlyMetadata: crud.client_read_only_metadata,\n      serverMetadata: crud.server_metadata,\n      async update(update: Partial<ServerTeamUpdateOptions>) {\n        await app._interface.updateServerTeam(crud.id, serverTeamUpdateOptionsToCrud(update));\n        await app._serverTeamsCache.refresh([undefined]);\n      },\n      async delete() {\n        await app._interface.deleteServerTeam(crud.id);\n        await app._serverTeamsCache.refresh([undefined]);\n      },\n      async listUsers() {\n        const result = Result.orThrow(await app._serverTeamMemberProfilesCache.getOrWait([crud.id], \"write-only\"));\n        return result.map(u => app._serverTeamUserFromCrud(u));\n      },\n      useUsers() {\n        const result = useAsyncCache(app._serverTeamMemberProfilesCache, [crud.id] as const, \"team.useUsers()\");\n        return useMemo(() => result.map(u => app._serverTeamUserFromCrud(u)), [result]);\n      },\n      async addUser(userId) {\n        await app._interface.addServerUserToTeam({\n          teamId: crud.id,\n          userId,\n        });\n        await app._serverTeamMemberProfilesCache.refresh([crud.id]);\n      },\n      async removeUser(userId) {\n        await app._interface.removeServerUserFromTeam({\n          teamId: crud.id,\n          userId,\n        });\n        await app._serverTeamMemberProfilesCache.refresh([crud.id]);\n      },\n      async inviteUser(options: { email: string, callbackUrl?: string }) {\n        await app._interface.sendServerTeamInvitation({\n          teamId: crud.id,\n          email: options.email,\n          callbackUrl: options.callbackUrl ?? constructRedirectUrl(app.urls.teamInvitation, \"callbackUrl\"),\n        });\n        await app._serverTeamInvitationsCache.refresh([crud.id]);\n      },\n      async listInvitations() {\n        const result = Result.orThrow(await app._serverTeamInvitationsCache.getOrWait([crud.id], \"write-only\"));\n        return result.map((crud) => app._serverTeamInvitationFromCrud(crud));\n      },\n      useInvitations() {\n        const result = useAsyncCache(app._serverTeamInvitationsCache, [crud.id] as const, \"team.useInvitations()\");\n        return useMemo(() => result.map((crud) => app._serverTeamInvitationFromCrud(crud)), [result]);\n      },\n      useApiKeys() {\n        const result = useAsyncCache(app._serverTeamApiKeysCache, [crud.id] as const, \"team.useApiKeys()\");\n        return result.map((apiKey) => app._serverApiKeyFromCrud(apiKey));\n      },\n      async listApiKeys() {\n        const result = Result.orThrow(await app._serverTeamApiKeysCache.getOrWait([crud.id], \"write-only\"));\n        return result.map((apiKey) => app._serverApiKeyFromCrud(apiKey));\n      },\n      async createApiKey(options: ApiKeyCreationOptions<\"team\">) {\n        const result = await app._interface.createProjectApiKey(\n          await apiKeyCreationOptionsToCrud(\"team\", crud.id, options),\n          null,\n          \"server\",\n        );\n        await app._serverTeamApiKeysCache.refresh([crud.id]);\n        return app._serverApiKeyFromCrud(result);\n      },\n      ...app._createServerCustomer(crud.id, \"team\"),\n    };\n  }\n\n  protected _serverItemFromCrud(customer: { type: \"user\" | \"team\" | \"custom\", id: string }, crud: ItemCrud['Client']['Read']): ServerItem {\n    const app = this;\n    return {\n      displayName: crud.display_name,\n      quantity: crud.quantity,\n      nonNegativeQuantity: Math.max(0, crud.quantity),\n      increaseQuantity: async (delta: number) => {\n        const updateOptions = customer.type === \"user\"\n          ? { itemId: crud.id, userId: customer.id }\n          : customer.type === \"team\"\n            ? { itemId: crud.id, teamId: customer.id }\n            : { itemId: crud.id, customCustomerId: customer.id };\n        await app._interface.updateItemQuantity(updateOptions, { delta });\n        if (customer.type === \"user\") await app._serverUserItemsCache.refresh([customer.id, crud.id]);\n        else if (customer.type === \"team\") await app._serverTeamItemsCache.refresh([customer.id, crud.id]);\n        else await app._serverCustomItemsCache.refresh([customer.id, crud.id]);\n      },\n      decreaseQuantity: async (delta: number) => {\n        const updateOptions = customer.type === \"user\"\n          ? { itemId: crud.id, userId: customer.id }\n          : customer.type === \"team\"\n            ? { itemId: crud.id, teamId: customer.id }\n            : { itemId: crud.id, customCustomerId: customer.id };\n        await app._interface.updateItemQuantity(updateOptions, { delta: -delta, allow_negative: true });\n        if (customer.type === \"user\") await app._serverUserItemsCache.refresh([customer.id, crud.id]);\n        else if (customer.type === \"team\") await app._serverTeamItemsCache.refresh([customer.id, crud.id]);\n        else await app._serverCustomItemsCache.refresh([customer.id, crud.id]);\n      },\n      tryDecreaseQuantity: async (delta: number) => {\n        try {\n          const updateOptions = customer.type === \"user\"\n            ? { itemId: crud.id, userId: customer.id }\n            : customer.type === \"team\"\n              ? { itemId: crud.id, teamId: customer.id }\n              : { itemId: crud.id, customCustomerId: customer.id };\n          await app._interface.updateItemQuantity(updateOptions, { delta: -delta });\n          if (customer.type === \"user\") await app._serverUserItemsCache.refresh([customer.id, crud.id]);\n          else if (customer.type === \"team\") await app._serverTeamItemsCache.refresh([customer.id, crud.id]);\n          else await app._serverCustomItemsCache.refresh([customer.id, crud.id]);\n          return true;\n        } catch (error) {\n          if (error instanceof KnownErrors.ItemQuantityInsufficientAmount) {\n            return false;\n          }\n          throw error;\n        }\n      },\n    };\n  }\n\n  protected async _getUserApiKey(options: { apiKey: string }): Promise<ApiKey<\"user\"> | null> {\n    const crud = Result.orThrow(await this._serverCheckApiKeyCache.getOrWait([\"user\", options.apiKey], \"write-only\")) as UserApiKeysCrud['Server']['Read'] | null;\n    return crud ? this._serverApiKeyFromCrud(crud) : null;\n  }\n\n  protected async _getTeamApiKey(options: { apiKey: string }): Promise<ApiKey<\"team\"> | null> {\n    const crud = Result.orThrow(await this._serverCheckApiKeyCache.getOrWait([\"team\", options.apiKey], \"write-only\")) as TeamApiKeysCrud['Server']['Read'] | null;\n    return crud ? this._serverApiKeyFromCrud(crud) : null;\n  }\n  protected _useUserApiKey(options: { apiKey: string }): ApiKey<\"user\"> | null {\n    const crud = useAsyncCache(this._serverCheckApiKeyCache, [\"user\", options.apiKey] as const, \"serverApp.useUserApiKey()\") as UserApiKeysCrud['Server']['Read'] | null;\n    return useMemo(() => crud ? this._serverApiKeyFromCrud(crud) : null, [crud]);\n  }\n  protected _useTeamApiKey(options: { apiKey: string }): ApiKey<\"team\"> | null {\n    const crud = useAsyncCache(this._serverCheckApiKeyCache, [\"team\", options.apiKey] as const, \"serverApp.useTeamApiKey()\") as TeamApiKeysCrud['Server']['Read'] | null;\n    return useMemo(() => crud ? this._serverApiKeyFromCrud(crud) : null, [crud]);\n  }\n  protected async _getUserByApiKey(apiKey: string): Promise<ServerUser | null> {\n    const apiKeyObject = await this._getUserApiKey({ apiKey });\n    if (apiKeyObject === null) {\n      return null;\n    }\n    return await this.getServerUserById(apiKeyObject.userId);\n  }\n\n  protected async _getUserByConvex(ctx: ConvexCtx, includeAnonymous: boolean): Promise<ServerUser | null> {\n    const identity = await ctx.auth.getUserIdentity();\n    if (identity === null) {\n      return null;\n    }\n    const user = await this.getServerUserById(identity.subject);\n    if (user?.isAnonymous && !includeAnonymous) {\n      return null;\n    }\n    return user;\n  }\n  protected _useUserByConvex(ctx: ConvexCtx, includeAnonymous: boolean): ServerUser | null {\n    const subject = useAsyncCache(this._convexIdentitySubjectCache, [ctx] as const, \"serverApp.useUserByConvex()\");\n    if (subject === null) {\n      return null;\n    }\n    const user = this.useUserById(subject);\n    if (user?.isAnonymous && !includeAnonymous) {\n      return null;\n    }\n    return user;\n  }\n  protected _useUserByApiKey(apiKey: string): ServerUser | null {\n    const apiKeyObject = this._useUserApiKey({ apiKey });\n    if (apiKeyObject === null) {\n      return null;\n    }\n    return this.useUserById(apiKeyObject.userId);\n  }\n\n  protected async _getTeamByApiKey(apiKey: string): Promise<ServerTeam | null> {\n    const apiKeyObject = await this._getTeamApiKey({ apiKey });\n    if (apiKeyObject === null) {\n      return null;\n    }\n    return await this.getTeam(apiKeyObject.teamId);\n  }\n  protected _useTeamByApiKey(apiKey: string): ServerTeam | null {\n    const apiKeyObject = this._useTeamApiKey({ apiKey });\n    if (apiKeyObject === null) {\n      return null;\n    }\n    return this.useTeam(apiKeyObject.teamId);\n  }\n\n  async createUser(options: ServerUserCreateOptions): Promise<ServerUser> {\n    const crud = await this._interface.createServerUser(serverUserCreateOptionsToCrud(options));\n    await this._refreshUsers();\n    return this._serverUserFromCrud(crud);\n  }\n\n  async getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'redirect' }): Promise<ProjectCurrentServerUser<ProjectId>>;\n  async getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'throw' }): Promise<ProjectCurrentServerUser<ProjectId>>;\n  async getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'anonymous' }): Promise<ProjectCurrentServerUser<ProjectId>>;\n  async getUser(options?: GetCurrentUserOptions<HasTokenStore>): Promise<ProjectCurrentServerUser<ProjectId> | null>;\n  async getUser(id: string): Promise<ServerUser | null>;\n  async getUser(options: { apiKey: string }): Promise<ServerUser | null>;\n  async getUser(options: { from: \"convex\", ctx: ConvexCtx, or?: \"return-null\" | \"anonymous\" }): Promise<ServerUser | null>;\n  async getUser(options?: string | GetCurrentUserOptions<HasTokenStore> | { apiKey: string } | { from: \"convex\", ctx: ConvexCtx }): Promise<ProjectCurrentServerUser<ProjectId> | ServerUser | null> {\n    if (typeof options === \"string\") {\n      return await this.getServerUserById(options);\n    } else if (typeof options === \"object\" && \"apiKey\" in options) {\n      return await this._getUserByApiKey(options.apiKey);\n    } else if (typeof options === \"object\" && \"from\" in options && options.from as string === \"convex\") {\n      return await this._getUserByConvex(options.ctx, \"or\" in options && options.or === \"anonymous\");\n    } else {\n      options = options as GetCurrentUserOptions<HasTokenStore> | undefined;\n      // TODO this code is duplicated from the client app; fix that\n      this._ensurePersistentTokenStore(options?.tokenStore);\n      const session = await this._getSession(options?.tokenStore);\n      let crud = Result.orThrow(await this._currentServerUserCache.getOrWait([session], \"write-only\"));\n      if (crud?.is_anonymous && options?.or !== \"anonymous\" && options?.or !== \"anonymous-if-exists[deprecated]\") {\n        crud = null;\n      }\n\n      if (crud === null) {\n        switch (options?.or) {\n          case 'redirect': {\n            await this.redirectToSignIn({ replace: true });\n            break;\n          }\n          case 'throw': {\n            throw new Error(\"User is not signed in but getUser was called with { or: 'throw' }\");\n          }\n          case 'anonymous': {\n            const tokens = await this._signUpAnonymously();\n            return await this.getUser({ tokenStore: tokens, or: \"anonymous-if-exists[deprecated]\" }) ?? throwErr(\"Something went wrong while signing up anonymously\");\n          }\n          case undefined:\n          case \"anonymous-if-exists[deprecated]\":\n          case \"return-null\": {\n            return null;\n          }\n        }\n      }\n\n      return crud && this._currentUserFromCrud(crud, session);\n    }\n  }\n\n  async getServerUser(): Promise<ProjectCurrentServerUser<ProjectId> | null> {\n    console.warn(\"stackServerApp.getServerUser is deprecated; use stackServerApp.getUser instead\");\n    return await this.getUser();\n  }\n\n  async getServerUserById(userId: string): Promise<ServerUser | null> {\n    const crud = Result.orThrow(await this._serverUserCache.getOrWait([userId], \"write-only\"));\n    return crud && this._serverUserFromCrud(crud);\n  }\n\n  useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'redirect' }): ProjectCurrentServerUser<ProjectId>;\n  useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'throw' }): ProjectCurrentServerUser<ProjectId>;\n  useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'anonymous' }): ProjectCurrentServerUser<ProjectId>;\n  useUser(options?: GetCurrentUserOptions<HasTokenStore>): ProjectCurrentServerUser<ProjectId> | null;\n  useUser(id: string): ServerUser | null;\n  useUser(options: { apiKey: string }): ServerUser | null;\n  useUser(options: { from: \"convex\", ctx: ConvexCtx, or?: \"return-null\" | \"anonymous\" }): ServerUser | null;\n  useUser(options?: GetCurrentUserOptions<HasTokenStore> | string | { apiKey: string } | { from: \"convex\", ctx: ConvexCtx }): ProjectCurrentServerUser<ProjectId> | ServerUser | null {\n    if (typeof options === \"string\") {\n      return this.useUserById(options);\n    } else if (typeof options === \"object\" && \"apiKey\" in options) {\n      return this._useUserByApiKey(options.apiKey);\n    } else if (typeof options === \"object\" && \"from\" in options && options.from as string === \"convex\") {\n      return this._useUserByConvex(options.ctx, \"or\" in options && options.or === \"anonymous\");\n    } else {\n      options = options as GetCurrentUserOptions<HasTokenStore> | undefined;\n      // TODO this code is duplicated from the client app; fix that\n      this._ensurePersistentTokenStore(options?.tokenStore);\n\n      const session = this._useSession(options?.tokenStore);\n      let crud = useAsyncCache(this._currentServerUserCache, [session] as const, \"serverApp.useUser()\");\n      if (crud?.is_anonymous && options?.or !== \"anonymous\" && options?.or !== \"anonymous-if-exists[deprecated]\") {\n        crud = null;\n      }\n\n      if (crud === null) {\n        switch (options?.or) {\n          case 'redirect': {\n            runAsynchronously(this.redirectToSignIn({ replace: true }));\n            suspend();\n            throw new StackAssertionError(\"suspend should never return\");\n          }\n          case 'throw': {\n            throw new Error(\"User is not signed in but useUser was called with { or: 'throw' }\");\n          }\n          case 'anonymous': {\n            // TODO we should think about the behavior when calling useUser (or getUser) in anonymous with a custom token store. signUpAnonymously always sets the current token store on app level, instead of the one passed to this function\n            // TODO we shouldn't reload & suspend here, instead we should use a promise that resolves to the new anonymous user\n            runAsynchronously(async () => {\n              await this._signUpAnonymously();\n              if (typeof window !== \"undefined\") {\n                window.location.reload();\n              }\n            });\n            suspend();\n            throw new StackAssertionError(\"suspend should never return\");\n          }\n          case undefined:\n          case \"anonymous-if-exists[deprecated]\":\n          case \"return-null\": {\n            // do nothing\n          }\n        }\n      }\n\n      return useMemo(() => {\n        return crud && this._currentUserFromCrud(crud, session);\n      }, [crud, session, options?.or]);\n    }\n  }\n  useUserById(userId: string): ServerUser | null {\n    const crud = useAsyncCache(this._serverUserCache, [userId], \"serverApp.useUserById()\");\n    return useMemo(() => {\n      return crud && this._serverUserFromCrud(crud);\n    }, [crud]);\n  }\n\n  async listUsers(options?: ServerListUsersOptions): Promise<ServerUser[] & { nextCursor: string | null }> {\n    const crud = Result.orThrow(await this._serverUsersCache.getOrWait([options?.cursor, options?.limit, options?.orderBy, options?.desc, options?.query, options?.includeAnonymous], \"write-only\"));\n    const result: any = crud.items.map((j) => this._serverUserFromCrud(j));\n    result.nextCursor = crud.pagination?.next_cursor ?? null;\n    return result as any;\n  }\n\n  useUsers(options?: ServerListUsersOptions): ServerUser[] & { nextCursor: string | null } {\n    const crud = useAsyncCache(this._serverUsersCache, [options?.cursor, options?.limit, options?.orderBy, options?.desc, options?.query, options?.includeAnonymous] as const, \"serverApp.useUsers()\");\n    const result: any = crud.items.map((j) => this._serverUserFromCrud(j));\n    result.nextCursor = crud.pagination?.next_cursor ?? null;\n    return result as any;\n  }\n\n  _serverPermissionFromCrud(crud: TeamPermissionsCrud['Server']['Read'] | ProjectPermissionsCrud['Server']['Read']): AdminTeamPermission {\n    return {\n      id: crud.id,\n    };\n  }\n\n  _serverTeamPermissionDefinitionFromCrud(crud: TeamPermissionDefinitionsCrud['Admin']['Read']): AdminTeamPermissionDefinition {\n    return {\n      id: crud.id,\n      description: crud.description,\n      containedPermissionIds: crud.contained_permission_ids,\n    };\n  }\n\n  _serverProjectPermissionDefinitionFromCrud(crud: ProjectPermissionDefinitionsCrud['Admin']['Read']): AdminProjectPermissionDefinition {\n    return {\n      id: crud.id,\n      description: crud.description,\n      containedPermissionIds: crud.contained_permission_ids,\n    };\n  }\n\n  async listTeams(): Promise<ServerTeam[]> {\n    const teams = Result.orThrow(await this._serverTeamsCache.getOrWait([undefined], \"write-only\"));\n    return teams.map((t) => this._serverTeamFromCrud(t));\n  }\n\n  async getItem(options: { itemId: string, userId: string } | { itemId: string, teamId: string } | { itemId: string, customCustomerId: string }): Promise<ServerItem> {\n    if (\"userId\" in options) {\n      const result = Result.orThrow(await this._serverUserItemsCache.getOrWait([options.userId, options.itemId], \"write-only\"));\n      return this._serverItemFromCrud({ type: \"user\", id: options.userId }, result);\n    } else if (\"teamId\" in options) {\n      const result = Result.orThrow(await this._serverTeamItemsCache.getOrWait([options.teamId, options.itemId], \"write-only\"));\n      return this._serverItemFromCrud({ type: \"team\", id: options.teamId }, result);\n    } else {\n      const result = Result.orThrow(await this._serverCustomItemsCache.getOrWait([options.customCustomerId, options.itemId], \"write-only\"));\n      return this._serverItemFromCrud({ type: \"custom\", id: options.customCustomerId }, result);\n    }\n  }\n\n  useItem(options: { itemId: string, userId: string } | { itemId: string, teamId: string } | { itemId: string, customCustomerId: string }): ServerItem {\n    let type: \"user\" | \"team\" | \"custom\";\n    let id: string;\n    let cache: AsyncCache<[string, string], Result<ItemCrud['Client']['Read']>>;\n    if (\"userId\" in options) {\n      type = \"user\";\n      id = options.userId;\n      cache = this._serverUserItemsCache;\n    } else if (\"teamId\" in options) {\n      type = \"team\";\n      id = options.teamId;\n      cache = this._serverTeamItemsCache;\n    } else {\n      type = \"custom\";\n      id = options.customCustomerId;\n      cache = this._serverCustomItemsCache;\n    }\n\n    const cacheKey = [id, options.itemId] as [string, string];\n    const debugLabel = \"serverApp.useItem()\";\n    const result = useAsyncCache(cache, cacheKey, debugLabel);\n    return useMemo(() => this._serverItemFromCrud({ type, id }, result), [result]);\n  }\n  async grantProduct(options: (\n    ({ userId: string } | { teamId: string } | { customCustomerId: string }) &\n    ({ productId: string } | { product: InlineProduct }) &\n    { quantity?: number }\n  )): Promise<void> {\n    let customerType: \"user\" | \"team\" | \"custom\";\n    let customerId: string;\n    if (\"userId\" in options) {\n      customerType = \"user\";\n      customerId = options.userId;\n    } else if (\"teamId\" in options) {\n      customerType = \"team\";\n      customerId = options.teamId;\n    } else {\n      customerType = \"custom\";\n      customerId = options.customCustomerId;\n    }\n\n    await this._interface.grantProduct({\n      customerType,\n      customerId,\n      productId: \"productId\" in options ? options.productId : undefined,\n      product: \"product\" in options ? options.product : undefined,\n      quantity: options.quantity,\n    });\n\n    const cache = customerType === \"user\"\n      ? this._serverUserProductsCache\n      : customerType === \"team\"\n        ? this._serverTeamProductsCache\n        : this._serverCustomProductsCache;\n    await cache.refresh([customerId, null, null]);\n  }\n\n  async createTeam(data: ServerTeamCreateOptions): Promise<ServerTeam> {\n    const team = await this._interface.createServerTeam(serverTeamCreateOptionsToCrud(data));\n    await this._serverTeamsCache.refresh([undefined]);\n    return this._serverTeamFromCrud(team);\n  }\n\n  useTeams(): ServerTeam[] {\n    const teams = useAsyncCache(this._serverTeamsCache, [undefined], \"serverApp.useTeams()\");\n    return useMemo(() => {\n      return teams.map((t) => this._serverTeamFromCrud(t));\n    }, [teams]);\n  }\n\n  async getTeam(options: { apiKey: string }): Promise<ServerTeam | null>;\n  async getTeam(teamId: string): Promise<ServerTeam | null>;\n  async getTeam(options?: { apiKey: string } | string): Promise<ServerTeam | null> {\n    if (typeof options === \"object\" && \"apiKey\" in options) {\n      return await this._getTeamByApiKey(options.apiKey);\n    } else {\n      const teamId = options;\n      const teams = await this.listTeams();\n      return teams.find((t) => t.id === teamId) ?? null;\n    }\n  }\n\n  useTeam(options: { apiKey: string }): ServerTeam | null;\n  useTeam(teamId: string): ServerTeam | null;\n  useTeam(options?: { apiKey: string } | string): ServerTeam | null {\n    if (typeof options === \"object\" && \"apiKey\" in options) {\n      return this._useTeamByApiKey(options.apiKey);\n    } else {\n      const teamId = options;\n      const teams = this.useTeams();\n      return useMemo(() => {\n        return teams.find((t) => t.id === teamId) ?? null;\n      }, [teams, teamId]);\n    }\n  }\n\n  protected _createServerDataVaultStore(id: string): DataVaultStore {\n    const validateOptions = (options: { secret: string }) => {\n      if (typeof options.secret !== \"string\") throw new Error(\"secret must be a string, got \" + typeof options.secret);\n    };\n    return {\n      id,\n      setValue: async (key, value, options) => {\n        validateOptions(options);\n        await this._interface.setDataVaultStoreValue(options.secret, id, key, value);\n      },\n      getValue: async (key, options) => {\n        validateOptions(options);\n        return Result.orThrow(await this._serverDataVaultStoreValueCache.getOrWait([id, key, options.secret], \"write-only\"));\n      },\n      useValue: (key, options) => {\n        validateOptions(options);\n        return useAsyncCache(this._serverDataVaultStoreValueCache, [id, key, options.secret] as const, \"store.useValue()\");\n      },\n    };\n  }\n\n  async getDataVaultStore(id: string): Promise<DataVaultStore> {\n    return this._createServerDataVaultStore(id);\n  }\n\n  useDataVaultStore(id: string): DataVaultStore {\n    return useMemo(() => this._createServerDataVaultStore(id), [id]);\n  }\n\n  async sendEmail(options: SendEmailOptions): Promise<void> {\n    await this._interface.sendEmail(options);\n  }\n\n  protected override async _refreshSession(session: InternalSession) {\n    await Promise.all([\n      super._refreshUser(session),\n      this._currentServerUserCache.refresh([session]),\n    ]);\n  }\n\n  protected override async _refreshUsers() {\n    await Promise.all([\n      super._refreshUsers(),\n      this._serverUserCache.refreshWhere(() => true),\n      this._serverUsersCache.refreshWhere(() => true),\n      this._serverContactChannelsCache.refreshWhere(() => true),\n      this._serverOAuthProvidersCache.refreshWhere(() => true),\n    ]);\n  }\n\n  async createOAuthProvider(options: {\n    userId: string,\n    providerConfigId: string,\n    accountId: string,\n    email: string,\n    allowSignIn: boolean,\n    allowConnectedAccounts: boolean,\n  }): Promise<Result<ServerOAuthProvider, InstanceType<typeof KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn>>> {\n    try {\n      const crud = await this._interface.createServerOAuthProvider({\n        user_id: options.userId,\n        provider_config_id: options.providerConfigId,\n        account_id: options.accountId,\n        email: options.email,\n        allow_sign_in: options.allowSignIn,\n        allow_connected_accounts: options.allowConnectedAccounts,\n      });\n\n      await this._serverOAuthProvidersCache.refresh([options.userId]);\n      return Result.ok(this._serverOAuthProviderFromCrud(crud));\n    } catch (error) {\n      if (KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn.isInstance(error)) {\n        return Result.error(error);\n      }\n      throw error;\n    }\n  }\n}\n"],"mappings":"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","names":["crud"]}