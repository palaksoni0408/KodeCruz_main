"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/lib/stack-app/apps/implementations/server-app-impl.ts
var server_app_impl_exports = {};
__export(server_app_impl_exports, {
  _StackServerAppImplIncomplete: () => _StackServerAppImplIncomplete
});
module.exports = __toCommonJS(server_app_impl_exports);
var import_stack_shared = require("@stackframe/stack-shared");
var import_sessions = require("@stackframe/stack-shared/dist/sessions");
var import_errors = require("@stackframe/stack-shared/dist/utils/errors");
var import_promises = require("@stackframe/stack-shared/dist/utils/promises");
var import_react = require("@stackframe/stack-shared/dist/utils/react");
var import_results = require("@stackframe/stack-shared/dist/utils/results");
var import_react2 = require("react");
var import_url = require("../../../../utils/url.js");
var import_api_keys = require("../../api-keys/index.js");
var import_contact_channels = require("../../contact-channels/index.js");
var import_teams = require("../../teams/index.js");
var import_users = require("../../users/index.js");
var import_client_app_impl = require("./client-app-impl.js");
var import_common = require("./common.js");
var import_browser = require("@simplewebauthn/browser");
var import_common2 = require("./common.js");
var _StackServerAppImplIncomplete = class extends import_client_app_impl._StackClientAppImplIncomplete {
  constructor(options, extraOptions) {
    const resolvedOptions = (0, import_common.resolveConstructorOptions)(options);
    super(resolvedOptions, {
      ...extraOptions,
      interface: extraOptions?.interface ?? new import_stack_shared.StackServerInterface({
        getBaseUrl: () => (0, import_common.getBaseUrl)(resolvedOptions.baseUrl),
        projectId: resolvedOptions.projectId ?? (0, import_common.getDefaultProjectId)(),
        extraRequestHeaders: resolvedOptions.extraRequestHeaders ?? (0, import_common.getDefaultExtraRequestHeaders)(),
        clientVersion: import_common.clientVersion,
        publishableClientKey: resolvedOptions.publishableClientKey ?? (0, import_common.getDefaultPublishableClientKey)(),
        secretServerKey: resolvedOptions.secretServerKey ?? (0, import_common.getDefaultSecretServerKey)()
      })
    });
    // TODO override the client user cache to use the server user cache, so we save some requests
    this._currentServerUserCache = (0, import_common.createCacheBySession)(async (session) => {
      if (session.isKnownToBeInvalid()) {
        return null;
      }
      return await this._interface.getServerUserByToken(session);
    });
    this._serverUsersCache = (0, import_common.createCache)(async ([cursor, limit, orderBy, desc, query, includeAnonymous]) => {
      return await this._interface.listServerUsers({ cursor, limit, orderBy, desc, query, includeAnonymous });
    });
    this._serverUserCache = (0, import_common.createCache)(async ([userId]) => {
      const user = await this._interface.getServerUserById(userId);
      return import_results.Result.or(user, null);
    });
    this._serverTeamsCache = (0, import_common.createCache)(async ([userId]) => {
      return await this._interface.listServerTeams({ userId });
    });
    this._serverTeamUserPermissionsCache = (0, import_common.createCache)(async ([teamId, userId, recursive]) => {
      return await this._interface.listServerTeamPermissions({ teamId, userId, recursive }, null);
    });
    this._serverUserProjectPermissionsCache = (0, import_common.createCache)(async ([userId, recursive]) => {
      return await this._interface.listServerProjectPermissions({ userId, recursive }, null);
    });
    this._serverUserOAuthConnectionAccessTokensCache = (0, import_common.createCache)(
      async ([userId, providerId, scope]) => {
        try {
          const result = await this._interface.createServerProviderAccessToken(userId, providerId, scope || "");
          return { accessToken: result.access_token };
        } catch (err) {
          if (!(import_stack_shared.KnownErrors.OAuthConnectionDoesNotHaveRequiredScope.isInstance(err) || import_stack_shared.KnownErrors.OAuthConnectionNotConnectedToUser.isInstance(err))) {
            throw err;
          }
        }
        return null;
      }
    );
    this._serverUserOAuthConnectionCache = (0, import_common.createCache)(
      async ([userId, providerId, scope, redirect]) => {
        return await this._getUserOAuthConnectionCacheFn({
          getUser: async () => import_results.Result.orThrow(await this._serverUserCache.getOrWait([userId], "write-only")),
          getOrWaitOAuthToken: async () => import_results.Result.orThrow(await this._serverUserOAuthConnectionAccessTokensCache.getOrWait([userId, providerId, scope || ""], "write-only")),
          useOAuthToken: () => (0, import_common2.useAsyncCache)(this._serverUserOAuthConnectionAccessTokensCache, [userId, providerId, scope || ""], "user.useConnectedAccount()"),
          providerId,
          scope,
          redirect,
          session: null
        });
      }
    );
    this._serverTeamMemberProfilesCache = (0, import_common.createCache)(
      async ([teamId]) => {
        return await this._interface.listServerTeamMemberProfiles({ teamId });
      }
    );
    this._serverTeamInvitationsCache = (0, import_common.createCache)(
      async ([teamId]) => {
        return await this._interface.listServerTeamInvitations({ teamId });
      }
    );
    this._serverUserTeamProfileCache = (0, import_common.createCache)(
      async ([teamId, userId]) => {
        return await this._interface.getServerTeamMemberProfile({ teamId, userId });
      }
    );
    this._serverContactChannelsCache = (0, import_common.createCache)(
      async ([userId]) => {
        return await this._interface.listServerContactChannels(userId);
      }
    );
    this._serverNotificationCategoriesCache = (0, import_common.createCache)(
      async ([userId]) => {
        return await this._interface.listServerNotificationCategories(userId);
      }
    );
    this._serverDataVaultStoreValueCache = (0, import_common.createCache)(async ([storeId, key, secret]) => {
      return await this._interface.getDataVaultStoreValue(secret, storeId, key);
    });
    this._serverUserApiKeysCache = (0, import_common.createCache)(
      async ([userId]) => {
        const result = await this._interface.listProjectApiKeys({
          user_id: userId
        }, null, "server");
        return result;
      }
    );
    this._serverTeamApiKeysCache = (0, import_common.createCache)(
      async ([teamId]) => {
        const result = await this._interface.listProjectApiKeys({
          team_id: teamId
        }, null, "server");
        return result;
      }
    );
    this._convexIdentitySubjectCache = (0, import_common.createCache)(
      async ([ctx]) => {
        const identity = await ctx.auth.getUserIdentity();
        return identity ? identity.subject : null;
      }
    );
    this._serverCheckApiKeyCache = (0, import_common.createCache)(async ([type, apiKey]) => {
      const result = await this._interface.checkProjectApiKey(
        type,
        apiKey,
        null,
        "server"
      );
      return result;
    });
    this._serverOAuthProvidersCache = (0, import_common.createCache)(
      async ([userId]) => {
        return await this._interface.listServerOAuthProviders({ user_id: userId });
      }
    );
    this._serverTeamItemsCache = (0, import_common.createCache)(
      async ([teamId, itemId]) => {
        return await this._interface.getItem({ teamId, itemId }, null);
      }
    );
    this._serverUserItemsCache = (0, import_common.createCache)(
      async ([userId, itemId]) => {
        return await this._interface.getItem({ userId, itemId }, null);
      }
    );
    this._serverCustomItemsCache = (0, import_common.createCache)(
      async ([customCustomerId, itemId]) => {
        return await this._interface.getItem({ customCustomerId, itemId }, null);
      }
    );
    this._serverUserProductsCache = (0, import_common.createCache)(
      async ([userId, cursor, limit]) => {
        return await this._interface.listProducts({
          customer_type: "user",
          customer_id: userId,
          cursor: cursor ?? void 0,
          limit: limit ?? void 0
        }, null);
      }
    );
    this._serverTeamProductsCache = (0, import_common.createCache)(
      async ([teamId, cursor, limit]) => {
        return await this._interface.listProducts({
          customer_type: "team",
          customer_id: teamId,
          cursor: cursor ?? void 0,
          limit: limit ?? void 0
        }, null);
      }
    );
    this._serverCustomProductsCache = (0, import_common.createCache)(
      async ([customCustomerId, cursor, limit]) => {
        return await this._interface.listProducts({
          customer_type: "custom",
          customer_id: customCustomerId,
          cursor: cursor ?? void 0,
          limit: limit ?? void 0
        }, null);
      }
    );
  }
  _createServerCustomer(userIdOrTeamId, type) {
    const app = this;
    const productsCache = type === "user" ? app._serverUserProductsCache : app._serverTeamProductsCache;
    const customerOptions = type === "user" ? { userId: userIdOrTeamId } : { teamId: userIdOrTeamId };
    return {
      ...this._createCustomer(userIdOrTeamId, type, null),
      async getItem(itemId) {
        return await app.getItem({ itemId, ...customerOptions });
      },
      useItem(itemId) {
        return app.useItem({ itemId, ...customerOptions });
      },
      async grantProduct(productOptions) {
        if (type === "user") {
          if ("productId" in productOptions) {
            await app.grantProduct({ userId: userIdOrTeamId, productId: productOptions.productId, quantity: productOptions.quantity });
          } else {
            await app.grantProduct({ userId: userIdOrTeamId, product: productOptions.product, quantity: productOptions.quantity });
          }
        } else {
          if ("productId" in productOptions) {
            await app.grantProduct({ teamId: userIdOrTeamId, productId: productOptions.productId, quantity: productOptions.quantity });
          } else {
            await app.grantProduct({ teamId: userIdOrTeamId, product: productOptions.product, quantity: productOptions.quantity });
          }
        }
        await productsCache.refresh([userIdOrTeamId, null, null]);
      },
      async createCheckoutUrl(options) {
        const productIdOrInline = "productId" in options ? options.productId : options.product;
        return await app._interface.createCheckoutUrl(type, userIdOrTeamId, productIdOrInline, null, options.returnUrl);
      }
    };
  }
  async _updateServerUser(userId, update) {
    const result = await this._interface.updateServerUser(userId, (0, import_users.serverUserUpdateOptionsToCrud)(update));
    await this._refreshUsers();
    return result;
  }
  _serverEditableTeamProfileFromCrud(crud) {
    const app = this;
    return {
      displayName: crud.display_name,
      profileImageUrl: crud.profile_image_url,
      async update(update) {
        await app._interface.updateServerTeamMemberProfile({
          teamId: crud.team_id,
          userId: crud.user_id,
          profile: {
            display_name: update.displayName,
            profile_image_url: update.profileImageUrl
          }
        });
        await app._serverUserTeamProfileCache.refresh([crud.team_id, crud.user_id]);
      }
    };
  }
  _serverContactChannelFromCrud(userId, crud) {
    const app = this;
    return {
      id: crud.id,
      value: crud.value,
      type: crud.type,
      isVerified: crud.is_verified,
      isPrimary: crud.is_primary,
      usedForAuth: crud.used_for_auth,
      async sendVerificationEmail(options) {
        await app._interface.sendServerContactChannelVerificationEmail(userId, crud.id, options?.callbackUrl ?? (0, import_url.constructRedirectUrl)(app.urls.emailVerification, "callbackUrl"));
      },
      async update(data) {
        await app._interface.updateServerContactChannel(userId, crud.id, (0, import_contact_channels.serverContactChannelUpdateOptionsToCrud)(data));
        await Promise.all([
          app._serverContactChannelsCache.refresh([userId]),
          app._serverUserCache.refresh([userId])
        ]);
      },
      async delete() {
        await app._interface.deleteServerContactChannel(userId, crud.id);
        await Promise.all([
          app._serverContactChannelsCache.refresh([userId]),
          app._serverUserCache.refresh([userId])
        ]);
      }
    };
  }
  _serverNotificationCategoryFromCrud(userId, crud) {
    const app = this;
    return {
      id: crud.notification_category_id,
      name: crud.notification_category_name,
      enabled: crud.enabled,
      canDisable: crud.can_disable,
      async setEnabled(enabled) {
        await app._interface.setServerNotificationsEnabled(userId, crud.notification_category_id, enabled);
        await app._serverNotificationCategoriesCache.refresh([userId]);
      }
    };
  }
  _serverOAuthProviderFromCrud(crud) {
    const app = this;
    return {
      id: crud.id,
      type: crud.type,
      userId: crud.user_id,
      accountId: crud.account_id,
      email: crud.email,
      allowSignIn: crud.allow_sign_in,
      allowConnectedAccounts: crud.allow_connected_accounts,
      async update(data) {
        try {
          await app._interface.updateServerOAuthProvider(crud.user_id, crud.id, {
            account_id: data.accountId,
            email: data.email,
            allow_sign_in: data.allowSignIn,
            allow_connected_accounts: data.allowConnectedAccounts
          });
          await app._serverOAuthProvidersCache.refresh([crud.user_id]);
          return import_results.Result.ok(void 0);
        } catch (error) {
          if (import_stack_shared.KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn.isInstance(error)) {
            return import_results.Result.error(error);
          }
          throw error;
        }
      },
      async delete() {
        await app._interface.deleteServerOAuthProvider(crud.user_id, crud.id);
        await app._serverOAuthProvidersCache.refresh([crud.user_id]);
      }
    };
  }
  _serverApiKeyFromCrud(crud) {
    return {
      ...this._baseApiKeyFromCrud(crud),
      async revoke() {
        await this.update({ revoked: true });
      },
      update: async (options) => {
        await this._interface.updateProjectApiKey(
          crud.type === "team" ? { team_id: crud.team_id } : { user_id: crud.user_id },
          crud.id,
          await (0, import_api_keys.apiKeyUpdateOptionsToCrud)(crud.type, options),
          null,
          "server"
        );
        if (crud.type === "team") {
          await this._serverTeamApiKeysCache.refresh([crud.team_id]);
        } else {
          await this._serverUserApiKeysCache.refresh([crud.user_id]);
        }
      }
    };
  }
  _serverUserFromCrud(crud) {
    const app = this;
    async function getConnectedAccount(id, options) {
      const scopeString = options?.scopes?.join(" ");
      return import_results.Result.orThrow(await app._serverUserOAuthConnectionCache.getOrWait([crud.id, id, scopeString || "", options?.or === "redirect"], "write-only"));
    }
    function useConnectedAccount(id, options) {
      const scopeString = options?.scopes?.join(" ");
      return (0, import_common2.useAsyncCache)(app._serverUserOAuthConnectionCache, [crud.id, id, scopeString || "", options?.or === "redirect"], "user.useConnectedAccount()");
    }
    const serverUser = {
      ...super._createBaseUser(crud),
      lastActiveAt: new Date(crud.last_active_at_millis),
      serverMetadata: crud.server_metadata,
      async setPrimaryEmail(email, options) {
        await app._updateServerUser(crud.id, { primaryEmail: email, primaryEmailVerified: options?.verified });
      },
      async grantPermission(scopeOrPermissionId, permissionId) {
        if (scopeOrPermissionId && typeof scopeOrPermissionId !== "string" && permissionId) {
          const scope = scopeOrPermissionId;
          await app._interface.grantServerTeamUserPermission(scope.id, crud.id, permissionId);
          for (const recursive of [true, false]) {
            await app._serverTeamUserPermissionsCache.refresh([scope.id, crud.id, recursive]);
          }
        } else {
          const pId = scopeOrPermissionId;
          await app._interface.grantServerProjectPermission(crud.id, pId);
          for (const recursive of [true, false]) {
            await app._serverUserProjectPermissionsCache.refresh([crud.id, recursive]);
          }
        }
      },
      async revokePermission(scopeOrPermissionId, permissionId) {
        if (scopeOrPermissionId && typeof scopeOrPermissionId !== "string" && permissionId) {
          const scope = scopeOrPermissionId;
          await app._interface.revokeServerTeamUserPermission(scope.id, crud.id, permissionId);
          for (const recursive of [true, false]) {
            await app._serverTeamUserPermissionsCache.refresh([scope.id, crud.id, recursive]);
          }
        } else {
          const pId = scopeOrPermissionId;
          await app._interface.revokeServerProjectPermission(crud.id, pId);
          for (const recursive of [true, false]) {
            await app._serverUserProjectPermissionsCache.refresh([crud.id, recursive]);
          }
        }
      },
      async delete() {
        const res = await app._interface.deleteServerUser(crud.id);
        await app._refreshUsers();
        return res;
      },
      async createSession(options) {
        const tokens = await app._interface.createServerUserSession(crud.id, options.expiresInMillis ?? 1e3 * 60 * 60 * 24 * 365, options.isImpersonation ?? false);
        return {
          async getTokens() {
            return tokens;
          }
        };
      },
      async getActiveSessions() {
        const sessions = await app._interface.listServerSessions(crud.id);
        return sessions.map((session) => app._clientSessionFromCrud(session));
      },
      async revokeSession(sessionId) {
        await app._interface.deleteServerSession(sessionId);
      },
      async setDisplayName(displayName) {
        return await this.update({ displayName });
      },
      async setClientMetadata(metadata) {
        return await this.update({ clientMetadata: metadata });
      },
      async setClientReadOnlyMetadata(metadata) {
        return await this.update({ clientReadOnlyMetadata: metadata });
      },
      async setServerMetadata(metadata) {
        return await this.update({ serverMetadata: metadata });
      },
      async setSelectedTeam(team) {
        return await this.update({ selectedTeamId: team?.id ?? null });
      },
      getConnectedAccount,
      useConnectedAccount,
      // THIS_LINE_PLATFORM react-like
      selectedTeam: crud.selected_team ? app._serverTeamFromCrud(crud.selected_team) : null,
      async getTeam(teamId) {
        const teams = await this.listTeams();
        return teams.find((t) => t.id === teamId) ?? null;
      },
      useTeam(teamId) {
        const teams = this.useTeams();
        return (0, import_react2.useMemo)(() => {
          return teams.find((t) => t.id === teamId) ?? null;
        }, [teams, teamId]);
      },
      async listTeams() {
        const teams = import_results.Result.orThrow(await app._serverTeamsCache.getOrWait([crud.id], "write-only"));
        return teams.map((t) => app._serverTeamFromCrud(t));
      },
      useTeams() {
        const teams = (0, import_common2.useAsyncCache)(app._serverTeamsCache, [crud.id], "user.useTeams()");
        return (0, import_react2.useMemo)(() => teams.map((t) => app._serverTeamFromCrud(t)), [teams]);
      },
      createTeam: async (data) => {
        const team = await app._interface.createServerTeam((0, import_teams.serverTeamCreateOptionsToCrud)({
          creatorUserId: crud.id,
          ...data
        }));
        await app._serverTeamsCache.refresh([void 0]);
        await app._updateServerUser(crud.id, { selectedTeamId: team.id });
        return app._serverTeamFromCrud(team);
      },
      leaveTeam: async (team) => {
        await app._interface.leaveServerTeam({ teamId: team.id, userId: crud.id });
      },
      async listPermissions(scopeOrOptions, options) {
        if (scopeOrOptions && "id" in scopeOrOptions) {
          const scope = scopeOrOptions;
          const recursive = options?.recursive ?? true;
          const permissions = import_results.Result.orThrow(await app._serverTeamUserPermissionsCache.getOrWait([scope.id, crud.id, recursive], "write-only"));
          return permissions.map((crud2) => app._serverPermissionFromCrud(crud2));
        } else {
          const opts = scopeOrOptions;
          const recursive = opts?.recursive ?? true;
          const permissions = import_results.Result.orThrow(await app._serverUserProjectPermissionsCache.getOrWait([crud.id, recursive], "write-only"));
          return permissions.map((crud2) => app._serverPermissionFromCrud(crud2));
        }
      },
      usePermissions(scopeOrOptions, options) {
        if (scopeOrOptions && "id" in scopeOrOptions) {
          const scope = scopeOrOptions;
          const recursive = options?.recursive ?? true;
          const permissions = (0, import_common2.useAsyncCache)(app._serverTeamUserPermissionsCache, [scope.id, crud.id, recursive], "user.usePermissions()");
          return (0, import_react2.useMemo)(() => permissions.map((crud2) => app._serverPermissionFromCrud(crud2)), [permissions]);
        } else {
          const opts = scopeOrOptions;
          const recursive = opts?.recursive ?? true;
          const permissions = (0, import_common2.useAsyncCache)(app._serverUserProjectPermissionsCache, [crud.id, recursive], "user.usePermissions()");
          return (0, import_react2.useMemo)(() => permissions.map((crud2) => app._serverPermissionFromCrud(crud2)), [permissions]);
        }
      },
      async getPermission(scopeOrPermissionId, permissionId) {
        if (scopeOrPermissionId && typeof scopeOrPermissionId !== "string") {
          const scope = scopeOrPermissionId;
          const permissions = await this.listPermissions(scope);
          return permissions.find((p) => p.id === permissionId) ?? null;
        } else {
          const pid = scopeOrPermissionId;
          const permissions = await this.listPermissions();
          return permissions.find((p) => p.id === pid) ?? null;
        }
      },
      usePermission(scopeOrPermissionId, permissionId) {
        if (scopeOrPermissionId && typeof scopeOrPermissionId !== "string") {
          const scope = scopeOrPermissionId;
          const permissions = this.usePermissions(scope);
          return (0, import_react2.useMemo)(() => permissions.find((p) => p.id === permissionId) ?? null, [permissions, permissionId]);
        } else {
          const pid = scopeOrPermissionId;
          const permissions = this.usePermissions();
          return (0, import_react2.useMemo)(() => permissions.find((p) => p.id === pid) ?? null, [permissions, pid]);
        }
      },
      async hasPermission(scopeOrPermissionId, permissionId) {
        if (scopeOrPermissionId && typeof scopeOrPermissionId !== "string") {
          const scope = scopeOrPermissionId;
          return await this.getPermission(scope, permissionId) !== null;
        } else {
          const pid = scopeOrPermissionId;
          return await this.getPermission(pid) !== null;
        }
      },
      async update(update) {
        await app._updateServerUser(crud.id, update);
      },
      async sendVerificationEmail() {
        return await app._checkFeatureSupport("sendVerificationEmail() on ServerUser", {});
      },
      async updatePassword(options) {
        const result = await app._interface.updatePassword(options);
        await app._serverUserCache.refresh([crud.id]);
        return result;
      },
      async setPassword(options) {
        const result = await this.update(options);
        await app._serverUserCache.refresh([crud.id]);
        return result;
      },
      async getTeamProfile(team) {
        const result = import_results.Result.orThrow(await app._serverUserTeamProfileCache.getOrWait([team.id, crud.id], "write-only"));
        return app._serverEditableTeamProfileFromCrud(result);
      },
      useTeamProfile(team) {
        const result = (0, import_common2.useAsyncCache)(app._serverUserTeamProfileCache, [team.id, crud.id], "user.useTeamProfile()");
        return (0, import_react2.useMemo)(() => app._serverEditableTeamProfileFromCrud(result), [result]);
      },
      async listContactChannels() {
        const result = import_results.Result.orThrow(await app._serverContactChannelsCache.getOrWait([crud.id], "write-only"));
        return result.map((data) => app._serverContactChannelFromCrud(crud.id, data));
      },
      useContactChannels() {
        const result = (0, import_common2.useAsyncCache)(app._serverContactChannelsCache, [crud.id], "user.useContactChannels()");
        return (0, import_react2.useMemo)(() => result.map((data) => app._serverContactChannelFromCrud(crud.id, data)), [result]);
      },
      createContactChannel: async (data) => {
        const contactChannel = await app._interface.createServerContactChannel((0, import_contact_channels.serverContactChannelCreateOptionsToCrud)(crud.id, data));
        await Promise.all([
          app._serverContactChannelsCache.refresh([crud.id]),
          app._serverUserCache.refresh([crud.id])
        ]);
        return app._serverContactChannelFromCrud(crud.id, contactChannel);
      },
      useNotificationCategories() {
        const results = (0, import_common2.useAsyncCache)(app._serverNotificationCategoriesCache, [crud.id], "user.useNotificationCategories()");
        return results.map((category) => app._serverNotificationCategoryFromCrud(crud.id, category));
      },
      async listNotificationCategories() {
        const results = import_results.Result.orThrow(await app._serverNotificationCategoriesCache.getOrWait([crud.id], "write-only"));
        return results.map((category) => app._serverNotificationCategoryFromCrud(crud.id, category));
      },
      useApiKeys() {
        const result = (0, import_common2.useAsyncCache)(app._serverUserApiKeysCache, [crud.id], "user.useApiKeys()");
        return result.map((apiKey) => app._serverApiKeyFromCrud(apiKey));
      },
      async listApiKeys() {
        const result = import_results.Result.orThrow(await app._serverUserApiKeysCache.getOrWait([crud.id], "write-only"));
        return result.map((apiKey) => app._serverApiKeyFromCrud(apiKey));
      },
      async createApiKey(options) {
        const result = await app._interface.createProjectApiKey(
          await (0, import_api_keys.apiKeyCreationOptionsToCrud)("user", crud.id, options),
          null,
          "server"
        );
        await app._serverUserApiKeysCache.refresh([crud.id]);
        return app._serverApiKeyFromCrud(result);
      },
      useOAuthProviders() {
        const results = (0, import_common2.useAsyncCache)(app._serverOAuthProvidersCache, [crud.id], "user.useOAuthProviders()");
        return (0, import_react2.useMemo)(() => results.map((oauthCrud) => app._serverOAuthProviderFromCrud(oauthCrud)), [results]);
      },
      async listOAuthProviders() {
        const results = import_results.Result.orThrow(await app._serverOAuthProvidersCache.getOrWait([crud.id], "write-only"));
        return results.map((oauthCrud) => app._serverOAuthProviderFromCrud(oauthCrud));
      },
      useOAuthProvider(id) {
        const providers = this.useOAuthProviders();
        return (0, import_react2.useMemo)(() => providers.find((p) => p.id === id) ?? null, [providers, id]);
      },
      async getOAuthProvider(id) {
        const providers = await this.listOAuthProviders();
        return providers.find((p) => p.id === id) ?? null;
      },
      async registerPasskey(options) {
        const hostname = options?.hostname || (await app._getCurrentUrl())?.hostname;
        if (!hostname) {
          throw new import_errors.StackAssertionError("hostname must be provided if the Stack App does not have a redirect method");
        }
        const initiationResult = await app._interface.initiateServerPasskeyRegistration(crud.id);
        if (initiationResult.status !== "ok") {
          return import_results.Result.error(new import_stack_shared.KnownErrors.PasskeyRegistrationFailed("Failed to get initiation options for passkey registration"));
        }
        const { options_json, code } = initiationResult.data;
        if (options_json.rp.id !== "THIS_VALUE_WILL_BE_REPLACED.example.com") {
          throw new import_errors.StackAssertionError(`Expected returned RP ID from server to equal sentinel, but found ${options_json.rp.id}`);
        }
        options_json.rp.id = hostname;
        let attResp;
        try {
          attResp = await (0, import_browser.startRegistration)({ optionsJSON: options_json });
        } catch (error) {
          if (error instanceof import_browser.WebAuthnError) {
            return import_results.Result.error(new import_stack_shared.KnownErrors.PasskeyWebAuthnError(error.message, error.name));
          } else {
            (0, import_errors.captureError)("passkey-registration-failed", error);
            return import_results.Result.error(new import_stack_shared.KnownErrors.PasskeyRegistrationFailed("Failed to start passkey registration due to unknown error"));
          }
        }
        const { accessToken, refreshToken } = await app._interface.createServerUserSession(crud.id, 6e4 * 2, false);
        const tempSession = new import_sessions.InternalSession({
          accessToken,
          refreshToken,
          refreshAccessTokenCallback: async () => null
        });
        const registrationResult = await app._interface.registerPasskey({ credential: attResp, code }, tempSession);
        await app._serverUserCache.refresh([crud.id]);
        return registrationResult;
      },
      ...app._createServerCustomer(crud.id, "user")
    };
    (0, import_users.attachUserDestructureGuard)(serverUser);
    return serverUser;
  }
  _serverTeamUserFromCrud(crud) {
    const teamUser = {
      ...this._serverUserFromCrud(crud.user),
      teamProfile: {
        displayName: crud.display_name,
        profileImageUrl: crud.profile_image_url
      }
    };
    (0, import_users.attachUserDestructureGuard)(teamUser);
    return teamUser;
  }
  _serverTeamInvitationFromCrud(crud) {
    return {
      id: crud.id,
      recipientEmail: crud.recipient_email,
      expiresAt: new Date(crud.expires_at_millis),
      revoke: async () => {
        await this._interface.revokeServerTeamInvitation(crud.id, crud.team_id);
        await this._serverTeamInvitationsCache.refresh([crud.team_id]);
      }
    };
  }
  _currentUserFromCrud(crud, session) {
    const currentUser = {
      ...this._serverUserFromCrud(crud),
      ...this._createAuth(session),
      ...this._isInternalProject() ? this._createInternalUserExtra(session) : {}
    };
    (0, import_users.attachUserDestructureGuard)(currentUser);
    Object.freeze(currentUser);
    return currentUser;
  }
  _serverTeamFromCrud(crud) {
    const app = this;
    return {
      id: crud.id,
      displayName: crud.display_name,
      profileImageUrl: crud.profile_image_url,
      createdAt: new Date(crud.created_at_millis),
      clientMetadata: crud.client_metadata,
      clientReadOnlyMetadata: crud.client_read_only_metadata,
      serverMetadata: crud.server_metadata,
      async update(update) {
        await app._interface.updateServerTeam(crud.id, (0, import_teams.serverTeamUpdateOptionsToCrud)(update));
        await app._serverTeamsCache.refresh([void 0]);
      },
      async delete() {
        await app._interface.deleteServerTeam(crud.id);
        await app._serverTeamsCache.refresh([void 0]);
      },
      async listUsers() {
        const result = import_results.Result.orThrow(await app._serverTeamMemberProfilesCache.getOrWait([crud.id], "write-only"));
        return result.map((u) => app._serverTeamUserFromCrud(u));
      },
      useUsers() {
        const result = (0, import_common2.useAsyncCache)(app._serverTeamMemberProfilesCache, [crud.id], "team.useUsers()");
        return (0, import_react2.useMemo)(() => result.map((u) => app._serverTeamUserFromCrud(u)), [result]);
      },
      async addUser(userId) {
        await app._interface.addServerUserToTeam({
          teamId: crud.id,
          userId
        });
        await app._serverTeamMemberProfilesCache.refresh([crud.id]);
      },
      async removeUser(userId) {
        await app._interface.removeServerUserFromTeam({
          teamId: crud.id,
          userId
        });
        await app._serverTeamMemberProfilesCache.refresh([crud.id]);
      },
      async inviteUser(options) {
        await app._interface.sendServerTeamInvitation({
          teamId: crud.id,
          email: options.email,
          callbackUrl: options.callbackUrl ?? (0, import_url.constructRedirectUrl)(app.urls.teamInvitation, "callbackUrl")
        });
        await app._serverTeamInvitationsCache.refresh([crud.id]);
      },
      async listInvitations() {
        const result = import_results.Result.orThrow(await app._serverTeamInvitationsCache.getOrWait([crud.id], "write-only"));
        return result.map((crud2) => app._serverTeamInvitationFromCrud(crud2));
      },
      useInvitations() {
        const result = (0, import_common2.useAsyncCache)(app._serverTeamInvitationsCache, [crud.id], "team.useInvitations()");
        return (0, import_react2.useMemo)(() => result.map((crud2) => app._serverTeamInvitationFromCrud(crud2)), [result]);
      },
      useApiKeys() {
        const result = (0, import_common2.useAsyncCache)(app._serverTeamApiKeysCache, [crud.id], "team.useApiKeys()");
        return result.map((apiKey) => app._serverApiKeyFromCrud(apiKey));
      },
      async listApiKeys() {
        const result = import_results.Result.orThrow(await app._serverTeamApiKeysCache.getOrWait([crud.id], "write-only"));
        return result.map((apiKey) => app._serverApiKeyFromCrud(apiKey));
      },
      async createApiKey(options) {
        const result = await app._interface.createProjectApiKey(
          await (0, import_api_keys.apiKeyCreationOptionsToCrud)("team", crud.id, options),
          null,
          "server"
        );
        await app._serverTeamApiKeysCache.refresh([crud.id]);
        return app._serverApiKeyFromCrud(result);
      },
      ...app._createServerCustomer(crud.id, "team")
    };
  }
  _serverItemFromCrud(customer, crud) {
    const app = this;
    return {
      displayName: crud.display_name,
      quantity: crud.quantity,
      nonNegativeQuantity: Math.max(0, crud.quantity),
      increaseQuantity: async (delta) => {
        const updateOptions = customer.type === "user" ? { itemId: crud.id, userId: customer.id } : customer.type === "team" ? { itemId: crud.id, teamId: customer.id } : { itemId: crud.id, customCustomerId: customer.id };
        await app._interface.updateItemQuantity(updateOptions, { delta });
        if (customer.type === "user") await app._serverUserItemsCache.refresh([customer.id, crud.id]);
        else if (customer.type === "team") await app._serverTeamItemsCache.refresh([customer.id, crud.id]);
        else await app._serverCustomItemsCache.refresh([customer.id, crud.id]);
      },
      decreaseQuantity: async (delta) => {
        const updateOptions = customer.type === "user" ? { itemId: crud.id, userId: customer.id } : customer.type === "team" ? { itemId: crud.id, teamId: customer.id } : { itemId: crud.id, customCustomerId: customer.id };
        await app._interface.updateItemQuantity(updateOptions, { delta: -delta, allow_negative: true });
        if (customer.type === "user") await app._serverUserItemsCache.refresh([customer.id, crud.id]);
        else if (customer.type === "team") await app._serverTeamItemsCache.refresh([customer.id, crud.id]);
        else await app._serverCustomItemsCache.refresh([customer.id, crud.id]);
      },
      tryDecreaseQuantity: async (delta) => {
        try {
          const updateOptions = customer.type === "user" ? { itemId: crud.id, userId: customer.id } : customer.type === "team" ? { itemId: crud.id, teamId: customer.id } : { itemId: crud.id, customCustomerId: customer.id };
          await app._interface.updateItemQuantity(updateOptions, { delta: -delta });
          if (customer.type === "user") await app._serverUserItemsCache.refresh([customer.id, crud.id]);
          else if (customer.type === "team") await app._serverTeamItemsCache.refresh([customer.id, crud.id]);
          else await app._serverCustomItemsCache.refresh([customer.id, crud.id]);
          return true;
        } catch (error) {
          if (error instanceof import_stack_shared.KnownErrors.ItemQuantityInsufficientAmount) {
            return false;
          }
          throw error;
        }
      }
    };
  }
  async _getUserApiKey(options) {
    const crud = import_results.Result.orThrow(await this._serverCheckApiKeyCache.getOrWait(["user", options.apiKey], "write-only"));
    return crud ? this._serverApiKeyFromCrud(crud) : null;
  }
  async _getTeamApiKey(options) {
    const crud = import_results.Result.orThrow(await this._serverCheckApiKeyCache.getOrWait(["team", options.apiKey], "write-only"));
    return crud ? this._serverApiKeyFromCrud(crud) : null;
  }
  _useUserApiKey(options) {
    const crud = (0, import_common2.useAsyncCache)(this._serverCheckApiKeyCache, ["user", options.apiKey], "serverApp.useUserApiKey()");
    return (0, import_react2.useMemo)(() => crud ? this._serverApiKeyFromCrud(crud) : null, [crud]);
  }
  _useTeamApiKey(options) {
    const crud = (0, import_common2.useAsyncCache)(this._serverCheckApiKeyCache, ["team", options.apiKey], "serverApp.useTeamApiKey()");
    return (0, import_react2.useMemo)(() => crud ? this._serverApiKeyFromCrud(crud) : null, [crud]);
  }
  async _getUserByApiKey(apiKey) {
    const apiKeyObject = await this._getUserApiKey({ apiKey });
    if (apiKeyObject === null) {
      return null;
    }
    return await this.getServerUserById(apiKeyObject.userId);
  }
  async _getUserByConvex(ctx, includeAnonymous) {
    const identity = await ctx.auth.getUserIdentity();
    if (identity === null) {
      return null;
    }
    const user = await this.getServerUserById(identity.subject);
    if (user?.isAnonymous && !includeAnonymous) {
      return null;
    }
    return user;
  }
  _useUserByConvex(ctx, includeAnonymous) {
    const subject = (0, import_common2.useAsyncCache)(this._convexIdentitySubjectCache, [ctx], "serverApp.useUserByConvex()");
    if (subject === null) {
      return null;
    }
    const user = this.useUserById(subject);
    if (user?.isAnonymous && !includeAnonymous) {
      return null;
    }
    return user;
  }
  _useUserByApiKey(apiKey) {
    const apiKeyObject = this._useUserApiKey({ apiKey });
    if (apiKeyObject === null) {
      return null;
    }
    return this.useUserById(apiKeyObject.userId);
  }
  async _getTeamByApiKey(apiKey) {
    const apiKeyObject = await this._getTeamApiKey({ apiKey });
    if (apiKeyObject === null) {
      return null;
    }
    return await this.getTeam(apiKeyObject.teamId);
  }
  _useTeamByApiKey(apiKey) {
    const apiKeyObject = this._useTeamApiKey({ apiKey });
    if (apiKeyObject === null) {
      return null;
    }
    return this.useTeam(apiKeyObject.teamId);
  }
  async createUser(options) {
    const crud = await this._interface.createServerUser((0, import_users.serverUserCreateOptionsToCrud)(options));
    await this._refreshUsers();
    return this._serverUserFromCrud(crud);
  }
  async getUser(options) {
    if (typeof options === "string") {
      return await this.getServerUserById(options);
    } else if (typeof options === "object" && "apiKey" in options) {
      return await this._getUserByApiKey(options.apiKey);
    } else if (typeof options === "object" && "from" in options && options.from === "convex") {
      return await this._getUserByConvex(options.ctx, "or" in options && options.or === "anonymous");
    } else {
      options = options;
      this._ensurePersistentTokenStore(options?.tokenStore);
      const session = await this._getSession(options?.tokenStore);
      let crud = import_results.Result.orThrow(await this._currentServerUserCache.getOrWait([session], "write-only"));
      if (crud?.is_anonymous && options?.or !== "anonymous" && options?.or !== "anonymous-if-exists[deprecated]") {
        crud = null;
      }
      if (crud === null) {
        switch (options?.or) {
          case "redirect": {
            await this.redirectToSignIn({ replace: true });
            break;
          }
          case "throw": {
            throw new Error("User is not signed in but getUser was called with { or: 'throw' }");
          }
          case "anonymous": {
            const tokens = await this._signUpAnonymously();
            return await this.getUser({ tokenStore: tokens, or: "anonymous-if-exists[deprecated]" }) ?? (0, import_errors.throwErr)("Something went wrong while signing up anonymously");
          }
          case void 0:
          case "anonymous-if-exists[deprecated]":
          case "return-null": {
            return null;
          }
        }
      }
      return crud && this._currentUserFromCrud(crud, session);
    }
  }
  async getServerUser() {
    console.warn("stackServerApp.getServerUser is deprecated; use stackServerApp.getUser instead");
    return await this.getUser();
  }
  async getServerUserById(userId) {
    const crud = import_results.Result.orThrow(await this._serverUserCache.getOrWait([userId], "write-only"));
    return crud && this._serverUserFromCrud(crud);
  }
  useUser(options) {
    if (typeof options === "string") {
      return this.useUserById(options);
    } else if (typeof options === "object" && "apiKey" in options) {
      return this._useUserByApiKey(options.apiKey);
    } else if (typeof options === "object" && "from" in options && options.from === "convex") {
      return this._useUserByConvex(options.ctx, "or" in options && options.or === "anonymous");
    } else {
      options = options;
      this._ensurePersistentTokenStore(options?.tokenStore);
      const session = this._useSession(options?.tokenStore);
      let crud = (0, import_common2.useAsyncCache)(this._currentServerUserCache, [session], "serverApp.useUser()");
      if (crud?.is_anonymous && options?.or !== "anonymous" && options?.or !== "anonymous-if-exists[deprecated]") {
        crud = null;
      }
      if (crud === null) {
        switch (options?.or) {
          case "redirect": {
            (0, import_promises.runAsynchronously)(this.redirectToSignIn({ replace: true }));
            (0, import_react.suspend)();
            throw new import_errors.StackAssertionError("suspend should never return");
          }
          case "throw": {
            throw new Error("User is not signed in but useUser was called with { or: 'throw' }");
          }
          case "anonymous": {
            (0, import_promises.runAsynchronously)(async () => {
              await this._signUpAnonymously();
              if (typeof window !== "undefined") {
                window.location.reload();
              }
            });
            (0, import_react.suspend)();
            throw new import_errors.StackAssertionError("suspend should never return");
          }
          case void 0:
          case "anonymous-if-exists[deprecated]":
          case "return-null": {
          }
        }
      }
      return (0, import_react2.useMemo)(() => {
        return crud && this._currentUserFromCrud(crud, session);
      }, [crud, session, options?.or]);
    }
  }
  useUserById(userId) {
    const crud = (0, import_common2.useAsyncCache)(this._serverUserCache, [userId], "serverApp.useUserById()");
    return (0, import_react2.useMemo)(() => {
      return crud && this._serverUserFromCrud(crud);
    }, [crud]);
  }
  async listUsers(options) {
    const crud = import_results.Result.orThrow(await this._serverUsersCache.getOrWait([options?.cursor, options?.limit, options?.orderBy, options?.desc, options?.query, options?.includeAnonymous], "write-only"));
    const result = crud.items.map((j) => this._serverUserFromCrud(j));
    result.nextCursor = crud.pagination?.next_cursor ?? null;
    return result;
  }
  useUsers(options) {
    const crud = (0, import_common2.useAsyncCache)(this._serverUsersCache, [options?.cursor, options?.limit, options?.orderBy, options?.desc, options?.query, options?.includeAnonymous], "serverApp.useUsers()");
    const result = crud.items.map((j) => this._serverUserFromCrud(j));
    result.nextCursor = crud.pagination?.next_cursor ?? null;
    return result;
  }
  _serverPermissionFromCrud(crud) {
    return {
      id: crud.id
    };
  }
  _serverTeamPermissionDefinitionFromCrud(crud) {
    return {
      id: crud.id,
      description: crud.description,
      containedPermissionIds: crud.contained_permission_ids
    };
  }
  _serverProjectPermissionDefinitionFromCrud(crud) {
    return {
      id: crud.id,
      description: crud.description,
      containedPermissionIds: crud.contained_permission_ids
    };
  }
  async listTeams() {
    const teams = import_results.Result.orThrow(await this._serverTeamsCache.getOrWait([void 0], "write-only"));
    return teams.map((t) => this._serverTeamFromCrud(t));
  }
  async getItem(options) {
    if ("userId" in options) {
      const result = import_results.Result.orThrow(await this._serverUserItemsCache.getOrWait([options.userId, options.itemId], "write-only"));
      return this._serverItemFromCrud({ type: "user", id: options.userId }, result);
    } else if ("teamId" in options) {
      const result = import_results.Result.orThrow(await this._serverTeamItemsCache.getOrWait([options.teamId, options.itemId], "write-only"));
      return this._serverItemFromCrud({ type: "team", id: options.teamId }, result);
    } else {
      const result = import_results.Result.orThrow(await this._serverCustomItemsCache.getOrWait([options.customCustomerId, options.itemId], "write-only"));
      return this._serverItemFromCrud({ type: "custom", id: options.customCustomerId }, result);
    }
  }
  useItem(options) {
    let type;
    let id;
    let cache;
    if ("userId" in options) {
      type = "user";
      id = options.userId;
      cache = this._serverUserItemsCache;
    } else if ("teamId" in options) {
      type = "team";
      id = options.teamId;
      cache = this._serverTeamItemsCache;
    } else {
      type = "custom";
      id = options.customCustomerId;
      cache = this._serverCustomItemsCache;
    }
    const cacheKey = [id, options.itemId];
    const debugLabel = "serverApp.useItem()";
    const result = (0, import_common2.useAsyncCache)(cache, cacheKey, debugLabel);
    return (0, import_react2.useMemo)(() => this._serverItemFromCrud({ type, id }, result), [result]);
  }
  async grantProduct(options) {
    let customerType;
    let customerId;
    if ("userId" in options) {
      customerType = "user";
      customerId = options.userId;
    } else if ("teamId" in options) {
      customerType = "team";
      customerId = options.teamId;
    } else {
      customerType = "custom";
      customerId = options.customCustomerId;
    }
    await this._interface.grantProduct({
      customerType,
      customerId,
      productId: "productId" in options ? options.productId : void 0,
      product: "product" in options ? options.product : void 0,
      quantity: options.quantity
    });
    const cache = customerType === "user" ? this._serverUserProductsCache : customerType === "team" ? this._serverTeamProductsCache : this._serverCustomProductsCache;
    await cache.refresh([customerId, null, null]);
  }
  async createTeam(data) {
    const team = await this._interface.createServerTeam((0, import_teams.serverTeamCreateOptionsToCrud)(data));
    await this._serverTeamsCache.refresh([void 0]);
    return this._serverTeamFromCrud(team);
  }
  useTeams() {
    const teams = (0, import_common2.useAsyncCache)(this._serverTeamsCache, [void 0], "serverApp.useTeams()");
    return (0, import_react2.useMemo)(() => {
      return teams.map((t) => this._serverTeamFromCrud(t));
    }, [teams]);
  }
  async getTeam(options) {
    if (typeof options === "object" && "apiKey" in options) {
      return await this._getTeamByApiKey(options.apiKey);
    } else {
      const teamId = options;
      const teams = await this.listTeams();
      return teams.find((t) => t.id === teamId) ?? null;
    }
  }
  useTeam(options) {
    if (typeof options === "object" && "apiKey" in options) {
      return this._useTeamByApiKey(options.apiKey);
    } else {
      const teamId = options;
      const teams = this.useTeams();
      return (0, import_react2.useMemo)(() => {
        return teams.find((t) => t.id === teamId) ?? null;
      }, [teams, teamId]);
    }
  }
  _createServerDataVaultStore(id) {
    const validateOptions = (options) => {
      if (typeof options.secret !== "string") throw new Error("secret must be a string, got " + typeof options.secret);
    };
    return {
      id,
      setValue: async (key, value, options) => {
        validateOptions(options);
        await this._interface.setDataVaultStoreValue(options.secret, id, key, value);
      },
      getValue: async (key, options) => {
        validateOptions(options);
        return import_results.Result.orThrow(await this._serverDataVaultStoreValueCache.getOrWait([id, key, options.secret], "write-only"));
      },
      useValue: (key, options) => {
        validateOptions(options);
        return (0, import_common2.useAsyncCache)(this._serverDataVaultStoreValueCache, [id, key, options.secret], "store.useValue()");
      }
    };
  }
  async getDataVaultStore(id) {
    return this._createServerDataVaultStore(id);
  }
  useDataVaultStore(id) {
    return (0, import_react2.useMemo)(() => this._createServerDataVaultStore(id), [id]);
  }
  async sendEmail(options) {
    await this._interface.sendEmail(options);
  }
  async _refreshSession(session) {
    await Promise.all([
      super._refreshUser(session),
      this._currentServerUserCache.refresh([session])
    ]);
  }
  async _refreshUsers() {
    await Promise.all([
      super._refreshUsers(),
      this._serverUserCache.refreshWhere(() => true),
      this._serverUsersCache.refreshWhere(() => true),
      this._serverContactChannelsCache.refreshWhere(() => true),
      this._serverOAuthProvidersCache.refreshWhere(() => true)
    ]);
  }
  async createOAuthProvider(options) {
    try {
      const crud = await this._interface.createServerOAuthProvider({
        user_id: options.userId,
        provider_config_id: options.providerConfigId,
        account_id: options.accountId,
        email: options.email,
        allow_sign_in: options.allowSignIn,
        allow_connected_accounts: options.allowConnectedAccounts
      });
      await this._serverOAuthProvidersCache.refresh([options.userId]);
      return import_results.Result.ok(this._serverOAuthProviderFromCrud(crud));
    } catch (error) {
      if (import_stack_shared.KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn.isInstance(error)) {
        return import_results.Result.error(error);
      }
      throw error;
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  _StackServerAppImplIncomplete
});
//# sourceMappingURL=server-app-impl.js.map