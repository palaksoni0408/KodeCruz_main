// src/utils/paginated-lists.tsx
import { range } from "./arrays.js";
import { StackAssertionError } from "./errors.js";
var PaginatedList = class _PaginatedList {
  // Implementations
  getFirstCursor() {
    return this._getFirstCursor();
  }
  getLastCursor() {
    return this._getLastCursor();
  }
  compare(orderBy, a, b) {
    return this._compare(orderBy, a, b);
  }
  async nextOrPrev(type, options) {
    let result = [];
    let includesFirst = false;
    let includesLast = false;
    let cursor = options.cursor;
    let limitRemaining = options.limit;
    while (limitRemaining > 0 || type === "next" && includesLast || type === "prev" && includesFirst) {
      const iterationRes = await this._nextOrPrev(type, {
        cursor,
        limit: options.limit,
        limitPrecision: "approximate",
        filter: options.filter,
        orderBy: options.orderBy
      });
      result[type === "next" ? "push" : "unshift"](...iterationRes.items);
      limitRemaining -= iterationRes.items.length;
      includesFirst ||= iterationRes.isFirst;
      includesLast ||= iterationRes.isLast;
      cursor = iterationRes.cursor;
      if (["approximate", "at-most"].includes(options.limitPrecision)) break;
    }
    for (let i = 1; i < result.length; i++) {
      if (this._compare(options.orderBy, result[i].item, result[i - 1].item) < 0) {
        throw new StackAssertionError("Paginated list result is not sorted; something is wrong with the implementation", {
          i,
          options,
          result
        });
      }
    }
    if (["exact", "at-most"].includes(options.limitPrecision) && result.length > options.limit) {
      if (type === "next") {
        result = result.slice(0, options.limit);
        includesLast = false;
        if (options.limit > 0) cursor = result[result.length - 1].itemCursor;
      } else {
        result = result.slice(result.length - options.limit);
        includesFirst = false;
        if (options.limit > 0) cursor = result[0].itemCursor;
      }
    }
    return { items: result, isFirst: includesFirst, isLast: includesLast, cursor };
  }
  async next({ after, ...rest }) {
    return await this.nextOrPrev("next", {
      ...rest,
      cursor: after
    });
  }
  async prev({ before, ...rest }) {
    return await this.nextOrPrev("prev", {
      ...rest,
      cursor: before
    });
  }
  // Utility methods below
  flatMap(options) {
    const that = this;
    class FlatMapPaginatedList extends _PaginatedList {
      _getFirstCursor() {
        return options.newCursorFromOldCursor(that.getFirstCursor());
      }
      _getLastCursor() {
        return options.newCursorFromOldCursor(that.getLastCursor());
      }
      _compare(orderBy, a, b) {
        return options.compare(orderBy, a, b);
      }
      async _nextOrPrev(type, { limit, filter, orderBy, cursor }) {
        const estimatedItems = options.estimateItemsToFetch({ limit, filter, orderBy });
        const original = await that.nextOrPrev(type, {
          limit: estimatedItems,
          limitPrecision: "approximate",
          cursor: options.oldCursorFromNewCursor(cursor),
          filter: options.oldFilterFromNewFilter(filter),
          orderBy: options.oldOrderByFromNewOrderBy(orderBy)
        });
        const mapped = original.items.flatMap((itemEntry) => options.itemMapper(
          itemEntry,
          filter,
          orderBy
        ));
        return {
          items: mapped,
          isFirst: original.isFirst,
          isLast: original.isLast,
          cursor: options.newCursorFromOldCursor(original.cursor)
        };
      }
    }
    return new FlatMapPaginatedList();
  }
  map(options) {
    return this.flatMap({
      itemMapper: (itemEntry, filter, orderBy) => {
        return [{ item: options.itemMapper(itemEntry.item), itemCursor: itemEntry.itemCursor }];
      },
      compare: (orderBy, a, b) => this.compare(options.oldOrderByFromNewOrderBy(orderBy), options.oldItemFromNewItem(a), options.oldItemFromNewItem(b)),
      newCursorFromOldCursor: (cursor) => cursor,
      oldCursorFromNewCursor: (cursor) => cursor,
      oldFilterFromNewFilter: (filter) => options.oldFilterFromNewFilter(filter),
      oldOrderByFromNewOrderBy: (orderBy) => options.oldOrderByFromNewOrderBy(orderBy),
      estimateItemsToFetch: (options2) => options2.limit
    });
  }
  filter(options) {
    return this.flatMap({
      itemMapper: (itemEntry, filter, orderBy) => options.filter(itemEntry.item, filter) ? [itemEntry] : [],
      compare: (orderBy, a, b) => this.compare(orderBy, a, b),
      newCursorFromOldCursor: (cursor) => cursor,
      oldCursorFromNewCursor: (cursor) => cursor,
      oldFilterFromNewFilter: (filter) => options.oldFilterFromNewFilter(filter),
      oldOrderByFromNewOrderBy: (orderBy) => orderBy,
      estimateItemsToFetch: (o) => options.estimateItemsToFetch(o)
    });
  }
  addFilter(options) {
    return this.filter({
      filter: (item, filter) => options.filter(item, filter),
      oldFilterFromNewFilter: (filter) => filter,
      estimateItemsToFetch: (o) => options.estimateItemsToFetch(o)
    });
  }
  static merge(...lists) {
    class MergePaginatedList extends _PaginatedList {
      _getFirstCursor() {
        return JSON.stringify(lists.map((list) => list.getFirstCursor()));
      }
      _getLastCursor() {
        return JSON.stringify(lists.map((list) => list.getLastCursor()));
      }
      _compare(orderBy, a, b) {
        const listsResults = lists.map((list) => list.compare(orderBy, a, b));
        if (!listsResults.every((result) => result === listsResults[0])) {
          throw new StackAssertionError("Lists have different compare results; make sure that they use the same compare function", { lists, listsResults });
        }
        return listsResults[0];
      }
      async _nextOrPrev(type, { limit, filter, orderBy, cursor }) {
        const cursors = JSON.parse(cursor);
        const fetchedLists = await Promise.all(lists.map(async (list, i) => {
          return await list.nextOrPrev(type, {
            limit,
            filter,
            orderBy,
            cursor: cursors[i],
            limitPrecision: "at-least"
          });
        }));
        const combinedItems = fetchedLists.flatMap((list, i) => list.items.map((itemEntry) => ({ itemEntry, listIndex: i })));
        const sortedItems = [...combinedItems].sort((a, b) => this._compare(orderBy, a.itemEntry.item, b.itemEntry.item));
        const lastCursorForEachList = sortedItems.reduce((acc, item) => {
          acc[item.listIndex] = item.itemEntry.itemCursor;
          return acc;
        }, range(lists.length).map((i) => cursors[i]));
        return {
          items: sortedItems.map((item) => item.itemEntry),
          isFirst: sortedItems.every((item) => item.listIndex === 0),
          isLast: sortedItems.every((item) => item.listIndex === lists.length - 1),
          cursor: JSON.stringify(lastCursorForEachList)
        };
      }
    }
    return new MergePaginatedList();
  }
  static empty() {
    class EmptyPaginatedList extends _PaginatedList {
      _getFirstCursor() {
        return "first";
      }
      _getLastCursor() {
        return "last";
      }
      _compare(orderBy, a, b) {
        return 0;
      }
      async _nextOrPrev(type, options) {
        return { items: [], isFirst: true, isLast: true, cursor: "first" };
      }
    }
    return new EmptyPaginatedList();
  }
};
var ArrayPaginatedList = class extends PaginatedList {
  constructor(array) {
    super();
    this.array = array;
  }
  _getFirstCursor() {
    return "0";
  }
  _getLastCursor() {
    return `${this.array.length - 1}`;
  }
  _compare(orderBy, a, b) {
    return orderBy(a, b);
  }
  async _nextOrPrev(type, options) {
    const filteredArray = this.array.filter(options.filter);
    const sortedArray = [...filteredArray].sort((a, b) => this._compare(options.orderBy, a, b));
    const itemEntriesArray = sortedArray.map((item, index) => ({ item, itemCursor: `${index}` }));
    const oldCursor = Number(options.cursor);
    const newCursor = Math.max(0, Math.min(this.array.length - 1, oldCursor + (type === "next" ? 1 : -1) * options.limit));
    return {
      items: itemEntriesArray.slice(Math.min(oldCursor, newCursor), Math.max(oldCursor, newCursor)),
      isFirst: oldCursor === 0 || newCursor === 0,
      isLast: oldCursor === this.array.length - 1 || newCursor === this.array.length - 1,
      cursor: `${newCursor}`
    };
  }
};
export {
  ArrayPaginatedList,
  PaginatedList
};
//# sourceMappingURL=paginated-lists.js.map