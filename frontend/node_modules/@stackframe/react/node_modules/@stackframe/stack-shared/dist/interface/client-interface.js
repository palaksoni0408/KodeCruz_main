"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/interface/client-interface.ts
var client_interface_exports = {};
__export(client_interface_exports, {
  StackClientInterface: () => StackClientInterface
});
module.exports = __toCommonJS(client_interface_exports);
var oauth = __toESM(require("oauth4webapi"));
var import_known_errors = require("../known-errors.js");
var import_sessions = require("../sessions.js");
var import_crypto = require("../utils/crypto.js");
var import_errors = require("../utils/errors.js");
var import_globals = require("../utils/globals.js");
var import_http = require("../utils/http.js");
var import_objects = require("../utils/objects.js");
var import_promises = require("../utils/promises.js");
var import_results = require("../utils/results.js");
var import_strings = require("../utils/strings.js");
var import_urls = require("../utils/urls.js");
var StackClientInterface = class {
  constructor(options) {
    this.options = options;
  }
  get projectId() {
    return this.options.projectId;
  }
  getApiUrl() {
    return this.options.getBaseUrl() + "/api/v1";
  }
  async runNetworkDiagnostics(session, requestType) {
    if (this.pendingNetworkDiagnostics) {
      return await this.pendingNetworkDiagnostics;
    }
    this.pendingNetworkDiagnostics = this._runNetworkDiagnosticsInner(session, requestType);
    try {
      return await this.pendingNetworkDiagnostics;
    } finally {
      this.pendingNetworkDiagnostics = void 0;
    }
  }
  async _runNetworkDiagnosticsInner(session, requestType) {
    const tryRequest = async (cb) => {
      try {
        await cb();
        return "OK";
      } catch (e) {
        return `${e}`;
      }
    };
    const cfTrace = await tryRequest(async () => {
      const res = await fetch("https://1.1.1.1/cdn-cgi/trace");
      if (!res.ok) {
        throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`);
      }
    });
    const baseUrlBackend = await tryRequest(async () => {
      const res = await fetch(new URL("/health", this.getApiUrl()));
      if (!res.ok) {
        throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`);
      }
    });
    const prodDashboard = await tryRequest(async () => {
      const res = await fetch("https://app.stack-auth.com/health");
      if (!res.ok) {
        throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`);
      }
    });
    const prodBackend = await tryRequest(async () => {
      const res = await fetch("https://api.stack-auth.com/health");
      if (!res.ok) {
        throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`);
      }
    });
    return {
      "navigator?.onLine": import_globals.globalVar.navigator?.onLine,
      cfTrace,
      baseUrlBackend,
      prodDashboard,
      prodBackend
    };
  }
  async _createNetworkError(cause, session, requestType) {
    return new Error(import_strings.deindent`
      Stack Auth is unable to connect to the server. Please check your internet connection and try again.

      If the problem persists, please contact support and provide a screenshot of your entire browser console.

      ${cause}

      ${JSON.stringify(await this.runNetworkDiagnostics(session, requestType), null, 2)}
    `, { cause });
  }
  async _networkRetry(cb, session, requestType) {
    const retriedResult = await import_results.Result.retry(
      cb,
      5,
      { exponentialDelayBase: 1e3 }
    );
    if (retriedResult.status === "error") {
      if (import_globals.globalVar.navigator && import_globals.globalVar.navigator.onLine === false) {
        throw new Error("You are offline. Please check your internet connection and try again. (window.navigator.onLine is false)", { cause: retriedResult.error });
      }
      throw await this._createNetworkError(retriedResult.error, session, requestType);
    }
    return retriedResult.data;
  }
  async _networkRetryException(cb, session, requestType) {
    return await this._networkRetry(async () => await import_results.Result.fromThrowingAsync(cb), session, requestType);
  }
  async fetchNewAccessToken(refreshToken) {
    if (!("publishableClientKey" in this.options)) {
      throw new Error("Admin session token is currently not supported for fetching new access token. Did you try to log in on a StackApp initiated with the admin session?");
    }
    const as = {
      issuer: this.options.getBaseUrl(),
      algorithm: "oauth2",
      token_endpoint: this.getApiUrl() + "/auth/oauth/token"
    };
    const client = {
      client_id: this.projectId,
      client_secret: this.options.publishableClientKey,
      token_endpoint_auth_method: "client_secret_post"
    };
    const response = await this._networkRetryException(async () => {
      const rawResponse = await oauth.refreshTokenGrantRequest(
        as,
        client,
        refreshToken.token
      );
      const response2 = await this._processResponse(rawResponse);
      if (response2.status === "error") {
        const error = response2.error;
        if (import_known_errors.KnownErrors.RefreshTokenError.isInstance(error)) {
          return null;
        }
        throw error;
      }
      if (!response2.data.ok) {
        const body = await response2.data.text();
        throw new Error(`Failed to send refresh token request: ${response2.status} ${body}`);
      }
      return response2.data;
    });
    if (!response) return null;
    const result = await oauth.processRefreshTokenResponse(as, client, response);
    if (oauth.isOAuth2Error(result)) {
      throw new import_errors.StackAssertionError("OAuth error", { result });
    }
    if (!result.access_token) {
      throw new import_errors.StackAssertionError("Access token not found in token endpoint response, this is weird!");
    }
    return import_sessions.AccessToken.createIfValid(result.access_token) ?? (0, import_errors.throwErr)("Access token in fetchNewAccessToken is invalid, looks like the backend is returning an invalid token!", { result });
  }
  async sendClientRequest(path, requestOptions, session, requestType = "client") {
    session ??= this.createSession({
      refreshToken: null
    });
    return await this._networkRetry(
      () => this.sendClientRequestInner(path, requestOptions, session, requestType),
      session,
      requestType
    );
  }
  createSession(options) {
    const session = new import_sessions.InternalSession({
      refreshAccessTokenCallback: async (refreshToken) => await this.fetchNewAccessToken(refreshToken),
      ...options
    });
    return session;
  }
  async sendClientRequestAndCatchKnownError(path, requestOptions, tokenStoreOrNull, errorsToCatch) {
    try {
      return import_results.Result.ok(await this.sendClientRequest(path, requestOptions, tokenStoreOrNull));
    } catch (e) {
      for (const errorType of errorsToCatch) {
        if (errorType.isInstance(e)) {
          return import_results.Result.error(e);
        }
      }
      throw e;
    }
  }
  async sendClientRequestInner(path, options, session, requestType) {
    let tokenObj = await session.getOrFetchLikelyValidTokens(2e4);
    let adminSession = "projectOwnerSession" in this.options ? this.options.projectOwnerSession : null;
    let adminTokenObj = adminSession ? await adminSession.getOrFetchLikelyValidTokens(2e4) : null;
    await this.options.prepareRequest?.();
    let url = this.getApiUrl() + path;
    if (url.endsWith("/")) {
      url = url.slice(0, -1);
    }
    const params = {
      /**
       * This fetch may be cross-origin, in which case we don't want to send cookies of the
       * original origin (this is the default behavior of `credentials`).
       *
       * To help debugging, also omit cookies on same-origin, so we don't accidentally
       * implement reliance on cookies anywhere.
       *
       * However, Cloudflare Workers don't actually support `credentials`, so we only set it
       * if Cloudflare-exclusive globals are not detected. https://github.com/cloudflare/workers-sdk/issues/2514
       */
      ..."WebSocketPair" in import_globals.globalVar ? {} : {
        credentials: "omit"
      },
      ...options,
      headers: {
        "X-Stack-Override-Error-Status": "true",
        "X-Stack-Project-Id": this.projectId,
        "X-Stack-Access-Type": requestType,
        "X-Stack-Client-Version": this.options.clientVersion,
        ...tokenObj ? {
          "X-Stack-Access-Token": tokenObj.accessToken.token
        } : {},
        ...tokenObj?.refreshToken ? {
          "X-Stack-Refresh-Token": tokenObj.refreshToken.token
        } : {},
        "X-Stack-Allow-Anonymous-User": "true",
        ..."publishableClientKey" in this.options ? {
          "X-Stack-Publishable-Client-Key": this.options.publishableClientKey
        } : {},
        ...adminTokenObj ? {
          "X-Stack-Admin-Access-Token": adminTokenObj.accessToken.token
        } : {},
        /**
         * Next.js until v15 would cache fetch requests by default, and forcefully disabling it was nearly impossible.
         *
         * This header is used to change the cache key and hence always disable it, because we do our own caching.
         *
         * When we drop support for Next.js <15, we may be able to remove this header, but please make sure that this is
         * the case (I haven't actually tested.)
         */
        "X-Stack-Random-Nonce": (0, import_crypto.generateSecureRandomString)(),
        // don't show a warning when proxying the API through ngrok (only relevant if the API url is an ngrok site)
        "ngrok-skip-browser-warning": "true",
        ...this.options.extraRequestHeaders,
        ...options.headers
      },
      /**
       * Cloudflare Workers does not support cache, so don't pass it there
       */
      ..."WebSocketPair" in import_globals.globalVar ? {} : {
        cache: "no-store"
      }
    };
    let rawRes;
    try {
      rawRes = await fetch(url, params);
    } catch (e) {
      if (e instanceof TypeError) {
        if (import_http.HTTP_METHODS[params.method ?? "GET"].idempotent) {
          return import_results.Result.error(e);
        } else {
          throw await this._createNetworkError(e, session, requestType);
        }
      }
      throw e;
    }
    const processedRes = await this._processResponse(rawRes);
    if (processedRes.status === "error") {
      if (import_known_errors.KnownErrors.InvalidAccessToken.isInstance(processedRes.error)) {
        if (!tokenObj) {
          throw new import_errors.StackAssertionError("Received invalid access token, but session is not logged in", { tokenObj, processedRes });
        }
        session.markAccessTokenExpired(tokenObj.accessToken);
        return import_results.Result.error(processedRes.error);
      }
      if (adminSession && (import_known_errors.KnownErrors.InvalidAdminAccessToken.isInstance(processedRes.error) || import_known_errors.KnownErrors.ApiKeyNotFound.isInstance(processedRes.error))) {
        if (!adminTokenObj) {
          throw new import_errors.StackAssertionError("Received invalid admin access token, but admin session is not logged in", { adminTokenObj, processedRes });
        }
        adminSession.markAccessTokenExpired(adminTokenObj.accessToken);
        return import_results.Result.error(processedRes.error);
      }
      throw processedRes.error;
    }
    const res = Object.assign(processedRes.data, {
      usedTokens: tokenObj
    });
    if (res.ok) {
      return import_results.Result.ok(res);
    } else if (res.status === 429) {
      const retryAfter = res.headers.get("Retry-After");
      if (retryAfter !== null) {
        console.log(`Rate limited while sending request to ${url}. Will retry after ${retryAfter} seconds...`);
        await (0, import_promises.wait)(Number(retryAfter) * 1e3);
        return import_results.Result.error(new Error(`Rate limited, retrying after ${retryAfter} seconds`));
      }
      console.log(`Rate limited while sending request to ${url}, no retry-after header received. Retrying...`);
      return import_results.Result.error(new Error("Rate limited, no retry-after header received"));
    } else {
      const error = await res.text();
      const errorObj = new import_errors.StackAssertionError(`Failed to send request to ${url}: ${res.status} ${error}`, { request: params, res, path });
      if (res.status === 508 && error.includes("INFINITE_LOOP_DETECTED")) {
        return import_results.Result.error(errorObj);
      }
      throw errorObj;
    }
  }
  async _processResponse(rawRes) {
    let res = rawRes;
    if (rawRes.headers.has("x-stack-actual-status")) {
      const actualStatus = Number(rawRes.headers.get("x-stack-actual-status"));
      res = new Response(rawRes.body, {
        status: actualStatus,
        statusText: rawRes.statusText,
        headers: rawRes.headers
      });
    }
    if (res.headers.has("x-stack-known-error")) {
      const errorJson = await res.json();
      if (res.headers.get("x-stack-known-error") !== errorJson.code) {
        throw new import_errors.StackAssertionError("Mismatch between x-stack-known-error header and error code in body; the server's response is invalid");
      }
      const error = import_known_errors.KnownError.fromJson(errorJson);
      return import_results.Result.error(error);
    }
    return import_results.Result.ok(res);
  }
  async checkFeatureSupport(options) {
    const res = await this.sendClientRequest("/check-feature-support", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(options)
    }, null);
    throw new import_errors.StackAssertionError(await res.text());
  }
  async sendForgotPasswordEmail(email, callbackUrl) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/auth/password/send-reset-code",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          email,
          callback_url: callbackUrl
        })
      },
      null,
      [import_known_errors.KnownErrors.UserNotFound]
    );
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    } else {
      return import_results.Result.ok(void 0);
    }
  }
  async sendVerificationEmail(email, callbackUrl, session) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/contact-channels/send-verification-code",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          email,
          callback_url: callbackUrl
        })
      },
      session,
      [import_known_errors.KnownErrors.EmailAlreadyVerified]
    );
    if (res.status === "error") {
      return res.error;
    }
  }
  async sendMagicLinkEmail(email, callbackUrl) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/auth/otp/send-sign-in-code",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          email,
          callback_url: callbackUrl
        })
      },
      null,
      [import_known_errors.KnownErrors.RedirectUrlNotWhitelisted]
    );
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    } else {
      return import_results.Result.ok(await res.data.json());
    }
  }
  async resetPassword(options) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "onlyVerifyCode" in options ? "/auth/password/reset/check-code" : "/auth/password/reset",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          code: options.code,
          ..."password" in options ? { password: options.password } : {}
        })
      },
      null,
      [import_known_errors.KnownErrors.VerificationCodeError]
    );
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    } else {
      return import_results.Result.ok(void 0);
    }
  }
  async updatePassword(options, session) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/auth/password/update",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          old_password: options.oldPassword,
          new_password: options.newPassword
        })
      },
      session,
      [import_known_errors.KnownErrors.PasswordConfirmationMismatch, import_known_errors.KnownErrors.PasswordRequirementsNotMet]
    );
    if (res.status === "error") {
      return res.error;
    }
  }
  async setPassword(options, session) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/auth/password/set",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(options)
      },
      session,
      [import_known_errors.KnownErrors.PasswordRequirementsNotMet]
    );
    if (res.status === "error") {
      return res.error;
    }
  }
  async verifyPasswordResetCode(code) {
    const res = await this.resetPassword({ code, onlyVerifyCode: true });
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    } else {
      return import_results.Result.ok(void 0);
    }
  }
  async verifyEmail(code) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/contact-channels/verify",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          code
        })
      },
      null,
      [import_known_errors.KnownErrors.VerificationCodeError]
    );
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    } else {
      return import_results.Result.ok(void 0);
    }
  }
  async initiatePasskeyRegistration(options, session) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/auth/passkey/initiate-passkey-registration",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(options)
      },
      session,
      []
    );
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    }
    return import_results.Result.ok(await res.data.json());
  }
  async registerPasskey(options, session) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/auth/passkey/register",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(options)
      },
      session,
      [import_known_errors.KnownErrors.PasskeyRegistrationFailed]
    );
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    }
    return import_results.Result.ok(void 0);
  }
  async initiatePasskeyAuthentication(options, session) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/auth/passkey/initiate-passkey-authentication",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(options)
      },
      session,
      []
    );
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    }
    return import_results.Result.ok(await res.data.json());
  }
  async sendTeamInvitation(options) {
    await this.sendClientRequest(
      "/team-invitations/send-code",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          email: options.email,
          team_id: options.teamId,
          callback_url: options.callbackUrl
        })
      },
      options.session
    );
  }
  async acceptTeamInvitation(options) {
    const res = await this.sendClientRequestAndCatchKnownError(
      options.type === "check" ? "/team-invitations/accept/check-code" : options.type === "details" ? "/team-invitations/accept/details" : "/team-invitations/accept",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          code: options.code
        })
      },
      options.session,
      [import_known_errors.KnownErrors.VerificationCodeError]
    );
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    } else {
      return import_results.Result.ok(await res.data.json());
    }
  }
  async totpMfa(attemptCode, totp, session) {
    const res = await this.sendClientRequest("/auth/mfa/sign-in", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        code: attemptCode,
        type: "totp",
        totp
      })
    }, session);
    const result = await res.json();
    return {
      accessToken: result.access_token,
      refreshToken: result.refresh_token,
      newUser: result.is_new_user
    };
  }
  async signInWithCredential(email, password, session) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/auth/password/sign-in",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          email,
          password
        })
      },
      session,
      [import_known_errors.KnownErrors.EmailPasswordMismatch]
    );
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    }
    const result = await res.data.json();
    return import_results.Result.ok({
      accessToken: result.access_token,
      refreshToken: result.refresh_token
    });
  }
  async signUpWithCredential(email, password, emailVerificationRedirectUrl, session) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/auth/password/sign-up",
      {
        headers: {
          "Content-Type": "application/json"
        },
        method: "POST",
        body: JSON.stringify({
          email,
          password,
          verification_callback_url: emailVerificationRedirectUrl
        })
      },
      session,
      [import_known_errors.KnownErrors.UserWithEmailAlreadyExists, import_known_errors.KnownErrors.PasswordRequirementsNotMet]
    );
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    }
    const result = await res.data.json();
    return import_results.Result.ok({
      accessToken: result.access_token,
      refreshToken: result.refresh_token
    });
  }
  async signUpAnonymously(session) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/auth/anonymous/sign-up",
      {
        method: "POST"
      },
      session,
      []
    );
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    }
    const result = await res.data.json();
    return import_results.Result.ok({
      accessToken: result.access_token,
      refreshToken: result.refresh_token
    });
  }
  async signInWithMagicLink(code, session) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/auth/otp/sign-in",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          code
        })
      },
      session,
      [import_known_errors.KnownErrors.VerificationCodeError]
    );
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    }
    const result = await res.data.json();
    return import_results.Result.ok({
      accessToken: result.access_token,
      refreshToken: result.refresh_token,
      newUser: result.is_new_user
    });
  }
  async signInWithMfa(totp, code, session) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/auth/mfa/sign-in",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          type: "totp",
          totp,
          code
        })
      },
      session,
      [import_known_errors.KnownErrors.VerificationCodeError]
    );
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    }
    const result = await res.data.json();
    return import_results.Result.ok({
      accessToken: result.access_token,
      refreshToken: result.refresh_token,
      newUser: result.is_new_user
    });
  }
  async signInWithPasskey(body, session) {
    const res = await this.sendClientRequestAndCatchKnownError(
      "/auth/passkey/sign-in",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      },
      session,
      [import_known_errors.KnownErrors.PasskeyAuthenticationFailed]
    );
    if (res.status === "error") {
      return import_results.Result.error(res.error);
    }
    const result = await res.data.json();
    return import_results.Result.ok({
      accessToken: result.access_token,
      refreshToken: result.refresh_token
    });
  }
  async getOAuthUrl(options) {
    const updatedRedirectUrl = new URL(options.redirectUrl);
    for (const key of ["code", "state"]) {
      if (updatedRedirectUrl.searchParams.has(key)) {
        console.warn("Redirect URL already contains " + key + " parameter, removing it as it will be overwritten by the OAuth callback");
      }
      updatedRedirectUrl.searchParams.delete(key);
    }
    if (!("publishableClientKey" in this.options)) {
      throw new Error("Admin session token is currently not supported for OAuth");
    }
    const url = new URL(this.getApiUrl() + "/auth/oauth/authorize/" + options.provider.toLowerCase());
    url.searchParams.set("client_id", this.projectId);
    url.searchParams.set("client_secret", this.options.publishableClientKey);
    url.searchParams.set("redirect_uri", updatedRedirectUrl.toString());
    url.searchParams.set("scope", "legacy");
    url.searchParams.set("state", options.state);
    url.searchParams.set("grant_type", "authorization_code");
    url.searchParams.set("code_challenge", options.codeChallenge);
    url.searchParams.set("code_challenge_method", "S256");
    url.searchParams.set("response_type", "code");
    url.searchParams.set("type", options.type);
    url.searchParams.set("error_redirect_url", options.errorRedirectUrl);
    const tokens = await options.session.getOrFetchLikelyValidTokens(2e4);
    if (tokens) {
      url.searchParams.set("token", tokens.accessToken.token);
    }
    if (options.afterCallbackRedirectUrl) {
      url.searchParams.set("after_callback_redirect_url", options.afterCallbackRedirectUrl);
    }
    if (options.providerScope) {
      url.searchParams.set("provider_scope", options.providerScope);
    }
    return url.toString();
  }
  async callOAuthCallback(options) {
    if (!("publishableClientKey" in this.options)) {
      throw new Error("Admin session token is currently not supported for OAuth");
    }
    const as = {
      issuer: this.options.getBaseUrl(),
      algorithm: "oauth2",
      token_endpoint: this.getApiUrl() + "/auth/oauth/token"
    };
    const client = {
      client_id: this.projectId,
      client_secret: this.options.publishableClientKey,
      token_endpoint_auth_method: "client_secret_post"
    };
    const params = await this._networkRetryException(
      async () => oauth.validateAuthResponse(as, client, options.oauthParams, options.state)
    );
    if (oauth.isOAuth2Error(params)) {
      throw new import_errors.StackAssertionError("Error validating outer OAuth response", { params });
    }
    const response = await oauth.authorizationCodeGrantRequest(
      as,
      client,
      params,
      options.redirectUri,
      options.codeVerifier
    );
    const result = await oauth.processAuthorizationCodeOAuth2Response(as, client, response);
    if (oauth.isOAuth2Error(result)) {
      if ("code" in result && result.code === "MULTI_FACTOR_AUTHENTICATION_REQUIRED") {
        throw new import_known_errors.KnownErrors.MultiFactorAuthenticationRequired(result.details.attempt_code);
      }
      throw new import_errors.StackAssertionError("Outer OAuth error during authorization code response", { result });
    }
    return {
      newUser: result.is_new_user,
      afterCallbackRedirectUrl: result.after_callback_redirect_url,
      accessToken: result.access_token,
      refreshToken: result.refresh_token ?? (0, import_errors.throwErr)("Refresh token not found in outer OAuth response")
    };
  }
  async signOut(session) {
    const tokenObj = await session.getOrFetchLikelyValidTokens(2e4);
    if (tokenObj) {
      const resOrError = await this.sendClientRequestAndCatchKnownError(
        "/auth/sessions/current",
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({})
        },
        session,
        [import_known_errors.KnownErrors.RefreshTokenError]
      );
      if (resOrError.status === "error") {
        if (import_known_errors.KnownErrors.RefreshTokenError.isInstance(resOrError.error)) {
        } else {
          throw new import_errors.StackAssertionError("Unexpected error", { error: resOrError.error });
        }
      } else {
      }
    }
    session.markInvalid();
  }
  async getClientUserByToken(session) {
    const responseOrError = await this.sendClientRequestAndCatchKnownError(
      "/users/me",
      {},
      session,
      [import_known_errors.KnownErrors.CannotGetOwnUserWithoutUser]
    );
    if (responseOrError.status === "error") {
      if (import_known_errors.KnownErrors.CannotGetOwnUserWithoutUser.isInstance(responseOrError.error)) {
        return null;
      } else {
        throw new import_errors.StackAssertionError("Unexpected uncaught error", { cause: responseOrError.error });
      }
    }
    const response = responseOrError.data;
    const user = await response.json();
    if (!user) throw new import_errors.StackAssertionError("User endpoint returned null; this should never happen");
    return user;
  }
  async listTeamInvitations(options, session) {
    const response = await this.sendClientRequest(
      "/team-invitations?" + new URLSearchParams({ team_id: options.teamId }),
      {},
      session
    );
    const result = await response.json();
    return result.items;
  }
  async revokeTeamInvitation(invitationId, teamId, session) {
    await this.sendClientRequest(
      `/team-invitations/${invitationId}?team_id=${teamId}`,
      { method: "DELETE" },
      session
    );
  }
  async listTeamMemberProfiles(options, session) {
    const response = await this.sendClientRequest(
      "/team-member-profiles?" + new URLSearchParams((0, import_objects.filterUndefined)({
        team_id: options.teamId,
        user_id: options.userId
      })),
      {},
      session
    );
    const result = await response.json();
    return result.items;
  }
  async getTeamMemberProfile(options, session) {
    const response = await this.sendClientRequest(
      `/team-member-profiles/${options.teamId}/${options.userId}`,
      {},
      session
    );
    return await response.json();
  }
  async leaveTeam(teamId, session) {
    await this.sendClientRequest(
      `/team-memberships/${teamId}/me`,
      {
        method: "DELETE",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({})
      },
      session
    );
  }
  async updateTeamMemberProfile(options, session) {
    await this.sendClientRequest(
      `/team-member-profiles/${options.teamId}/${options.userId}`,
      {
        method: "PATCH",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(options.profile)
      },
      session
    );
  }
  async updateTeam(options, session) {
    await this.sendClientRequest(
      `/teams/${options.teamId}`,
      {
        method: "PATCH",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(options.data)
      },
      session
    );
  }
  async listCurrentUserTeamPermissions(options, session) {
    const response = await this.sendClientRequest(
      `/team-permissions?team_id=${options.teamId}&user_id=me&recursive=${options.recursive}`,
      {},
      session
    );
    const result = await response.json();
    return result.items;
  }
  async listCurrentUserProjectPermissions(options, session) {
    const response = await this.sendClientRequest(
      `/project-permissions?user_id=me&recursive=${options.recursive}`,
      {},
      session
    );
    const result = await response.json();
    return result.items;
  }
  async listCurrentUserTeams(session) {
    const response = await this.sendClientRequest(
      "/teams?user_id=me",
      {},
      session
    );
    const result = await response.json();
    return result.items;
  }
  async getClientProject() {
    const responseOrError = await this.sendClientRequestAndCatchKnownError("/projects/current", {}, null, [import_known_errors.KnownErrors.ProjectNotFound]);
    if (responseOrError.status === "error") {
      return import_results.Result.error(responseOrError.error);
    }
    const response = responseOrError.data;
    const project = await response.json();
    return import_results.Result.ok(project);
  }
  async updateClientUser(update, session) {
    await this.sendClientRequest(
      "/users/me",
      {
        method: "PATCH",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(update)
      },
      session
    );
  }
  async listProjects(session) {
    const response = await this.sendClientRequest("/internal/projects", {}, session);
    if (!response.ok) {
      throw new Error("Failed to list projects: " + response.status + " " + await response.text());
    }
    const json = await response.json();
    return json.items;
  }
  async createProject(project, session) {
    const fetchResponse = await this.sendClientRequest(
      "/internal/projects",
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(project)
      },
      session
    );
    if (!fetchResponse.ok) {
      throw new Error("Failed to create project: " + fetchResponse.status + " " + await fetchResponse.text());
    }
    const json = await fetchResponse.json();
    return json;
  }
  async createProviderAccessToken(provider, scope, session) {
    const response = await this.sendClientRequest(
      `/connected-accounts/me/${provider}/access-token`,
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({ scope })
      },
      session
    );
    return await response.json();
  }
  async createClientTeam(data, session) {
    const response = await this.sendClientRequest(
      "/teams",
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(data)
      },
      session
    );
    return await response.json();
  }
  async deleteTeam(teamId, session) {
    await this.sendClientRequest(
      `/teams/${teamId}`,
      {
        method: "DELETE"
      },
      session
    );
  }
  async deleteCurrentUser(session) {
    await this.sendClientRequest(
      "/users/me",
      {
        method: "DELETE"
      },
      session
    );
  }
  async createClientContactChannel(data, session) {
    const response = await this.sendClientRequest(
      "/contact-channels",
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(data)
      },
      session
    );
    return await response.json();
  }
  async updateClientContactChannel(id, data, session) {
    const response = await this.sendClientRequest(
      `/contact-channels/me/${id}`,
      {
        method: "PATCH",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(data)
      },
      session
    );
    return await response.json();
  }
  async deleteClientContactChannel(id, session) {
    await this.sendClientRequest(
      `/contact-channels/me/${id}`,
      {
        method: "DELETE"
      },
      session
    );
  }
  async deleteSession(sessionId, session) {
    await this.sendClientRequest(
      `/auth/sessions/${sessionId}?user_id=me`,
      {
        method: "DELETE"
      },
      session
    );
  }
  async listSessions(session) {
    const response = await this.sendClientRequest(
      "/auth/sessions?user_id=me",
      {
        method: "GET"
      },
      session
    );
    return await response.json();
  }
  async listClientContactChannels(session) {
    const response = await this.sendClientRequest(
      "/contact-channels?user_id=me",
      {
        method: "GET"
      },
      session
    );
    const json = await response.json();
    return json.items;
  }
  async sendCurrentUserContactChannelVerificationEmail(contactChannelId, callbackUrl, session) {
    const responseOrError = await this.sendClientRequestAndCatchKnownError(
      `/contact-channels/me/${contactChannelId}/send-verification-code`,
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({ callback_url: callbackUrl })
      },
      session,
      [import_known_errors.KnownErrors.EmailAlreadyVerified]
    );
    if (responseOrError.status === "error") {
      return import_results.Result.error(responseOrError.error);
    }
    return import_results.Result.ok(void 0);
  }
  async cliLogin(loginCode, refreshToken, session) {
    const responseOrError = await this.sendClientRequestAndCatchKnownError(
      "/auth/cli/complete",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          login_code: loginCode,
          refresh_token: refreshToken
        })
      },
      session,
      [import_known_errors.KnownErrors.SchemaError]
    );
    if (responseOrError.status === "error") {
      return import_results.Result.error(responseOrError.error);
    }
    return import_results.Result.ok(void 0);
  }
  async _getApiKeyRequestInfo(options) {
    if ("user_id" in options && "team_id" in options) {
      throw new import_errors.StackAssertionError("Cannot specify both user_id and team_id in _getApiKeyRequestInfo");
    }
    return {
      endpoint: "team_id" in options ? "/team-api-keys" : "/user-api-keys",
      queryParams: new URLSearchParams((0, import_objects.filterUndefinedOrNull)(options))
    };
  }
  async listProjectApiKeys(options, session, requestType) {
    const sendRequest = (requestType === "client" ? this.sendClientRequest : this.sendServerRequest).bind(this);
    const { endpoint, queryParams } = await this._getApiKeyRequestInfo(options);
    const response = await sendRequest(
      `${endpoint}?${queryParams.toString()}`,
      {
        method: "GET"
      },
      session,
      requestType
    );
    const json = await response.json();
    return json.items;
  }
  async createProjectApiKey(data, session, requestType) {
    const sendRequest = (requestType === "client" ? this.sendClientRequest : this.sendServerRequest).bind(this);
    const { endpoint } = await this._getApiKeyRequestInfo(data);
    const response = await sendRequest(
      `${endpoint}`,
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(data)
      },
      session,
      requestType
    );
    return await response.json();
  }
  async getProjectApiKey(options, keyId, session, requestType) {
    const sendRequest = (requestType === "client" ? this.sendClientRequest : this.sendServerRequest).bind(this);
    const { endpoint, queryParams } = await this._getApiKeyRequestInfo(options);
    const response = await sendRequest(
      `${endpoint}/${keyId}?${queryParams.toString()}`,
      {
        method: "GET"
      },
      session,
      requestType
    );
    return await response.json();
  }
  async updateProjectApiKey(options, keyId, data, session, requestType) {
    const sendRequest = (requestType === "client" ? this.sendClientRequest : this.sendServerRequest).bind(this);
    const { endpoint, queryParams } = await this._getApiKeyRequestInfo(options);
    const response = await sendRequest(
      `${endpoint}/${keyId}?${queryParams.toString()}`,
      {
        method: "PATCH",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(data)
      },
      session,
      requestType
    );
    return await response.json();
  }
  async checkProjectApiKey(type, apiKey, session, requestType) {
    const sendRequest = (requestType === "client" ? this.sendClientRequestAndCatchKnownError : this.sendServerRequestAndCatchKnownError).bind(this);
    const result = await sendRequest(
      `/${type}-api-keys/check`,
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({ api_key: apiKey })
      },
      session,
      [import_known_errors.KnownErrors.ApiKeyNotValid]
    );
    if (result.status === "error") {
      return null;
    }
    return await result.data.json();
  }
  async listNotificationCategories(session) {
    const response = await this.sendClientRequest(
      `/emails/notification-preference/me`,
      {},
      session
    );
    const result = await response.json();
    return result.items;
  }
  async setNotificationsEnabled(notificationCategoryId, enabled, session) {
    await this.sendClientRequest(
      `/emails/notification-preference/me/${notificationCategoryId}`,
      {
        method: "PATCH",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({
          enabled
        })
      },
      session
    );
  }
  async getOAuthProvider(userId, providerId, session) {
    const response = await this.sendClientRequest(
      `/oauth-providers/${userId}/${providerId}`,
      {
        method: "GET"
      },
      session
    );
    return await response.json();
  }
  async updateOAuthProvider(userId, providerId, data, session) {
    const response = await this.sendClientRequest(
      `/oauth-providers/${userId}/${providerId}`,
      {
        method: "PATCH",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(data)
      },
      session
    );
    return await response.json();
  }
  async listOAuthProviders(options = {}, session) {
    const queryParams = new URLSearchParams((0, import_objects.filterUndefined)(options));
    const response = await this.sendClientRequest(
      `/oauth-providers${queryParams.toString() ? `?${queryParams.toString()}` : ""}`,
      {
        method: "GET"
      },
      session
    );
    const result = await response.json();
    return result.items;
  }
  async deleteOAuthProvider(userId, providerId, session) {
    const response = await this.sendClientRequest(
      `/oauth-providers/${userId}/${providerId}`,
      {
        method: "DELETE"
      },
      session
    );
    return await response.json();
  }
  async getItem(options, session) {
    let customerType;
    let customerId;
    if ("userId" in options) {
      customerType = "user";
      customerId = options.userId;
    } else if ("teamId" in options) {
      customerType = "team";
      customerId = options.teamId;
    } else if ("customCustomerId" in options) {
      customerType = "custom";
      customerId = options.customCustomerId;
    } else {
      throw new import_errors.StackAssertionError("getItem requires one of userId, teamId, or customCustomerId");
    }
    const response = await this.sendClientRequest(
      import_urls.urlString`/payments/items/${customerType}/${customerId}/${options.itemId}`,
      {},
      session
    );
    return await response.json();
  }
  async listProducts(options, session) {
    const queryParams = new URLSearchParams((0, import_objects.filterUndefined)({
      cursor: options.cursor,
      limit: options.limit !== void 0 ? options.limit.toString() : void 0
    }));
    const path = import_urls.urlString`/payments/products/${options.customer_type}/${options.customer_id}`;
    const response = await this.sendClientRequest(
      `${path}${queryParams.toString() ? `?${queryParams.toString()}` : ""}`,
      {},
      session
    );
    return await response.json();
  }
  async createCheckoutUrl(customer_type, customer_id, productIdOrInline, session, returnUrl) {
    const productBody = typeof productIdOrInline === "string" ? { product_id: productIdOrInline } : { inline_product: productIdOrInline };
    const response = await this.sendClientRequest(
      "/payments/purchases/create-purchase-url",
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({ customer_type, customer_id, ...productBody, return_url: returnUrl })
      },
      session
    );
    const { url } = await response.json();
    return url;
  }
  async transferProject(internalProjectSession, projectIdToTransfer, newTeamId) {
    if (this.options.projectId !== "internal") {
      throw new import_errors.StackAssertionError("StackClientInterface.transferProject() is only available for internal projects (please specify the project ID in the constructor)");
    }
    await this.sendClientRequest(
      "/internal/projects/transfer",
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({
          project_id: projectIdToTransfer,
          new_team_id: newTeamId
        })
      },
      internalProjectSession
    );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  StackClientInterface
});
//# sourceMappingURL=client-interface.js.map