"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/urls.tsx
var urls_exports = {};
__export(urls_exports, {
  createUrlIfValid: () => createUrlIfValid,
  getRelativePart: () => getRelativePart,
  isChildPath: () => isChildPath,
  isChildUrl: () => isChildUrl,
  isLocalhost: () => isLocalhost,
  isRelative: () => isRelative,
  isValidHostname: () => isValidHostname,
  isValidHostnameWithWildcards: () => isValidHostnameWithWildcards,
  isValidUrl: () => isValidUrl,
  matchHostnamePattern: () => matchHostnamePattern,
  url: () => url,
  urlString: () => urlString
});
module.exports = __toCommonJS(urls_exports);
var import_crypto = require("./crypto.js");
var import_strings = require("./strings.js");
function createUrlIfValid(...args) {
  try {
    return new URL(...args);
  } catch (e) {
    return null;
  }
}
function isValidUrl(url2) {
  return !!createUrlIfValid(url2);
}
function isValidHostname(hostname) {
  if (!hostname || hostname.startsWith(".") || hostname.endsWith(".") || hostname.includes("..")) {
    return false;
  }
  const url2 = createUrlIfValid(`https://${hostname}`);
  if (!url2) return false;
  return url2.hostname === hostname;
}
function isValidHostnameWithWildcards(hostname) {
  if (!hostname) return false;
  const hasWildcard = hostname.includes("*");
  if (!hasWildcard) {
    return isValidHostname(hostname);
  }
  if (hostname.startsWith(".") || hostname.endsWith(".")) {
    return false;
  }
  if (hostname.includes("..")) {
    return false;
  }
  const testHostname = hostname.replace(/\*+/g, "wildcard");
  if (!/^[a-zA-Z0-9.-]+$/.test(testHostname)) {
    return false;
  }
  const segments = hostname.split(/\*+/);
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    if (segment === "") continue;
    if (i === 0 && segment.startsWith(".")) {
      return false;
    }
    if (i === segments.length - 1 && segment.endsWith(".")) {
      return false;
    }
    if (segment.includes("..")) {
      return false;
    }
  }
  return true;
}
function matchHostnamePattern(pattern, hostname) {
  if (!pattern.includes("*")) {
    return pattern === hostname;
  }
  let regexPattern = pattern.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
  const doubleWildcardPlaceholder = "\0DOUBLE_WILDCARD\0";
  regexPattern = regexPattern.replace(/\*\*/g, doubleWildcardPlaceholder);
  regexPattern = regexPattern.replace(/\*/g, "[^.]*");
  regexPattern = regexPattern.replace(new RegExp(doubleWildcardPlaceholder, "g"), ".*");
  regexPattern = "^" + regexPattern + "$";
  try {
    const regex = new RegExp(regexPattern);
    return regex.test(hostname);
  } catch {
    return false;
  }
}
function isLocalhost(urlOrString) {
  const url2 = createUrlIfValid(urlOrString);
  if (!url2) return false;
  if (url2.hostname === "localhost" || url2.hostname.endsWith(".localhost")) return true;
  if (url2.hostname.match(/^127\.\d+\.\d+\.\d+$/)) return true;
  return false;
}
function isRelative(url2) {
  const randomDomain = `${(0, import_crypto.generateSecureRandomString)()}.stack-auth.example.com`;
  const u = createUrlIfValid(url2, `https://${randomDomain}`);
  if (!u) return false;
  if (u.host !== randomDomain) return false;
  if (u.protocol !== "https:") return false;
  return true;
}
function getRelativePart(url2) {
  return url2.pathname + url2.search + url2.hash;
}
function url(strings, ...values) {
  return new URL(urlString(strings, ...values));
}
function urlString(strings, ...values) {
  return (0, import_strings.templateIdentity)(strings, ...values.map(encodeURIComponent));
}
function isChildUrl(parentUrl, maybeChildUrl) {
  return parentUrl.origin === maybeChildUrl.origin && isChildPath(parentUrl.pathname, maybeChildUrl.pathname) && [...parentUrl.searchParams].every(([key, value]) => maybeChildUrl.searchParams.get(key) === value) && (!parentUrl.hash || parentUrl.hash === maybeChildUrl.hash);
}
function isChildPath(parentPath, maybeChildPath) {
  parentPath = parentPath.endsWith("/") ? parentPath : parentPath + "/";
  maybeChildPath = maybeChildPath.endsWith("/") ? maybeChildPath : maybeChildPath + "/";
  return maybeChildPath.startsWith(parentPath);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createUrlIfValid,
  getRelativePart,
  isChildPath,
  isChildUrl,
  isLocalhost,
  isRelative,
  isValidHostname,
  isValidHostnameWithWildcards,
  isValidUrl,
  matchHostnamePattern,
  url,
  urlString
});
//# sourceMappingURL=urls.js.map