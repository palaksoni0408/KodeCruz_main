// src/schema-fields.ts
import * as yup from "yup";
import { KnownErrors } from "./known-errors.js";
import { isBase64 } from "./utils/bytes.js";
import { SUPPORTED_CURRENCIES } from "./utils/currency-constants.js";
import { StackAssertionError, throwErr } from "./utils/errors.js";
import { decodeBasicAuthorizationHeader } from "./utils/http.js";
import { allProviders } from "./utils/oauth.js";
import { deepPlainClone, omit, typedFromEntries } from "./utils/objects.js";
import { deindent } from "./utils/strings.js";
import { isValidHostnameWithWildcards, isValidUrl } from "./utils/urls.js";
import { isUuid } from "./utils/uuids.js";
var MAX_IMAGE_SIZE_BASE64_BYTES = 1e6;
yup.addMethod(yup.string, "nonEmpty", function(message) {
  return this.test(
    "non-empty",
    message ?? (({ path }) => `${path} must not be empty`),
    (value) => {
      return value !== "";
    }
  );
});
yup.addMethod(yup.Schema, "hasNested", function(path) {
  if (!path.match(/^[a-zA-Z0-9_$:-]*$/)) throw new StackAssertionError(`yupSchema.hasNested can currently only be used with alphanumeric keys, underscores, dollar signs, colons, and hyphens. Fix this in the future. Provided key: ${JSON.stringify(path)}`);
  const schemaInfo = this.meta()?.stackSchemaInfo;
  if (schemaInfo?.type === "record") {
    return schemaInfo.keySchema.isValidSync(path);
  } else if (schemaInfo?.type === "union") {
    return schemaInfo.items.some((s) => s.hasNested(path));
  } else {
    try {
      yup.reach(this, path);
      return true;
    } catch (e) {
      if (e instanceof Error && e.message.includes("The schema does not contain the path")) {
        return false;
      }
      throw e;
    }
  }
});
yup.addMethod(yup.Schema, "getNested", function(path) {
  if (!path.match(/^[a-zA-Z0-9_$:-]*$/)) throw new StackAssertionError(`yupSchema.getNested can currently only be used with alphanumeric keys, underscores, dollar signs, colons, and hyphens. Fix this in the future. Provided key: ${JSON.stringify(path)}`);
  if (!this.hasNested(path)) throw new StackAssertionError(`Tried to call yupSchema.getNested, but key is not present in the schema. Provided key: ${path}`, { path, schema: this });
  const schemaInfo = this.meta()?.stackSchemaInfo;
  if (schemaInfo?.type === "record") {
    return schemaInfo.valueSchema;
  } else if (schemaInfo?.type === "union") {
    const schemasWithNested = schemaInfo.items.filter((s) => s.hasNested(path));
    return yupUnion(...schemasWithNested.map((s) => s.getNested(path)));
  } else {
    return yup.reach(this, path);
  }
});
async function yupValidate(schema, obj, options) {
  try {
    return await schema.validate(obj, {
      ...omit(options ?? {}, ["currentUserId"]),
      context: {
        ...options?.context,
        stackAllowUserIdMe: options?.currentUserId !== void 0
      }
    });
  } catch (error) {
    if (error instanceof ReplaceFieldWithOwnUserId) {
      const currentUserId = options?.currentUserId;
      if (!currentUserId) throw new KnownErrors.CannotGetOwnUserWithoutUser();
      let pathRemaining = error.path;
      const fieldPath = [];
      while (pathRemaining.length > 0) {
        if (pathRemaining.startsWith("[")) {
          const index = pathRemaining.indexOf("]");
          if (index < 0) throw new StackAssertionError("Invalid path");
          fieldPath.push(JSON.parse(pathRemaining.slice(1, index)));
          pathRemaining = pathRemaining.slice(index + 1);
        } else {
          let dotIndex = pathRemaining.indexOf(".");
          if (dotIndex === -1) dotIndex = pathRemaining.length;
          fieldPath.push(pathRemaining.slice(0, dotIndex));
          pathRemaining = pathRemaining.slice(dotIndex + 1);
        }
      }
      const newObj = deepPlainClone(obj);
      let it = newObj;
      for (const field of fieldPath.slice(0, -1)) {
        if (!Object.prototype.hasOwnProperty.call(it, field)) {
          throw new StackAssertionError(`Segment ${field} of path ${error.path} not found in object`);
        }
        it = it[field];
      }
      it[fieldPath[fieldPath.length - 1]] = currentUserId;
      return await yupValidate(schema, newObj, options);
    }
    throw error;
  }
}
var _idDescription = (identify) => `The unique identifier of the ${identify}`;
var _displayNameDescription = (identify) => `Human-readable ${identify} display name. This is not a unique identifier.`;
var _clientMetaDataDescription = (identify) => `Client metadata. Used as a data store, accessible from the client side. Do not store information that should not be exposed to the client.`;
var _clientReadOnlyMetaDataDescription = (identify) => `Client read-only, server-writable metadata. Used as a data store, accessible from the client side. Do not store information that should not be exposed to the client. The client can read this data, but cannot modify it. This is useful for things like subscription status.`;
var _profileImageUrlDescription = (identify) => `URL of the profile image for ${identify}. Can be a Base64 encoded image. Must be smaller than 100KB. Please compress and crop to a square before passing in.`;
var _serverMetaDataDescription = (identify) => `Server metadata. Used as a data store, only accessible from the server side. You can store secret information related to the ${identify} here.`;
var _atMillisDescription = (identify) => `(the number of milliseconds since epoch, January 1, 1970, UTC)`;
var _createdAtMillisDescription = (identify) => `The time the ${identify} was created ${_atMillisDescription(identify)}`;
var _signedUpAtMillisDescription = `The time the user signed up ${_atMillisDescription}`;
var _lastActiveAtMillisDescription = `The time the user was last active ${_atMillisDescription}`;
function yupString(...args) {
  return yup.string(...args).meta({ stackSchemaInfo: { type: "string" } });
}
function yupNumber(...args) {
  return yup.number(...args).meta({ stackSchemaInfo: { type: "number" } });
}
function yupBoolean(...args) {
  return yup.boolean(...args).meta({ stackSchemaInfo: { type: "boolean" } });
}
function yupDate(...args) {
  return yup.date(...args).meta({ stackSchemaInfo: { type: "date" } });
}
function _yupMixedInternal(...args) {
  return yup.mixed(...args);
}
function yupMixed(...args) {
  return _yupMixedInternal(...args).meta({ stackSchemaInfo: { type: "mixed" } });
}
function yupArray(...args) {
  return yup.array(...args).meta({ stackSchemaInfo: { type: "array" } });
}
function yupTuple(schemas) {
  if (schemas.length === 0) throw new Error("yupTuple must have at least one schema");
  return yup.tuple(schemas).meta({ stackSchemaInfo: { type: "tuple", items: schemas } });
}
function yupObjectWithAutoDefault(...args) {
  const object2 = yup.object(...args).test(
    "no-unknown-object-properties",
    ({ path }) => `${path} contains unknown properties`,
    (value, context) => {
      if (context.options.context?.noUnknownPathPrefixes?.some((prefix) => context.path.startsWith(prefix))) {
        if (context.schema.spec.noUnknown !== false) {
          const availableKeys = new Set(Object.keys(context.schema.fields));
          const unknownKeys = Object.keys(value ?? {}).filter((key) => !availableKeys.has(key));
          if (unknownKeys.length > 0) {
            return context.createError({
              message: `${context.path || "Object"} contains unknown properties: ${unknownKeys.join(", ")}`,
              path: context.path,
              params: { unknownKeys, availableKeys }
            });
          }
        }
      }
      return true;
    }
  ).meta({ stackSchemaInfo: { type: "object" } });
  return object2;
}
function yupObject(...args) {
  const object2 = yupObjectWithAutoDefault(...args);
  return object2.default(void 0);
}
function yupNever() {
  return _yupMixedInternal().meta({ stackSchemaInfo: { type: "never" } }).test("never", "This value should never be reached", () => false);
}
function yupUnion(...args) {
  if (args.length === 0) throw new Error("yupUnion must have at least one schema");
  return _yupMixedInternal().meta({ stackSchemaInfo: { type: "union", items: args } }).test("is-one-of", "Invalid value", async (value, context) => {
    if (value == null) return true;
    const errors = [];
    for (const schema of args) {
      try {
        await yupValidate(schema, value, context.options);
        return true;
      } catch (e) {
        errors.push(e);
      }
    }
    return context.createError({
      message: deindent`
        ${context.path} is not matched by any of the provided schemas:
          ${errors.map((e, i) => deindent`
            Schema ${i}:
              ${e.errors.join("\n")}
          `).join("\n")}`,
      path: context.path
    });
  });
}
function yupRecord(keySchema, valueSchema) {
  return yupObject().meta({ stackSchemaInfo: { type: "record", keySchema, valueSchema } }).unknown(true).test(
    "record",
    "${path} must be a record of valid values",
    async function(value, context) {
      if (value == null) return true;
      const { path, createError } = this;
      if (typeof value !== "object") {
        return createError({ message: `${path} must be an object` });
      }
      for (const key of Object.keys(value)) {
        await yupValidate(keySchema, key, context.options);
        try {
          await yupValidate(valueSchema, value[key], {
            ...context.options,
            context: {
              ...context.options.context,
              path: path ? `${path}.${key}` : key
            }
          });
        } catch (e) {
          return createError({
            path: path ? `${path}.${key}` : key,
            message: e.message
          });
        }
      }
      return true;
    }
  );
}
function ensureObjectSchema(schema) {
  if (!(schema instanceof yup.ObjectSchema)) throw new StackAssertionError(`assertObjectSchema: schema is not an ObjectSchema: ${schema.describe().type}`);
  return schema;
}
var adaptSchema = yupMixed();
var urlSchema = yupString().test({
  name: "no-spaces",
  message: (params) => `${params.path} contains spaces`,
  test: (value) => value == null || !value.includes(" ")
}).test({
  name: "url",
  message: (params) => `${params.path} is not a valid URL`,
  test: (value) => value == null || isValidUrl(value)
});
var wildcardUrlSchema = yupString().test({
  name: "no-spaces",
  message: (params) => `${params.path} contains spaces`,
  test: (value) => value == null || !value.includes(" ")
}).test({
  name: "wildcard-url",
  message: (params) => `${params.path} is not a valid URL or wildcard URL pattern`,
  test: (value) => {
    if (value == null) return true;
    if (!value.includes("*")) {
      return isValidUrl(value);
    }
    try {
      const PLACEHOLDER = "wildcard-placeholder";
      const normalizedUrl = value.replace(/\*/g, PLACEHOLDER);
      const url = new URL(normalizedUrl);
      if (url.username.includes(PLACEHOLDER) || url.password.includes(PLACEHOLDER) || url.pathname.includes(PLACEHOLDER) || url.search.includes(PLACEHOLDER) || url.hash.includes(PLACEHOLDER)) {
        return false;
      }
      if (url.protocol !== "http:" && url.protocol !== "https:") {
        return false;
      }
      const hostPattern = url.hostname.split(PLACEHOLDER).join("*");
      return isValidHostnameWithWildcards(hostPattern);
    } catch (e) {
      return false;
    }
  }
});
var wildcardProtocolAndDomainSchema = wildcardUrlSchema.test({
  name: "is-protocol-and-domain",
  message: (params) => `${params.path} must be a protocol and domain (with optional port) without any path, query parameters, or hash`,
  test: (value) => {
    if (value == null) return true;
    try {
      const PLACEHOLDER = "wildcard-placeholder";
      const normalized = value.replace(/\*/g, PLACEHOLDER);
      const url = new URL(normalized);
      return url.protocol !== "" && url.hostname !== "" && url.pathname === "/" && url.search === "" && url.hash === "";
    } catch (e) {
      return false;
    }
  }
});
var jsonSchema = yupMixed().nullable().defined().transform((value) => JSON.parse(JSON.stringify(value)));
var jsonStringSchema = yupString().test("json", (params) => `${params.path} is not valid JSON`, (value) => {
  if (value == null) return true;
  try {
    JSON.parse(value);
    return true;
  } catch (error) {
    return false;
  }
});
var jsonStringOrEmptySchema = yupString().test("json", (params) => `${params.path} is not valid JSON`, (value) => {
  if (!value) return true;
  try {
    JSON.parse(value);
    return true;
  } catch (error) {
    return false;
  }
});
var base64Schema = yupString().test("is-base64", (params) => `${params.path} is not valid base64`, (value) => {
  if (value == null) return true;
  return isBase64(value);
});
var passwordSchema = yupString().max(70);
var intervalSchema = yupTuple([yupNumber().min(0).integer().defined(), yupString().oneOf(["millisecond", "second", "minute", "hour", "day", "week", "month", "year"]).defined()]);
var dayIntervalSchema = yupTuple([yupNumber().min(0).integer().defined(), yupString().oneOf(["day", "week", "month", "year"]).defined()]);
var intervalOrNeverSchema = yupUnion(intervalSchema.defined(), yupString().oneOf(["never"]).defined());
var dayIntervalOrNeverSchema = yupUnion(dayIntervalSchema.defined(), yupString().oneOf(["never"]).defined());
var userSpecifiedIdSchema = (idName) => yupString().max(63).matches(/^[a-zA-Z0-9_][a-zA-Z0-9_-]*$/, `${idName} must contain only letters, numbers, underscores, and hyphens, and not start with a hyphen`);
var moneyAmountSchema = (currency) => yupString().test("money-amount", "Invalid money amount", (value, context) => {
  if (value == null) return true;
  const regex = /^([0-9]+)(\.([0-9]+))?$/;
  const match = value.match(regex);
  if (!match) return context.createError({ message: "Money amount must be in the format of <number> or <number>.<number>" });
  const whole = match[1];
  const decimals = match[3];
  if (decimals && decimals.length > currency.decimals) return context.createError({ message: `Too many decimals; ${currency.code} only has ${currency.decimals} decimals` });
  if (whole !== "0" && whole.startsWith("0")) return context.createError({ message: "Money amount must not have leading zeros" });
  return true;
});
var strictEmailSchema = (message) => yupString().email(message).max(256).matches(/^[^.]+(\.[^.]+)*@.*\.[^.][^.]+$/, message);
var emailSchema = yupString().email();
var clientOrHigherAuthTypeSchema = yupString().oneOf(["client", "server", "admin"]).defined();
var serverOrHigherAuthTypeSchema = yupString().oneOf(["server", "admin"]).defined();
var adminAuthTypeSchema = yupString().oneOf(["admin"]).defined();
var projectIdSchema = yupString().test((v) => v === void 0 || v === "internal" || isUuid(v)).meta({ openapiField: { description: _idDescription("project"), exampleValue: "e0b52f4d-dece-408c-af49-d23061bb0f8d" } });
var projectBranchIdSchema = yupString().nonEmpty().max(255).meta({ openapiField: { description: _idDescription("project branch"), exampleValue: "main" } });
var projectDisplayNameSchema = yupString().meta({ openapiField: { description: _displayNameDescription("project"), exampleValue: "MyMusic" } });
var projectLogoUrlSchema = urlSchema.max(MAX_IMAGE_SIZE_BASE64_BYTES).meta({ openapiField: { description: "URL of the logo for the project. This is usually a close to 1:1 image of the company logo.", exampleValue: "https://example.com/logo.png" } });
var projectLogoFullUrlSchema = urlSchema.max(MAX_IMAGE_SIZE_BASE64_BYTES).meta({ openapiField: { description: "URL of the full logo for the project. This is usually a vertical image with the logo and the company name.", exampleValue: "https://example.com/full-logo.png" } });
var projectLogoDarkModeUrlSchema = urlSchema.max(MAX_IMAGE_SIZE_BASE64_BYTES).meta({ openapiField: { description: "URL of the dark mode logo for the project. This is usually a close to 1:1 image of the company logo optimized for dark backgrounds.", exampleValue: "https://example.com/logo-dark.png" } });
var projectLogoFullDarkModeUrlSchema = urlSchema.max(MAX_IMAGE_SIZE_BASE64_BYTES).meta({ openapiField: { description: "URL of the dark mode full logo for the project. This is usually a vertical image with the logo and the company name optimized for dark backgrounds.", exampleValue: "https://example.com/full-logo-dark.png" } });
var projectDescriptionSchema = yupString().nullable().meta({ openapiField: { description: "A human readable description of the project", exampleValue: "A music streaming service" } });
var projectCreatedAtMillisSchema = yupNumber().meta({ openapiField: { description: _createdAtMillisDescription("project"), exampleValue: 163e10 } });
var projectIsProductionModeSchema = yupBoolean().meta({ openapiField: { description: "Whether the project is in production mode", exampleValue: true } });
var projectConfigIdSchema = yupString().meta({ openapiField: { description: _idDescription("project config"), exampleValue: "d09201f0-54f5-40bd-89ff-6d1815ddad24" } });
var projectAllowLocalhostSchema = yupBoolean().meta({ openapiField: { description: "Whether localhost is allowed as a domain for this project. Should only be allowed in development mode", exampleValue: true } });
var projectCreateTeamOnSignUpSchema = yupBoolean().meta({ openapiField: { description: "Whether a team should be created for each user that signs up", exampleValue: true } });
var projectMagicLinkEnabledSchema = yupBoolean().meta({ openapiField: { description: "Whether magic link authentication is enabled for this project", exampleValue: true } });
var projectPasskeyEnabledSchema = yupBoolean().meta({ openapiField: { description: "Whether passkey authentication is enabled for this project", exampleValue: true } });
var projectClientTeamCreationEnabledSchema = yupBoolean().meta({ openapiField: { description: "Whether client users can create teams", exampleValue: true } });
var projectClientUserDeletionEnabledSchema = yupBoolean().meta({ openapiField: { description: "Whether client users can delete their own account from the client", exampleValue: true } });
var projectSignUpEnabledSchema = yupBoolean().meta({ openapiField: { description: "Whether users can sign up new accounts, or whether they are only allowed to sign in to existing accounts. Regardless of this option, the server API can always create new users with the `POST /users` endpoint.", exampleValue: true } });
var projectCredentialEnabledSchema = yupBoolean().meta({ openapiField: { description: "Whether email password authentication is enabled for this project", exampleValue: true } });
var oauthIdSchema = yupString().oneOf(allProviders).meta({ openapiField: { description: `OAuth provider ID, one of ${allProviders.map((x) => `\`${x}\``).join(", ")}`, exampleValue: "google" } });
var oauthEnabledSchema = yupBoolean().meta({ openapiField: { description: "Whether the OAuth provider is enabled. If an provider is first enabled, then disabled, it will be shown in the list but with enabled=false", exampleValue: true } });
var oauthTypeSchema = yupString().oneOf(["shared", "standard"]).meta({ openapiField: { description: 'OAuth provider type, one of shared, standard. "shared" uses Stack shared OAuth keys and it is only meant for development. "standard" uses your own OAuth keys and will show your logo and company name when signing in with the provider.', exampleValue: "standard" } });
var oauthClientIdSchema = yupString().meta({ openapiField: { description: 'OAuth client ID. Needs to be specified when using type="standard"', exampleValue: "google-oauth-client-id" } });
var oauthClientSecretSchema = yupString().meta({ openapiField: { description: 'OAuth client secret. Needs to be specified when using type="standard"', exampleValue: "google-oauth-client-secret" } });
var oauthFacebookConfigIdSchema = yupString().meta({ openapiField: { description: "The configuration id for Facebook business login (for things like ads and marketing). This is only required if you are using the standard OAuth with Facebook and you are using Facebook business login." } });
var oauthMicrosoftTenantIdSchema = yupString().meta({ openapiField: { description: "The Microsoft tenant id for Microsoft directory. This is only required if you are using the standard OAuth with Microsoft and you have an Azure AD tenant." } });
var oauthAccountMergeStrategySchema = yupString().oneOf(["link_method", "raise_error", "allow_duplicates"]).meta({ openapiField: { description: "Determines how to handle OAuth logins that match an existing user by email. `link_method` adds the OAuth method to the existing user. `raise_error` rejects the login with an error. `allow_duplicates` creates a new user.", exampleValue: "link_method" } });
var emailTypeSchema = yupString().oneOf(["shared", "standard"]).meta({ openapiField: { description: 'Email provider type, one of shared, standard. "shared" uses Stack shared email provider and it is only meant for development. "standard" uses your own email server and will have your email address as the sender.', exampleValue: "standard" } });
var emailSenderNameSchema = yupString().meta({ openapiField: { description: 'Email sender name. Needs to be specified when using type="standard"', exampleValue: "Stack" } });
var emailHostSchema = yupString().meta({ openapiField: { description: 'Email host. Needs to be specified when using type="standard"', exampleValue: "smtp.your-domain.com" } });
var emailPortSchema = yupNumber().min(0).max(65535).meta({ openapiField: { description: 'Email port. Needs to be specified when using type="standard"', exampleValue: 587 } });
var emailUsernameSchema = yupString().meta({ openapiField: { description: 'Email username. Needs to be specified when using type="standard"', exampleValue: "smtp-email" } });
var emailSenderEmailSchema = emailSchema.meta({ openapiField: { description: 'Email sender email. Needs to be specified when using type="standard"', exampleValue: "example@your-domain.com" } });
var emailPasswordSchema = passwordSchema.meta({ openapiField: { description: 'Email password. Needs to be specified when using type="standard"', exampleValue: "your-email-password" } });
var handlerPathSchema = yupString().test("is-handler-path", "Handler path must start with /", (value) => value?.startsWith("/")).meta({ openapiField: { description: 'Handler path. If you did not setup a custom handler path, it should be "/handler" by default. It needs to start with /', exampleValue: "/handler" } });
var emailThemeSchema = yupString().meta({ openapiField: { description: "Email theme id for the project. Determines the visual style of emails sent by the project." } });
var emailThemeListSchema = yupRecord(
  yupString().uuid(),
  yupObject({
    displayName: yupString().meta({ openapiField: { description: "Email theme name", exampleValue: "Default Light" } }).defined(),
    tsxSource: yupString().meta({ openapiField: { description: "Email theme source code tsx component" } }).defined()
  })
).meta({ openapiField: { description: "Record of email theme IDs to their display name and source code" } });
var templateThemeIdSchema = yupMixed().test((v) => v === void 0 || v === false || v === null || typeof v === "string" && isUuid(v)).meta({ openapiField: { description: "Email theme id for the template" } }).optional();
var emailTemplateListSchema = yupRecord(
  yupString().uuid(),
  yupObject({
    displayName: yupString().meta({ openapiField: { description: "Email template name", exampleValue: "Email Verification" } }).defined(),
    tsxSource: yupString().meta({ openapiField: { description: "Email template source code tsx component" } }).defined(),
    // themeId can be one of three values:
    // 1. A valid theme id
    // 2. false, which means the template uses no theme
    // 3. undefined/not given, which means the template uses the project's active theme
    themeId: templateThemeIdSchema
  })
).meta({ openapiField: { description: "Record of email template IDs to their display name and source code" } });
var customerTypeSchema = yupString().oneOf(["user", "team", "custom"]);
var validateHasAtLeastOneSupportedCurrency = (value, context) => {
  if (!value) return true;
  const currencies = Object.keys(value).filter((key) => SUPPORTED_CURRENCIES.some((c) => c.code === key));
  if (currencies.length === 0) {
    return context.createError({ message: "At least one currency is required" });
  }
  return true;
};
var productPriceSchema = yupObject({
  ...typedFromEntries(SUPPORTED_CURRENCIES.map((currency) => [currency.code, moneyAmountSchema(currency).optional()])),
  interval: dayIntervalSchema.optional(),
  serverOnly: yupBoolean(),
  freeTrial: dayIntervalSchema.optional()
}).test("at-least-one-currency", (value, context) => validateHasAtLeastOneSupportedCurrency(value, context));
var priceOrIncludeByDefaultSchema = yupUnion(
  yupString().oneOf(["include-by-default"]).meta({ openapiField: { description: "Makes this item free and includes it by default for all customers.", exampleValue: "include-by-default" } }),
  yupRecord(
    userSpecifiedIdSchema("priceId"),
    productPriceSchema
  )
);
var productSchema = yupObject({
  displayName: yupString(),
  catalogId: userSpecifiedIdSchema("catalogId").optional().meta({ openapiField: { description: "The ID of the catalog this product belongs to. Within a catalog, all products are mutually exclusive unless they are an add-on to another product in the catalog.", exampleValue: "catalog-id" } }),
  isAddOnTo: yupUnion(
    yupBoolean().isFalse(),
    yupRecord(
      userSpecifiedIdSchema("productId"),
      yupBoolean().isTrue().defined()
    )
  ).optional().meta({ openapiField: { description: "The products that this product is an add-on to. If this is set, the customer must already have one of the products in the record to be able to purchase this product.", exampleValue: { "product-id": true } } }),
  customerType: customerTypeSchema.defined(),
  freeTrial: dayIntervalSchema.optional(),
  serverOnly: yupBoolean(),
  stackable: yupBoolean(),
  prices: priceOrIncludeByDefaultSchema.defined(),
  includedItems: yupRecord(
    userSpecifiedIdSchema("itemId"),
    yupObject({
      quantity: yupNumber().defined(),
      repeat: dayIntervalOrNeverSchema.optional(),
      expires: yupString().oneOf(["never", "when-purchase-expires", "when-repeated"]).optional()
    })
  )
});
var productMetadataExample = { featureFlag: true, source: "marketing-campaign" };
var productClientMetadataSchema = jsonSchema.meta({ openapiField: { description: _clientMetaDataDescription("product"), exampleValue: productMetadataExample } });
var productClientReadOnlyMetadataSchema = jsonSchema.meta({ openapiField: { description: _clientReadOnlyMetaDataDescription("product"), exampleValue: productMetadataExample } });
var productServerMetadataSchema = jsonSchema.meta({ openapiField: { description: _serverMetaDataDescription("product"), exampleValue: productMetadataExample } });
var productSchemaWithMetadata = productSchema.concat(yupObject({
  clientMetadata: productClientMetadataSchema.optional(),
  clientReadOnlyMetadata: productClientReadOnlyMetadataSchema.optional(),
  serverMetadata: productServerMetadataSchema.optional()
}));
var inlineProductSchema = yupObject({
  display_name: yupString().defined(),
  customer_type: customerTypeSchema.defined(),
  free_trial: dayIntervalSchema.optional(),
  server_only: yupBoolean().default(true),
  stackable: yupBoolean().default(false),
  prices: yupRecord(
    userSpecifiedIdSchema("priceId"),
    yupObject({
      ...typedFromEntries(SUPPORTED_CURRENCIES.map((currency) => [currency.code, moneyAmountSchema(currency).optional()])),
      interval: dayIntervalSchema.optional(),
      free_trial: dayIntervalSchema.optional()
    }).test("at-least-one-currency", (value, context) => validateHasAtLeastOneSupportedCurrency(value, context))
  ),
  included_items: yupRecord(
    userSpecifiedIdSchema("itemId"),
    yupObject({
      quantity: yupNumber(),
      repeat: dayIntervalOrNeverSchema.optional(),
      expires: yupString().oneOf(["never", "when-purchase-expires", "when-repeated"]).optional()
    })
  ),
  client_metadata: productClientMetadataSchema.optional(),
  client_read_only_metadata: productClientReadOnlyMetadataSchema.optional(),
  server_metadata: productServerMetadataSchema.optional()
});
var ReplaceFieldWithOwnUserId = class extends Error {
  constructor(path) {
    super(`This error should be caught by whoever validated the schema, and the field in the path '${path}' should be replaced with the current user's id. This is a workaround to yup not providing access to the context inside the transform function.`);
    this.path = path;
  }
};
var userIdMeSentinelUuid = "cad564fd-f81b-43f4-b390-98abf3fcc17e";
var userIdOrMeSchema = yupString().uuid().transform((v) => {
  if (v === "me") return userIdMeSentinelUuid;
  else return v;
}).test((v, context) => {
  if (!("stackAllowUserIdMe" in (context.options.context ?? {}))) throw new StackAssertionError("userIdOrMeSchema is not allowed in this context. Make sure you're using yupValidate from schema-fields.ts to validate, instead of schema.validate(...).");
  if (!context.options.context?.stackAllowUserIdMe) throw new StackAssertionError("userIdOrMeSchema is not allowed in this context. Make sure you're passing in the currentUserId option in yupValidate.");
  if (v === userIdMeSentinelUuid) throw new ReplaceFieldWithOwnUserId(context.path);
  return true;
}).meta({ openapiField: { description: "The ID of the user, or the special value `me` for the currently authenticated user", exampleValue: "3241a285-8329-4d69-8f3d-316e08cf140c" } });
var userIdSchema = yupString().uuid().meta({ openapiField: { description: _idDescription("user"), exampleValue: "3241a285-8329-4d69-8f3d-316e08cf140c" } });
var primaryEmailSchema = emailSchema.meta({ openapiField: { description: "Primary email", exampleValue: "johndoe@example.com" } });
var primaryEmailAuthEnabledSchema = yupBoolean().meta({ openapiField: { description: "Whether the primary email is used for authentication. If this is set to `false`, the user will not be able to sign in with the primary email with password or OTP", exampleValue: true } });
var primaryEmailVerifiedSchema = yupBoolean().meta({ openapiField: { description: "Whether the primary email has been verified to belong to this user", exampleValue: true } });
var userDisplayNameSchema = yupString().nullable().max(256).meta({ openapiField: { description: _displayNameDescription("user"), exampleValue: "John Doe" } });
var selectedTeamIdSchema = yupString().uuid().meta({ openapiField: { description: "ID of the team currently selected by the user", exampleValue: "team-id" } });
var profileImageUrlSchema = urlSchema.max(MAX_IMAGE_SIZE_BASE64_BYTES).meta({ openapiField: { description: _profileImageUrlDescription("user"), exampleValue: "https://example.com/image.jpg" } });
var signedUpAtMillisSchema = yupNumber().meta({ openapiField: { description: _signedUpAtMillisDescription, exampleValue: 163e10 } });
var userClientMetadataSchema = jsonSchema.meta({ openapiField: { description: _clientMetaDataDescription("user"), exampleValue: { key: "value" } } });
var userClientReadOnlyMetadataSchema = jsonSchema.meta({ openapiField: { description: _clientReadOnlyMetaDataDescription("user"), exampleValue: { key: "value" } } });
var userServerMetadataSchema = jsonSchema.meta({ openapiField: { description: _serverMetaDataDescription("user"), exampleValue: { key: "value" } } });
var userOAuthProviderSchema = yupObject({
  id: yupString().defined(),
  type: yupString().oneOf(allProviders).defined(),
  provider_user_id: yupString().defined()
});
var userLastActiveAtMillisSchema = yupNumber().nullable().meta({ openapiField: { description: _lastActiveAtMillisDescription, exampleValue: 163e10 } });
var userPasskeyAuthEnabledSchema = yupBoolean().meta({ openapiField: { hidden: true, description: "Whether the user has passkeys enabled", exampleValue: false } });
var userOtpAuthEnabledSchema = yupBoolean().meta({ openapiField: { hidden: true, description: "Whether the user has OTP/magic link enabled. ", exampleValue: true } });
var userOtpAuthEnabledMutationSchema = yupBoolean().meta({ openapiField: { hidden: true, description: "Whether the user has OTP/magic link enabled. Note that only accounts with verified emails can sign-in with OTP.", exampleValue: true } });
var userHasPasswordSchema = yupBoolean().meta({ openapiField: { hidden: true, description: "Whether the user has a password set. If the user does not have a password set, they will not be able to sign in with email/password.", exampleValue: true } });
var userPasswordMutationSchema = passwordSchema.nullable().meta({ openapiField: { description: "Sets the user's password. Doing so revokes all current sessions.", exampleValue: "my-new-password" } }).max(70);
var userPasswordHashMutationSchema = yupString().nonEmpty().meta({ openapiField: { description: "If `password` is not given, sets the user's password hash to the given string in Modular Crypt Format (ex.: `$2a$10$VIhIOofSMqGdGlL4wzE//e.77dAQGqNtF/1dT7bqCrVtQuInWy2qi`). Doing so revokes all current sessions." } });
var userTotpSecretMutationSchema = base64Schema.nullable().meta({ openapiField: { description: "Enables 2FA and sets a TOTP secret for the user. Set to null to disable 2FA.", exampleValue: "dG90cC1zZWNyZXQ=" } });
var accessTokenPayloadSchema = yupObject({
  sub: yupString().defined(),
  exp: yupNumber().optional(),
  iss: yupString().defined(),
  aud: yupString().defined(),
  project_id: yupString().defined(),
  branch_id: yupString().defined(),
  refresh_token_id: yupString().defined(),
  role: yupString().oneOf(["authenticated"]).defined(),
  name: yupString().defined().nullable(),
  email: yupString().defined().nullable(),
  email_verified: yupBoolean().defined(),
  selected_team_id: yupString().defined().nullable(),
  is_anonymous: yupBoolean().defined()
});
var signInEmailSchema = strictEmailSchema(void 0).meta({ openapiField: { description: "The email to sign in with.", exampleValue: "johndoe@example.com" } });
var emailOtpSignInCallbackUrlSchema = urlSchema.meta({ openapiField: { description: "The base callback URL to construct the magic link from. A query parameter `code` with the verification code will be appended to it. The page should then make a request to the `/auth/otp/sign-in` endpoint.", exampleValue: "https://example.com/handler/magic-link-callback" } });
var emailVerificationCallbackUrlSchema = urlSchema.meta({ openapiField: { description: "The base callback URL to construct a verification link for the verification e-mail. A query parameter `code` with the verification code will be appended to it. The page should then make a request to the `/contact-channels/verify` endpoint.", exampleValue: "https://example.com/handler/email-verification" } });
var accessTokenResponseSchema = yupString().meta({ openapiField: { description: "Short-lived access token that can be used to authenticate the user", exampleValue: "eyJhmMiJB2TO...diI4QT" } });
var refreshTokenResponseSchema = yupString().meta({ openapiField: { description: "Long-lived refresh token that can be used to obtain a new access token", exampleValue: "i8ns3aq2...14y" } });
var signInResponseSchema = yupObject({
  refresh_token: refreshTokenResponseSchema.defined(),
  access_token: accessTokenResponseSchema.defined(),
  is_new_user: yupBoolean().meta({ openapiField: { description: "Whether the user is a new user", exampleValue: true } }).defined(),
  user_id: userIdSchema.defined()
});
var teamSystemPermissions = [
  "$update_team",
  "$delete_team",
  "$read_members",
  "$remove_members",
  "$invite_members",
  "$manage_api_keys"
];
var permissionDefinitionIdSchema = yupString().matches(/^\$?[a-z0-9_:]+$/, 'Only lowercase letters, numbers, ":", "_" and optional "$" at the beginning are allowed').test("is-system-permission", "System permissions must start with a dollar sign", (value, ctx) => {
  if (!value) return true;
  if (value.startsWith("$") && !teamSystemPermissions.includes(value)) {
    return ctx.createError({ message: "Invalid system permission" });
  }
  return true;
}).meta({ openapiField: { description: `The permission ID used to uniquely identify a permission. Can either be a custom permission with lowercase letters, numbers, \`:\`, and \`_\` characters, or one of the system permissions: ${teamSystemPermissions.map((x) => `\`${x}\``).join(", ")}`, exampleValue: "read_secret_info" } });
var customPermissionDefinitionIdSchema = yupString().matches(/^[a-z0-9_:]+$/, 'Only lowercase letters, numbers, ":", "_" are allowed').meta({ openapiField: { description: 'The permission ID used to uniquely identify a permission. Can only contain lowercase letters, numbers, ":", and "_" characters', exampleValue: "read_secret_info" } });
var teamPermissionDescriptionSchema = yupString().meta({ openapiField: { description: "A human-readable description of the permission", exampleValue: "Read secret information" } });
var containedPermissionIdsSchema = yupArray(permissionDefinitionIdSchema.defined()).meta({ openapiField: { description: "The IDs of the permissions that are contained in this permission", exampleValue: ["read_public_info"] } });
var teamIdSchema = yupString().uuid().meta({ openapiField: { description: _idDescription("team"), exampleValue: "ad962777-8244-496a-b6a2-e0c6a449c79e" } });
var teamDisplayNameSchema = yupString().meta({ openapiField: { description: _displayNameDescription("team"), exampleValue: "My Team" } });
var teamProfileImageUrlSchema = urlSchema.max(1e6).meta({ openapiField: { description: _profileImageUrlDescription("team"), exampleValue: "https://example.com/image.jpg" } });
var teamClientMetadataSchema = jsonSchema.meta({ openapiField: { description: _clientMetaDataDescription("team"), exampleValue: { key: "value" } } });
var teamClientReadOnlyMetadataSchema = jsonSchema.meta({ openapiField: { description: _clientReadOnlyMetaDataDescription("team"), exampleValue: { key: "value" } } });
var teamServerMetadataSchema = jsonSchema.meta({ openapiField: { description: _serverMetaDataDescription("team"), exampleValue: { key: "value" } } });
var teamCreatedAtMillisSchema = yupNumber().meta({ openapiField: { description: _createdAtMillisDescription("team"), exampleValue: 163e10 } });
var teamInvitationEmailSchema = emailSchema.meta({ openapiField: { description: "The email of the user to invite.", exampleValue: "johndoe@example.com" } });
var teamInvitationCallbackUrlSchema = urlSchema.meta({ openapiField: { description: "The base callback URL to construct an invite link with. A query parameter `code` with the verification code will be appended to it. The page should then make a request to the `/team-invitations/accept` endpoint.", exampleValue: "https://example.com/handler/team-invitation" } });
var teamCreatorUserIdSchema = userIdOrMeSchema.meta({ openapiField: { description: 'The ID of the creator of the team. If not specified, the user will not be added to the team. Can be either "me" or the ID of the user. Only used on the client side.', exampleValue: "me" } });
var teamMemberDisplayNameSchema = yupString().meta({ openapiField: { description: _displayNameDescription("team member") + " Note that this is separate from the display_name of the user.", exampleValue: "John Doe" } });
var teamMemberProfileImageUrlSchema = urlSchema.max(1e6).meta({ openapiField: { description: _profileImageUrlDescription("team member"), exampleValue: "https://example.com/image.jpg" } });
var contactChannelIdSchema = yupString().uuid().meta({ openapiField: { description: _idDescription("contact channel"), exampleValue: "b3d396b8-c574-4c80-97b3-50031675ceb2" } });
var contactChannelTypeSchema = yupString().oneOf(["email"]).meta({ openapiField: { description: `The type of the contact channel. Currently only "email" is supported.`, exampleValue: "email" } });
var contactChannelValueSchema = yupString().when("type", {
  is: "email",
  then: (schema) => schema.email()
}).meta({ openapiField: { description: "The value of the contact channel. For email, this should be a valid email address.", exampleValue: "johndoe@example.com" } });
var contactChannelUsedForAuthSchema = yupBoolean().meta({ openapiField: { description: "Whether the contact channel is used for authentication. If this is set to `true`, the user will be able to sign in with the contact channel with password or OTP.", exampleValue: true } });
var contactChannelIsVerifiedSchema = yupBoolean().meta({ openapiField: { description: "Whether the contact channel has been verified. If this is set to `true`, the contact channel has been verified to belong to the user.", exampleValue: true } });
var contactChannelIsPrimarySchema = yupBoolean().meta({ openapiField: { description: "Whether the contact channel is the primary contact channel. If this is set to `true`, it will be used for authentication and notifications by default.", exampleValue: true } });
var oauthProviderIdSchema = yupString().uuid().meta({ openapiField: { description: _idDescription("OAuth provider"), exampleValue: "b3d396b8-c574-4c80-97b3-50031675ceb2" } });
var oauthProviderEmailSchema = emailSchema.meta({ openapiField: { description: "Email of the OAuth provider. This is used to display and identify the OAuth provider in the UI.", exampleValue: "test@gmail.com" } });
var oauthProviderTypeSchema = yupString().oneOf(allProviders).meta({ openapiField: { description: `OAuth provider type, one of ${allProviders.map((x) => `\`${x}\``).join(", ")}`, exampleValue: "google" } });
var oauthProviderAllowSignInSchema = yupBoolean().meta({ openapiField: { description: "Whether the user can use this OAuth provider to sign in. Only one OAuth provider per type can have this set to `true`.", exampleValue: true } });
var oauthProviderAllowConnectedAccountsSchema = yupBoolean().meta({ openapiField: { description: "Whether the user can use this OAuth provider as connected account. Multiple OAuth providers per type can have this set to `true`.", exampleValue: true } });
var oauthProviderAccountIdSchema = yupString().meta({ openapiField: { description: "Account ID of the OAuth provider. This uniquely identifies the account on the provider side.", exampleValue: "google-account-id-12345" } });
var oauthProviderProviderConfigIdSchema = yupString().meta({ openapiField: { description: "Provider config ID of the OAuth provider. This uniquely identifies the provider config on config.json file", exampleValue: "google" } });
var basicAuthorizationHeaderSchema = yupString().test("is-basic-authorization-header", 'Authorization header must be in the format "Basic <base64>"', (value) => {
  if (!value) return true;
  return decodeBasicAuthorizationHeader(value) !== null;
});
var neonAuthorizationHeaderSchema = basicAuthorizationHeaderSchema.test("is-authorization-header", "Invalid client_id:client_secret values; did you use the correct values for the integration?", (value) => {
  if (!value) return true;
  const [clientId, clientSecret] = decodeBasicAuthorizationHeader(value) ?? throwErr(`Authz header invalid? This should've been validated by basicAuthorizationHeaderSchema: ${value}`);
  for (const neonClientConfig of JSON.parse(process.env.STACK_INTEGRATION_CLIENTS_CONFIG || "[]")) {
    if (clientId === neonClientConfig.client_id && clientSecret === neonClientConfig.client_secret) return true;
  }
  return false;
});
function yupDefinedWhen(schema, triggers) {
  const entries = Object.entries(triggers);
  return schema.when(entries.map(([key]) => key), {
    is: (...values) => entries.every(([key, value], index) => value === values[index]),
    then: (schema2) => schema2.defined(),
    otherwise: (schema2) => schema2.optional()
  });
}
function yupDefinedAndNonEmptyWhen(schema, triggers) {
  const entries = Object.entries(triggers);
  return schema.when(entries.map(([key]) => key), {
    is: (...values) => entries.every(([key, value], index) => value === values[index]),
    then: (schema2) => schema2.defined().nonEmpty(),
    otherwise: (schema2) => schema2.optional()
  });
}
export {
  ReplaceFieldWithOwnUserId,
  accessTokenPayloadSchema,
  accessTokenResponseSchema,
  adaptSchema,
  adminAuthTypeSchema,
  base64Schema,
  basicAuthorizationHeaderSchema,
  clientOrHigherAuthTypeSchema,
  contactChannelIdSchema,
  contactChannelIsPrimarySchema,
  contactChannelIsVerifiedSchema,
  contactChannelTypeSchema,
  contactChannelUsedForAuthSchema,
  contactChannelValueSchema,
  containedPermissionIdsSchema,
  customPermissionDefinitionIdSchema,
  customerTypeSchema,
  dayIntervalOrNeverSchema,
  dayIntervalSchema,
  emailHostSchema,
  emailOtpSignInCallbackUrlSchema,
  emailPasswordSchema,
  emailPortSchema,
  emailSchema,
  emailSenderEmailSchema,
  emailSenderNameSchema,
  emailTemplateListSchema,
  emailThemeListSchema,
  emailThemeSchema,
  emailTypeSchema,
  emailUsernameSchema,
  emailVerificationCallbackUrlSchema,
  ensureObjectSchema,
  handlerPathSchema,
  inlineProductSchema,
  intervalOrNeverSchema,
  intervalSchema,
  jsonSchema,
  jsonStringOrEmptySchema,
  jsonStringSchema,
  moneyAmountSchema,
  neonAuthorizationHeaderSchema,
  oauthAccountMergeStrategySchema,
  oauthClientIdSchema,
  oauthClientSecretSchema,
  oauthEnabledSchema,
  oauthFacebookConfigIdSchema,
  oauthIdSchema,
  oauthMicrosoftTenantIdSchema,
  oauthProviderAccountIdSchema,
  oauthProviderAllowConnectedAccountsSchema,
  oauthProviderAllowSignInSchema,
  oauthProviderEmailSchema,
  oauthProviderIdSchema,
  oauthProviderProviderConfigIdSchema,
  oauthProviderTypeSchema,
  oauthTypeSchema,
  passwordSchema,
  permissionDefinitionIdSchema,
  priceOrIncludeByDefaultSchema,
  primaryEmailAuthEnabledSchema,
  primaryEmailSchema,
  primaryEmailVerifiedSchema,
  productClientMetadataSchema,
  productClientReadOnlyMetadataSchema,
  productPriceSchema,
  productSchema,
  productSchemaWithMetadata,
  productServerMetadataSchema,
  profileImageUrlSchema,
  projectAllowLocalhostSchema,
  projectBranchIdSchema,
  projectClientTeamCreationEnabledSchema,
  projectClientUserDeletionEnabledSchema,
  projectConfigIdSchema,
  projectCreateTeamOnSignUpSchema,
  projectCreatedAtMillisSchema,
  projectCredentialEnabledSchema,
  projectDescriptionSchema,
  projectDisplayNameSchema,
  projectIdSchema,
  projectIsProductionModeSchema,
  projectLogoDarkModeUrlSchema,
  projectLogoFullDarkModeUrlSchema,
  projectLogoFullUrlSchema,
  projectLogoUrlSchema,
  projectMagicLinkEnabledSchema,
  projectPasskeyEnabledSchema,
  projectSignUpEnabledSchema,
  refreshTokenResponseSchema,
  selectedTeamIdSchema,
  serverOrHigherAuthTypeSchema,
  signInEmailSchema,
  signInResponseSchema,
  signedUpAtMillisSchema,
  strictEmailSchema,
  teamClientMetadataSchema,
  teamClientReadOnlyMetadataSchema,
  teamCreatedAtMillisSchema,
  teamCreatorUserIdSchema,
  teamDisplayNameSchema,
  teamIdSchema,
  teamInvitationCallbackUrlSchema,
  teamInvitationEmailSchema,
  teamMemberDisplayNameSchema,
  teamMemberProfileImageUrlSchema,
  teamPermissionDescriptionSchema,
  teamProfileImageUrlSchema,
  teamServerMetadataSchema,
  teamSystemPermissions,
  templateThemeIdSchema,
  urlSchema,
  userClientMetadataSchema,
  userClientReadOnlyMetadataSchema,
  userDisplayNameSchema,
  userHasPasswordSchema,
  userIdOrMeSchema,
  userIdSchema,
  userLastActiveAtMillisSchema,
  userOAuthProviderSchema,
  userOtpAuthEnabledMutationSchema,
  userOtpAuthEnabledSchema,
  userPasskeyAuthEnabledSchema,
  userPasswordHashMutationSchema,
  userPasswordMutationSchema,
  userServerMetadataSchema,
  userSpecifiedIdSchema,
  userTotpSecretMutationSchema,
  wildcardProtocolAndDomainSchema,
  wildcardUrlSchema,
  yupArray,
  yupBoolean,
  yupDate,
  yupDefinedAndNonEmptyWhen,
  yupDefinedWhen,
  yupMixed,
  yupNever,
  yupNumber,
  yupObject,
  yupObjectWithAutoDefault,
  yupRecord,
  yupString,
  yupTuple,
  yupUnion,
  yupValidate
};
//# sourceMappingURL=schema-fields.js.map