// src/interface/server-interface.ts
import { decryptValue, encryptValue, hashKey } from "../helpers/vault/client-side.js";
import { KnownErrors } from "../known-errors.js";
import { InternalSession } from "../sessions.js";
import { StackAssertionError } from "../utils/errors.js";
import { filterUndefined } from "../utils/objects.js";
import { Result } from "../utils/results.js";
import { urlString } from "../utils/urls.js";
import {
  StackClientInterface
} from "./client-interface.js";
var StackServerInterface = class extends StackClientInterface {
  constructor(options) {
    super(options);
    this.options = options;
  }
  async sendServerRequest(path, options, session, requestType = "server") {
    return await this.sendClientRequest(
      path,
      {
        ...options,
        headers: {
          "x-stack-secret-server-key": "secretServerKey" in this.options ? this.options.secretServerKey : "",
          ...options.headers
        }
      },
      session,
      requestType
    );
  }
  async sendServerRequestAndCatchKnownError(path, requestOptions, tokenStoreOrNull, errorsToCatch) {
    try {
      return Result.ok(await this.sendServerRequest(path, requestOptions, tokenStoreOrNull));
    } catch (e) {
      for (const errorType of errorsToCatch) {
        if (errorType.isInstance(e)) {
          return Result.error(e);
        }
      }
      throw e;
    }
  }
  async createServerUser(data) {
    const response = await this.sendServerRequest(
      "/users",
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(data)
      },
      null
    );
    return await response.json();
  }
  async getServerUserByToken(session) {
    const responseOrError = await this.sendServerRequestAndCatchKnownError(
      "/users/me",
      {},
      session,
      [KnownErrors.CannotGetOwnUserWithoutUser]
    );
    if (responseOrError.status === "error") {
      if (KnownErrors.CannotGetOwnUserWithoutUser.isInstance(responseOrError.error)) {
        return null;
      } else {
        throw new StackAssertionError("Unexpected uncaught error", { cause: responseOrError.error });
      }
    }
    const response = responseOrError.data;
    const user = await response.json();
    if (!user) throw new StackAssertionError("User endpoint returned null; this should never happen");
    return user;
  }
  async getServerUserById(userId) {
    const responseOrError = await this.sendServerRequestAndCatchKnownError(
      urlString`/users/${userId}`,
      {},
      null,
      [KnownErrors.UserNotFound]
    );
    if (responseOrError.status === "error") {
      return Result.error(responseOrError.error);
    }
    const user = await responseOrError.data.json();
    return Result.ok(user);
  }
  async listServerTeamInvitations(options) {
    const response = await this.sendServerRequest(
      urlString`/team-invitations?team_id=${options.teamId}`,
      {},
      null
    );
    const result = await response.json();
    return result.items;
  }
  async revokeServerTeamInvitation(invitationId, teamId) {
    await this.sendServerRequest(
      urlString`/team-invitations/${invitationId}?team_id=${teamId}`,
      { method: "DELETE" },
      null
    );
  }
  async listServerTeamMemberProfiles(options) {
    const response = await this.sendServerRequest(
      urlString`/team-member-profiles?team_id=${options.teamId}`,
      {},
      null
    );
    const result = await response.json();
    return result.items;
  }
  async getServerTeamMemberProfile(options) {
    const response = await this.sendServerRequest(
      urlString`/team-member-profiles/${options.teamId}/${options.userId}`,
      {},
      null
    );
    return await response.json();
  }
  async listServerTeamPermissions(options, session) {
    const response = await this.sendServerRequest(
      `/team-permissions?${new URLSearchParams(filterUndefined({
        user_id: options.userId,
        team_id: options.teamId,
        recursive: options.recursive.toString()
      }))}`,
      {},
      session
    );
    const result = await response.json();
    return result.items;
  }
  async listServerProjectPermissions(options, session) {
    const response = await this.sendServerRequest(
      `/project-permissions?${new URLSearchParams(filterUndefined({
        user_id: options.userId,
        recursive: options.recursive.toString()
      }))}`,
      {},
      session
    );
    const result = await response.json();
    return result.items;
  }
  async listServerUsers(options) {
    const searchParams = new URLSearchParams(filterUndefined({
      cursor: options.cursor,
      limit: options.limit?.toString(),
      desc: options.desc?.toString(),
      ...options.orderBy ? {
        order_by: {
          signedUpAt: "signed_up_at"
        }[options.orderBy]
      } : {},
      ...options.query ? {
        query: options.query
      } : {},
      ...options.includeAnonymous ? {
        include_anonymous: "true"
      } : {}
    }));
    const response = await this.sendServerRequest("/users?" + searchParams.toString(), {}, null);
    return await response.json();
  }
  async listServerTeams(options) {
    const response = await this.sendServerRequest(
      `/teams?${new URLSearchParams(filterUndefined({
        user_id: options?.userId
      }))}`,
      {},
      null
    );
    const result = await response.json();
    return result.items;
  }
  async getServerTeam(teamId) {
    const response = await this.sendServerRequest(
      `/teams/${teamId}`,
      {},
      null
    );
    return await response.json();
  }
  async listServerTeamUsers(teamId) {
    const response = await this.sendServerRequest(`/users?team_id=${teamId}`, {}, null);
    const result = await response.json();
    return result.items;
  }
  /* when passing a session, the user will be added to the team */
  async createServerTeam(data) {
    const response = await this.sendServerRequest(
      "/teams",
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(data)
      },
      null
    );
    return await response.json();
  }
  async updateServerTeam(teamId, data) {
    const response = await this.sendServerRequest(
      urlString`/teams/${teamId}`,
      {
        method: "PATCH",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(data)
      },
      null
    );
    return await response.json();
  }
  async deleteServerTeam(teamId) {
    await this.sendServerRequest(
      urlString`/teams/${teamId}`,
      { method: "DELETE" },
      null
    );
  }
  async addServerUserToTeam(options) {
    const response = await this.sendServerRequest(
      urlString`/team-memberships/${options.teamId}/${options.userId}`,
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({})
      },
      null
    );
    return await response.json();
  }
  async removeServerUserFromTeam(options) {
    await this.sendServerRequest(
      urlString`/team-memberships/${options.teamId}/${options.userId}`,
      {
        method: "DELETE",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({})
      },
      null
    );
  }
  async updateServerUser(userId, update) {
    const response = await this.sendServerRequest(
      urlString`/users/${userId}`,
      {
        method: "PATCH",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(update)
      },
      null
    );
    return await response.json();
  }
  async createServerProviderAccessToken(userId, provider, scope) {
    const response = await this.sendServerRequest(
      urlString`/connected-accounts/${userId}/${provider}/access-token`,
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({ scope })
      },
      null
    );
    return await response.json();
  }
  async createServerUserSession(userId, expiresInMillis, isImpersonation) {
    const response = await this.sendServerRequest(
      "/auth/sessions",
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({
          user_id: userId,
          expires_in_millis: expiresInMillis,
          is_impersonation: isImpersonation
        })
      },
      null
    );
    const result = await response.json();
    return {
      accessToken: result.access_token,
      refreshToken: result.refresh_token
    };
  }
  async leaveServerTeam(options) {
    await this.sendClientRequest(
      urlString`/team-memberships/${options.teamId}/${options.userId}`,
      {
        method: "DELETE",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({})
      },
      null
    );
  }
  async updateServerTeamMemberProfile(options) {
    await this.sendServerRequest(
      urlString`/team-member-profiles/${options.teamId}/${options.userId}`,
      {
        method: "PATCH",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(options.profile)
      },
      null
    );
  }
  async grantServerTeamUserPermission(teamId, userId, permissionId) {
    await this.sendServerRequest(
      urlString`/team-permissions/${teamId}/${userId}/${permissionId}`,
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({})
      },
      null
    );
  }
  async grantServerProjectPermission(userId, permissionId) {
    await this.sendServerRequest(
      urlString`/project-permissions/${userId}/${permissionId}`,
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({})
      },
      null
    );
  }
  async revokeServerTeamUserPermission(teamId, userId, permissionId) {
    await this.sendServerRequest(
      urlString`/team-permissions/${teamId}/${userId}/${permissionId}`,
      {
        method: "DELETE",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({})
      },
      null
    );
  }
  async revokeServerProjectPermission(userId, permissionId) {
    await this.sendServerRequest(
      urlString`/project-permissions/${userId}/${permissionId}`,
      {
        method: "DELETE",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({})
      },
      null
    );
  }
  async deleteServerUser(userId) {
    await this.sendServerRequest(
      urlString`/users/${userId}`,
      {
        method: "DELETE",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({})
      },
      null
    );
  }
  async createServerContactChannel(data) {
    const response = await this.sendServerRequest(
      "/contact-channels",
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(data)
      },
      null
    );
    return await response.json();
  }
  async updateServerContactChannel(userId, contactChannelId, data) {
    const response = await this.sendServerRequest(
      urlString`/contact-channels/${userId}/${contactChannelId}`,
      {
        method: "PATCH",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(data)
      },
      null
    );
    return await response.json();
  }
  async deleteServerContactChannel(userId, contactChannelId) {
    await this.sendServerRequest(
      urlString`/contact-channels/${userId}/${contactChannelId}`,
      {
        method: "DELETE"
      },
      null
    );
  }
  async listServerContactChannels(userId) {
    const response = await this.sendServerRequest(
      urlString`/contact-channels?user_id=${userId}`,
      {
        method: "GET"
      },
      null
    );
    const json = await response.json();
    return json.items;
  }
  async listServerNotificationCategories(userId) {
    const response = await this.sendServerRequest(
      urlString`/emails/notification-preference/${userId}`,
      {
        method: "GET"
      },
      null
    );
    const json = await response.json();
    return json.items;
  }
  async setServerNotificationsEnabled(userId, notificationCategoryId, enabled) {
    await this.sendServerRequest(
      urlString`/emails/notification-preference/${userId}/${notificationCategoryId}`,
      {
        method: "PATCH",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({
          enabled
        })
      },
      null
    );
  }
  async sendServerContactChannelVerificationEmail(userId, contactChannelId, callbackUrl) {
    await this.sendServerRequest(
      urlString`/contact-channels/${userId}/${contactChannelId}/send-verification-code`,
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({ callback_url: callbackUrl })
      },
      null
    );
  }
  async listServerSessions(userId) {
    const response = await this.sendServerRequest(
      urlString`/auth/sessions?user_id=${userId}`,
      {
        method: "GET"
      },
      null
    );
    return await response.json();
  }
  async deleteServerSession(sessionId) {
    await this.sendServerRequest(
      urlString`/auth/sessions/${sessionId}`,
      {
        method: "DELETE"
      },
      null
    );
  }
  async sendServerTeamInvitation(options) {
    await this.sendServerRequest(
      "/team-invitations/send-code",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          email: options.email,
          team_id: options.teamId,
          callback_url: options.callbackUrl
        })
      },
      null
    );
  }
  async updatePassword(options) {
    const res = await this.sendServerRequestAndCatchKnownError(
      "/auth/password/update",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          old_password: options.oldPassword,
          new_password: options.newPassword
        })
      },
      null,
      [KnownErrors.PasswordConfirmationMismatch, KnownErrors.PasswordRequirementsNotMet]
    );
    if (res.status === "error") {
      return res.error;
    }
  }
  // OAuth Providers CRUD operations
  async createServerOAuthProvider(data) {
    const response = await this.sendServerRequest(
      "/oauth-providers",
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(data)
      },
      null
    );
    return await response.json();
  }
  async listServerOAuthProviders(options = {}) {
    const queryParams = new URLSearchParams(filterUndefined(options));
    const response = await this.sendServerRequest(
      `/oauth-providers${queryParams.toString() ? `?${queryParams.toString()}` : ""}`,
      {
        method: "GET"
      },
      null
    );
    const result = await response.json();
    return result.items;
  }
  async updateServerOAuthProvider(userId, providerId, data) {
    const response = await this.sendServerRequest(
      urlString`/oauth-providers/${userId}/${providerId}`,
      {
        method: "PATCH",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(data)
      },
      null
    );
    return await response.json();
  }
  async deleteServerOAuthProvider(userId, providerId) {
    const response = await this.sendServerRequest(
      urlString`/oauth-providers/${userId}/${providerId}`,
      {
        method: "DELETE"
      },
      null
    );
    return await response.json();
  }
  async sendEmail(options) {
    const res = await this.sendServerRequest(
      "/emails/send-email",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          user_ids: options.userIds,
          all_users: options.allUsers,
          theme_id: options.themeId,
          html: options.html,
          subject: options.subject,
          notification_category_name: options.notificationCategoryName,
          template_id: options.templateId,
          variables: options.variables,
          draft_id: options.draftId
        })
      },
      null
    );
    return Result.ok(void 0);
  }
  async updateItemQuantity(options, data) {
    let customerType;
    let customerId;
    const itemId = options.itemId;
    if ("userId" in options) {
      customerType = "user";
      customerId = options.userId;
    } else if ("teamId" in options) {
      customerType = "team";
      customerId = options.teamId;
    } else if ("customCustomerId" in options) {
      customerType = "custom";
      customerId = options.customCustomerId;
    } else {
      throw new StackAssertionError("updateItemQuantity requires one of userId, teamId, or customCustomerId");
    }
    const queryParams = new URLSearchParams({ allow_negative: (data.allow_negative ?? false).toString() });
    await this.sendServerRequest(
      `/payments/items/${customerType}/${customerId}/${itemId}/update-quantity?${queryParams.toString()}`,
      {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ delta: data.delta, expires_at: data.expires_at, description: data.description })
      },
      null
    );
  }
  async grantProduct(options) {
    if (!options.productId && !options.product) {
      throw new StackAssertionError("grantProduct requires either productId or product");
    }
    if (options.productId && options.product) {
      throw new StackAssertionError("grantProduct should not receive both productId and product");
    }
    const body = filterUndefined({
      product_id: options.productId,
      product_inline: options.product,
      quantity: options.quantity
    });
    await this.sendServerRequest(
      urlString`/payments/products/${options.customerType}/${options.customerId}`,
      {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(body)
      },
      null
    );
  }
  async getDataVaultStoreValue(secret, storeId, key) {
    const hashedKey = await hashKey(secret, key);
    const response = await this.sendServerRequestAndCatchKnownError(
      `/data-vault/stores/${storeId}/get`,
      {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ hashed_key: hashedKey })
      },
      null,
      [KnownErrors.DataVaultStoreHashedKeyDoesNotExist]
    );
    if (response.status === "error") {
      if (KnownErrors.DataVaultStoreHashedKeyDoesNotExist.isInstance(response.error)) {
        return null;
      } else {
        throw new StackAssertionError("Unexpected uncaught error", { cause: response.error });
      }
    }
    const json = await response.data.json();
    const encryptedValue = json.encrypted_value;
    if (typeof encryptedValue !== "string") throw new StackAssertionError("encrypted_value is not a string", { type: typeof encryptedValue });
    return await decryptValue(secret, key, encryptedValue);
  }
  async setDataVaultStoreValue(secret, storeId, key, value) {
    const hashedKey = await hashKey(secret, key);
    const encryptedValue = await encryptValue(secret, key, value);
    await this.sendServerRequest(
      `/data-vault/stores/${storeId}/set`,
      {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ hashed_key: hashedKey, encrypted_value: encryptedValue })
      },
      null
    );
  }
  async initiateServerPasskeyRegistration(userId) {
    const { accessToken, refreshToken } = await this.createServerUserSession(userId, 6e4 * 2, false);
    const tempSession = new InternalSession({
      accessToken,
      refreshToken,
      refreshAccessTokenCallback: async () => null
      // No refresh for temporary sessions
    });
    return await this.initiatePasskeyRegistration({}, tempSession);
  }
};
export {
  StackServerInterface
};
//# sourceMappingURL=server-interface.js.map