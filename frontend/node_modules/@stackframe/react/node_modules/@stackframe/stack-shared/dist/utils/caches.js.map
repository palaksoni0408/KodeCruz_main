{"version":3,"sources":["../../src/utils/caches.tsx"],"sourcesContent":["import { isBrowserLike } from \"./env\";\nimport { DependenciesMap } from \"./maps\";\nimport { filterUndefined } from \"./objects\";\nimport { RateLimitOptions, ReactPromise, pending, rateLimited, resolved, runAsynchronously, wait } from \"./promises\";\nimport { AsyncStore } from \"./stores\";\n\n/**\n * Can be used to cache the result of a function call, for example for the `use` hook in React.\n */\nexport function cacheFunction<F extends Function>(f: F): F {\n  const dependenciesMap = new DependenciesMap<any, any>();\n\n  return ((...args: any) => {\n    if (dependenciesMap.has(args)) {\n      return dependenciesMap.get(args);\n    }\n\n    const value = f(...args);\n    dependenciesMap.set(args, value);\n    return value;\n  }) as any as F;\n}\nundefined?.test(\"cacheFunction\", ({ expect }) => {\n  // Test with a simple function\n  let callCount = 0;\n  const add = (a: number, b: number) => {\n    callCount++;\n    return a + b;\n  };\n\n  const cachedAdd = cacheFunction(add);\n\n  // First call should execute the function\n  expect(cachedAdd(1, 2)).toBe(3);\n  expect(callCount).toBe(1);\n\n  // Second call with same args should use cached result\n  expect(cachedAdd(1, 2)).toBe(3);\n  expect(callCount).toBe(1);\n\n  // Call with different args should execute the function again\n  expect(cachedAdd(2, 3)).toBe(5);\n  expect(callCount).toBe(2);\n\n  // Test with a function that returns objects\n  let objectCallCount = 0;\n  const createObject = (id: number) => {\n    objectCallCount++;\n    return { id };\n  };\n\n  const cachedCreateObject = cacheFunction(createObject);\n\n  // First call should execute the function\n  const obj1 = cachedCreateObject(1);\n  expect(obj1).toEqual({ id: 1 });\n  expect(objectCallCount).toBe(1);\n\n  // Second call with same args should use cached result\n  const obj2 = cachedCreateObject(1);\n  expect(obj2).toBe(obj1); // Same reference\n  expect(objectCallCount).toBe(1);\n});\n\n\ntype CacheStrategy = \"write-only\" | \"read-write\" | \"never\";\n\nexport class AsyncCache<D extends any[], T> {\n  private readonly _map = new DependenciesMap<D, AsyncValueCache<T>>();\n\n  constructor(\n    private readonly _fetcher: (dependencies: D) => Promise<T>,\n    private readonly _options: {\n      onSubscribe?: (key: D, refresh: () => void) => (() => void),\n      rateLimiter?: Omit<RateLimitOptions, \"batchCalls\">,\n    } = {},\n  ) {\n    // nothing here yet\n  }\n\n  private _createKeyed<FunctionName extends keyof AsyncValueCache<T>>(\n    functionName: FunctionName,\n  ): (key: D, ...args: Parameters<AsyncValueCache<T>[FunctionName]>) => ReturnType<AsyncValueCache<T>[FunctionName]> {\n    return (key: D, ...args) => {\n      const valueCache = this.getValueCache(key);\n      return (valueCache[functionName] as any).apply(valueCache, args);\n    };\n  }\n\n  getValueCache(dependencies: D): AsyncValueCache<T> {\n    let cache = this._map.get(dependencies);\n    if (!cache) {\n      cache = new AsyncValueCache(\n        async () => await this._fetcher(dependencies),\n        {\n          ...this._options,\n          onSubscribe: this._options.onSubscribe ? (cb) => this._options.onSubscribe!(dependencies, cb) : undefined,\n        },\n      );\n      this._map.set(dependencies, cache);\n    }\n    return cache;\n  }\n\n  async refreshWhere(predicate: (dependencies: D) => boolean) {\n    const promises: Promise<void>[] = [];\n    for (const [dependencies, cache] of this._map) {\n      if (predicate(dependencies)) {\n        promises.push(cache.refresh());\n      }\n    }\n    await Promise.all(promises);\n  }\n\n  async invalidateWhere(predicate: (dependencies: D) => boolean) {\n    const promises: Promise<void>[] = [];\n    for (const [dependencies, cache] of this._map) {\n      if (predicate(dependencies)) {\n        promises.push(cache.invalidate().catch(() => undefined));\n      }\n    }\n    await Promise.all(promises);\n  }\n\n  readonly isCacheAvailable = this._createKeyed(\"isCacheAvailable\");\n  readonly getIfCached = this._createKeyed(\"getIfCached\");\n  readonly getOrWait = this._createKeyed(\"getOrWait\");\n  readonly forceSetCachedValue = this._createKeyed(\"forceSetCachedValue\");\n  readonly forceSetCachedValueAsync = this._createKeyed(\"forceSetCachedValueAsync\");\n  readonly refresh = this._createKeyed(\"refresh\");\n  readonly invalidate = this._createKeyed(\"invalidate\");\n  readonly onStateChange = this._createKeyed(\"onStateChange\");\n  readonly isDirty = this._createKeyed(\"isDirty\");\n}\n\nclass AsyncValueCache<T> {\n  private _store: AsyncStore<T>;\n  private _pendingPromise: ReactPromise<T> | undefined;\n  private _fetcher: () => Promise<T>;\n  private readonly _rateLimitOptions: Omit<RateLimitOptions, \"batchCalls\">;\n  private _subscriptionsCount = 0;\n  private _unsubscribers: (() => void)[] = [];\n  private _mostRecentRefreshPromiseIndex = 0;\n\n  constructor(\n    fetcher: () => Promise<T>,\n    private readonly _options: {\n      onSubscribe?: (refresh: () => void) => (() => void),\n      rateLimiter?: Omit<RateLimitOptions, \"batchCalls\">,\n    } = {},\n  ) {\n    this._store = new AsyncStore();\n    this._rateLimitOptions = {\n      concurrency: 1,\n      throttleMs: 300,\n      ...filterUndefined(_options.rateLimiter ?? {}),\n    };\n\n\n    this._fetcher = rateLimited(fetcher, {\n      ...this._rateLimitOptions,\n      batchCalls: true,\n    });\n  }\n\n  isCacheAvailable(): boolean {\n    return this._store.isAvailable();\n  }\n\n  getIfCached() {\n    return this._store.get();\n  }\n\n  getOrWait(cacheStrategy: CacheStrategy): ReactPromise<T> {\n    const cached = this.getIfCached();\n    if (cacheStrategy === \"read-write\" && cached.status === \"ok\") {\n      return resolved(cached.data);\n    }\n\n    return this._refetch(cacheStrategy);\n  }\n\n  private _set(value: T): void {\n    this._store.set(value);\n  }\n\n  private _setAsync(value: Promise<T>): ReactPromise<void> {\n    if (this._subscriptionsCount === 0 && !isBrowserLike()) {\n      // if we're in a server-like environment, we'd rather cache less aggressively to avoid memory leaks.\n      // hence, if no one is listening to this cache, let's invalidate it\n      this._invalidateCacheSoon();\n    }\n    const promise = pending(value);\n    this._pendingPromise = promise;\n    return pending(this._store.setAsync(promise).then(() => undefined));\n  }\n\n  private _refetch(cacheStrategy: CacheStrategy): ReactPromise<T> {\n    if (cacheStrategy === \"read-write\" && this._pendingPromise) {\n      return this._pendingPromise;\n    }\n    const promise = pending(this._fetcher());\n    if (cacheStrategy === \"never\") {\n      return promise;\n    }\n    return pending(this._setAsync(promise).then(() => promise));\n  }\n\n  forceSetCachedValue(value: T): void {\n    this._set(value);\n  }\n\n  forceSetCachedValueAsync(value: Promise<T>): ReactPromise<void> {\n    return this._setAsync(value);\n  }\n\n  /**\n   * If anyone is listening to the cache, refreshes the value, and sets it without invalidating the cache.\n   */\n  async refresh(): Promise<void> {\n    // note that we do the extra check here to save a request if no one is listening to the cache anyway\n    if (this._subscriptionsCount > 0) {\n      await this.getOrWait(\"write-only\");\n    }\n  }\n\n  /**\n   * Invalidates the cache, marking it dirty (ie. it will be refreshed on the next read). If anyone is listening to the cache, it will refresh immediately.\n   */\n  async invalidate(): Promise<void> {\n    this._store.setUnavailable();\n    this._pendingPromise = undefined;\n    await this.refresh();\n  }\n\n  isDirty(): boolean {\n    return this._pendingPromise === undefined;\n  }\n\n  _invalidateCacheSoon(): void {\n    // wait a few seconds; we want to keep the cache up during this time\n    // else we do unnecessary requests if we unsubscribe and then subscribe again immediately\n    const currentRefreshPromiseIndex = ++this._mostRecentRefreshPromiseIndex;\n    runAsynchronously(async () => {\n      await wait(5000);\n      if (this._subscriptionsCount === 0 && currentRefreshPromiseIndex === this._mostRecentRefreshPromiseIndex) {\n        await this.invalidate();\n      }\n    });\n  }\n\n  onStateChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void } {\n    const storeObj = this._store.onChange(callback);\n\n    runAsynchronously(this.getOrWait(\"read-write\"));\n\n    if (this._subscriptionsCount++ === 0 && this._options.onSubscribe) {\n      const unsubscribe = this._options.onSubscribe(() => {\n        runAsynchronously(this.refresh());\n      });\n      this._unsubscribers.push(unsubscribe);\n    }\n\n    let hasUnsubscribed = false;\n    return {\n      unsubscribe: () => {\n        if (hasUnsubscribed) return;\n        hasUnsubscribed = true;\n        storeObj.unsubscribe();\n        if (--this._subscriptionsCount === 0) {\n          this._invalidateCacheSoon();\n\n          for (const unsubscribe of this._unsubscribers) {\n            unsubscribe();\n          }\n        }\n      },\n    };\n  }\n}\n"],"mappings":"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","names":[]}