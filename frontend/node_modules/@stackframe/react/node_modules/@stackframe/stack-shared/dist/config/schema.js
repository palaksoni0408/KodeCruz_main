"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/config/schema.ts
var schema_exports = {};
__export(schema_exports, {
  applyBranchDefaults: () => applyBranchDefaults,
  applyEnvironmentDefaults: () => applyEnvironmentDefaults,
  applyOrganizationDefaults: () => applyOrganizationDefaults,
  applyProjectDefaults: () => applyProjectDefaults,
  assertNoConfigOverrideErrors: () => assertNoConfigOverrideErrors,
  branchConfigSchema: () => branchConfigSchema,
  branchPaymentsSchema: () => branchPaymentsSchema,
  configLevels: () => configLevels,
  environmentConfigSchema: () => environmentConfigSchema,
  getConfigOverrideErrors: () => getConfigOverrideErrors,
  getIncompleteConfigWarnings: () => getIncompleteConfigWarnings,
  migrateConfigOverride: () => migrateConfigOverride,
  organizationConfigSchema: () => organizationConfigSchema,
  projectConfigSchema: () => projectConfigSchema,
  sanitizeBranchConfig: () => sanitizeBranchConfig,
  sanitizeEnvironmentConfig: () => sanitizeEnvironmentConfig,
  sanitizeOrganizationConfig: () => sanitizeOrganizationConfig,
  sanitizeProjectConfig: () => sanitizeProjectConfig
});
module.exports = __toCommonJS(schema_exports);
var yup = __toESM(require("yup"));
var import_apps_config = require("../apps/apps-config.js");
var import_emails = require("../helpers/emails.js");
var schemaFields = __toESM(require("../schema-fields.js"));
var import_schema_fields = require("../schema-fields.js");
var import_currency_constants = require("../utils/currency-constants.js");
var import_errors = require("../utils/errors.js");
var import_oauth = require("../utils/oauth.js");
var import_objects = require("../utils/objects.js");
var import_results = require("../utils/results.js");
var import_types = require("../utils/types.js");
var import_format = require("./format.js");
var configLevels = ["project", "branch", "environment", "organization"];
var permissionRegex = /^\$?[a-z0-9_:]+$/;
var customPermissionRegex = /^[a-z0-9_:]+$/;
function canNoLongerBeOverridden(schema, keys) {
  const notOmitted = schema.concat((0, import_schema_fields.yupObject)(
    Object.fromEntries(keys.map((key) => [key, schema.getNested(key).meta({ stackConfigCanNoLongerBeOverridden: true })]))
  ));
  return notOmitted;
}
var projectConfigSchema = (0, import_schema_fields.yupObject)({
  sourceOfTruth: (0, import_schema_fields.yupUnion)(
    (0, import_schema_fields.yupObject)({
      type: (0, import_schema_fields.yupString)().oneOf(["hosted"]).defined()
    }),
    (0, import_schema_fields.yupObject)({
      type: (0, import_schema_fields.yupString)().oneOf(["neon"]).defined(),
      connectionStrings: (0, import_schema_fields.yupRecord)(
        (0, import_schema_fields.userSpecifiedIdSchema)("connectionStringId").defined(),
        (0, import_schema_fields.yupString)().defined()
      ).defined()
    }),
    (0, import_schema_fields.yupObject)({
      type: (0, import_schema_fields.yupString)().oneOf(["postgres"]).defined(),
      connectionString: (0, import_schema_fields.yupString)().defined()
    })
  )
});
var branchRbacDefaultPermissions = (0, import_schema_fields.yupRecord)(
  (0, import_schema_fields.yupString)().matches(permissionRegex),
  (0, import_schema_fields.yupBoolean)().isTrue().optional()
);
var branchRbacSchema = (0, import_schema_fields.yupObject)({
  permissions: (0, import_schema_fields.yupRecord)(
    (0, import_schema_fields.yupString)().matches(customPermissionRegex),
    (0, import_schema_fields.yupObject)({
      description: (0, import_schema_fields.yupString)().optional(),
      scope: (0, import_schema_fields.yupString)().oneOf(["team", "project"]).optional(),
      containedPermissionIds: (0, import_schema_fields.yupRecord)(
        (0, import_schema_fields.yupString)().matches(permissionRegex),
        (0, import_schema_fields.yupBoolean)().isTrue().optional()
      ).optional()
    }).optional()
  ),
  defaultPermissions: (0, import_schema_fields.yupObject)({
    teamCreator: branchRbacDefaultPermissions,
    teamMember: branchRbacDefaultPermissions,
    signUp: branchRbacDefaultPermissions
  })
});
var branchApiKeysSchema = (0, import_schema_fields.yupObject)({
  enabled: (0, import_schema_fields.yupObject)({
    team: (0, import_schema_fields.yupBoolean)(),
    user: (0, import_schema_fields.yupBoolean)()
  })
});
var appIds = Object.keys(import_apps_config.ALL_APPS);
var branchAppsSchema = (0, import_schema_fields.yupObject)({
  installed: (0, import_schema_fields.yupRecord)(
    (0, import_schema_fields.yupString)().oneOf(appIds),
    (0, import_schema_fields.yupObject)({
      enabled: (0, import_schema_fields.yupBoolean)()
    })
  ).test(
    "authentication-and-emails-enabled",
    "authentication and emails must be installed and enabled",
    function(value) {
      const hasAuthentication = value["authentication"].enabled === true;
      const hasEmails = value["emails"].enabled === true;
      if (!hasAuthentication || !hasEmails) {
        return this.createError({
          message: "authentication and emails must be installed and enabled",
          path: this.path
        });
      }
      return true;
    }
  )
});
var branchAuthSchema = (0, import_schema_fields.yupObject)({
  allowSignUp: (0, import_schema_fields.yupBoolean)(),
  password: (0, import_schema_fields.yupObject)({
    allowSignIn: (0, import_schema_fields.yupBoolean)()
  }),
  otp: (0, import_schema_fields.yupObject)({
    allowSignIn: (0, import_schema_fields.yupBoolean)()
  }),
  passkey: (0, import_schema_fields.yupObject)({
    allowSignIn: (0, import_schema_fields.yupBoolean)()
  }),
  oauth: (0, import_schema_fields.yupObject)({
    accountMergeStrategy: (0, import_schema_fields.yupString)().oneOf(["link_method", "raise_error", "allow_duplicates"]).optional(),
    providers: (0, import_schema_fields.yupRecord)(
      (0, import_schema_fields.yupString)().matches(permissionRegex),
      (0, import_schema_fields.yupObject)({
        type: (0, import_schema_fields.yupString)().oneOf(import_oauth.allProviders).optional(),
        allowSignIn: (0, import_schema_fields.yupBoolean)(),
        allowConnectedAccounts: (0, import_schema_fields.yupBoolean)()
      })
    )
  })
});
var branchPaymentsSchema = (0, import_schema_fields.yupObject)({
  autoPay: (0, import_schema_fields.yupObject)({
    interval: schemaFields.dayIntervalSchema
  }).optional(),
  testMode: (0, import_schema_fields.yupBoolean)(),
  catalogs: (0, import_schema_fields.yupRecord)(
    (0, import_schema_fields.userSpecifiedIdSchema)("catalogId"),
    (0, import_schema_fields.yupObject)({
      displayName: (0, import_schema_fields.yupString)().optional()
    })
  ).meta({ openapiField: { description: "The catalogs that products can be in. All products in a catalog (besides add-ons) are mutually exclusive.", exampleValue: { "catalog-id": { displayName: "My Catalog" } } } }),
  products: (0, import_schema_fields.yupRecord)(
    (0, import_schema_fields.userSpecifiedIdSchema)("productId"),
    import_schema_fields.productSchema
  ),
  items: (0, import_schema_fields.yupRecord)(
    (0, import_schema_fields.userSpecifiedIdSchema)("itemId"),
    (0, import_schema_fields.yupObject)({
      displayName: (0, import_schema_fields.yupString)().optional(),
      customerType: schemaFields.customerTypeSchema
    })
  )
});
var branchDomain = (0, import_schema_fields.yupObject)({
  allowLocalhost: (0, import_schema_fields.yupBoolean)()
});
var branchConfigSchema = canNoLongerBeOverridden(projectConfigSchema, ["sourceOfTruth"]).concat((0, import_schema_fields.yupObject)({
  rbac: branchRbacSchema,
  teams: (0, import_schema_fields.yupObject)({
    createPersonalTeamOnSignUp: (0, import_schema_fields.yupBoolean)(),
    allowClientTeamCreation: (0, import_schema_fields.yupBoolean)()
  }),
  users: (0, import_schema_fields.yupObject)({
    allowClientUserDeletion: (0, import_schema_fields.yupBoolean)()
  }),
  apiKeys: branchApiKeysSchema,
  apps: branchAppsSchema,
  domains: branchDomain,
  auth: branchAuthSchema,
  emails: (0, import_schema_fields.yupObject)({
    selectedThemeId: schemaFields.emailThemeSchema,
    themes: schemaFields.emailThemeListSchema,
    templates: schemaFields.emailTemplateListSchema
  }),
  payments: branchPaymentsSchema,
  dataVault: (0, import_schema_fields.yupObject)({
    stores: (0, import_schema_fields.yupRecord)(
      (0, import_schema_fields.userSpecifiedIdSchema)("storeId"),
      (0, import_schema_fields.yupObject)({
        displayName: (0, import_schema_fields.yupString)()
      })
    )
  })
}));
var environmentConfigSchema = branchConfigSchema.concat((0, import_schema_fields.yupObject)({
  auth: branchConfigSchema.getNested("auth").concat((0, import_schema_fields.yupObject)({
    oauth: branchConfigSchema.getNested("auth").getNested("oauth").concat((0, import_schema_fields.yupObject)({
      providers: (0, import_schema_fields.yupRecord)(
        (0, import_schema_fields.yupString)().matches(permissionRegex),
        (0, import_schema_fields.yupObject)({
          type: (0, import_schema_fields.yupString)().oneOf(import_oauth.allProviders).optional(),
          isShared: (0, import_schema_fields.yupBoolean)(),
          clientId: schemaFields.oauthClientIdSchema.optional(),
          clientSecret: schemaFields.oauthClientSecretSchema.optional(),
          facebookConfigId: schemaFields.oauthFacebookConfigIdSchema.optional(),
          microsoftTenantId: schemaFields.oauthMicrosoftTenantIdSchema.optional(),
          allowSignIn: (0, import_schema_fields.yupBoolean)().optional(),
          allowConnectedAccounts: (0, import_schema_fields.yupBoolean)().optional()
        })
      )
    }))
  })),
  emails: branchConfigSchema.getNested("emails").concat((0, import_schema_fields.yupObject)({
    server: (0, import_schema_fields.yupObject)({
      isShared: (0, import_schema_fields.yupBoolean)(),
      provider: (0, import_schema_fields.yupString)().oneOf(["resend", "smtp"]).optional(),
      host: schemaFields.emailHostSchema.optional().nonEmpty(),
      port: schemaFields.emailPortSchema.optional(),
      username: schemaFields.emailUsernameSchema.optional().nonEmpty(),
      password: schemaFields.emailPasswordSchema.optional().nonEmpty(),
      senderName: schemaFields.emailSenderNameSchema.optional().nonEmpty(),
      senderEmail: schemaFields.emailSenderEmailSchema.optional().nonEmpty()
    })
  })),
  domains: branchConfigSchema.getNested("domains").concat((0, import_schema_fields.yupObject)({
    trustedDomains: (0, import_schema_fields.yupRecord)(
      (0, import_schema_fields.userSpecifiedIdSchema)("trustedDomainId"),
      (0, import_schema_fields.yupObject)({
        baseUrl: schemaFields.wildcardUrlSchema.max(300),
        // TODO: replace with wildcardProtocolAndDomainSchema (this will require a migration as some configs have domains that are not valid wildcard protocol and domain patterns)
        handlerPath: schemaFields.handlerPathSchema.max(300)
      })
    )
  }))
}));
var organizationConfigSchema = environmentConfigSchema.concat((0, import_schema_fields.yupObject)({}));
function migrateConfigOverride(type, oldUnmigratedConfigOverride) {
  const isBranchOrHigher = ["branch", "environment", "organization"].includes(type);
  const isEnvironmentOrHigher = ["environment", "organization"].includes(type);
  let res = oldUnmigratedConfigOverride;
  if (isBranchOrHigher) {
    res = renameProperty(res, "emails.theme", "selectedThemeId");
  }
  if (isEnvironmentOrHigher) {
    res = mapProperty(res, (p) => p.join(".") === "domains.trustedDomains", (value) => {
      if (Array.isArray(value)) {
        return (0, import_objects.typedFromEntries)(value.map((v, i) => [`${i}`, v]));
      }
      return value;
    });
  }
  if (isBranchOrHigher) {
    res = removeProperty(res, (p) => p.join(".") === "emails.themeList");
    res = removeProperty(res, (p) => p.join(".") === "emails.templateList");
  }
  if (type === "environment") {
    res = removeProperty(res, (p) => p.join(".") === "sourceOfTruth");
  }
  if (type === "environment") {
    res = removeProperty(res, (p) => p.join(".") === "payments.stripeAccountId");
    res = removeProperty(res, (p) => p.join(".") === "payments.stripeAccountSetupComplete");
  }
  if (isBranchOrHigher) {
    res = removeProperty(res, (p) => p.length === 4 && p[0] === "payments" && p[1] === "items" && p[3] === "default");
  }
  if (isBranchOrHigher) {
    res = renameProperty(res, "payments.offers", "products");
  }
  if (isBranchOrHigher) {
    res = renameProperty(res, "payments.groups", "catalogs");
  }
  if (isBranchOrHigher) {
    res = renameProperty(res, (p) => p.length === 4 && p[0] === "payments" && p[1] === "products" && p[3] === "groupId", (p) => "catalogId");
  }
  if (isBranchOrHigher) {
    res = removeProperty(res, (p) => p[0] === "workflows");
    res = removeProperty(res, (p) => p[0] === "apps" && p[1] === "installed" && p[2] === "workflows");
  }
  return res;
}
function removeProperty(obj, pathCond) {
  return mapProperty(obj, pathCond, () => void 0);
}
function mapProperty(obj, pathCond, mapper) {
  const res = Array.isArray(obj) ? [] : {};
  for (const [key, value] of (0, import_objects.typedEntries)(obj)) {
    const path = key.split(".");
    if (pathCond(path)) {
      const newValue = mapper(value);
      if (newValue !== void 0) {
        (0, import_objects.set)(res, key, newValue);
      } else {
      }
    } else if ((0, import_objects.isObjectLike)(value)) {
      (0, import_objects.set)(res, key, mapProperty(value, (p) => pathCond([...path, ...p]), mapper));
    } else {
      (0, import_objects.set)(res, key, value);
    }
  }
  return res;
}
function renameProperty(obj, oldPath, newName) {
  const pathCond = typeof oldPath === "function" ? oldPath : (p) => p.join(".") === oldPath;
  const pathMapper = typeof newName === "function" ? newName : (p) => newName;
  const res = Array.isArray(obj) ? [] : {};
  for (const [key, originalValue] of (0, import_objects.typedEntries)(obj)) {
    const path = key.split(".");
    for (let i = 0; i < path.length; i++) {
      const pathPrefix = path.slice(0, i + 1);
      if (pathCond(pathPrefix)) {
        const name = pathMapper(pathPrefix);
        if (name.includes(".")) throw new import_errors.StackAssertionError(`newName must not contain a dot. Provided: ${name}`);
        path[i] = name;
      }
    }
    const value = (0, import_objects.isObjectLike)(originalValue) ? renameProperty(originalValue, (p) => pathCond([...path, ...p]), (p) => pathMapper([...path, ...p])) : originalValue;
    (0, import_objects.set)(res, path.join("."), value);
  }
  return res;
}
var projectConfigDefaults = {
  sourceOfTruth: {
    type: "hosted",
    connectionStrings: void 0,
    connectionString: void 0
  }
};
var branchConfigDefaults = {};
var environmentConfigDefaults = {};
var organizationConfigDefaults = {
  rbac: {
    permissions: (key) => ({
      containedPermissionIds: (key2) => void 0,
      description: void 0,
      scope: void 0
    }),
    defaultPermissions: {
      teamCreator: (key) => void 0,
      teamMember: (key) => void 0,
      signUp: (key) => void 0
    }
  },
  apiKeys: {
    enabled: {
      team: false,
      user: false
    }
  },
  apps: {
    installed: (0, import_objects.typedFromEntries)(appIds.map((appId) => [appId, { enabled: false }]))
  },
  teams: {
    createPersonalTeamOnSignUp: false,
    allowClientTeamCreation: false
  },
  users: {
    allowClientUserDeletion: false
  },
  domains: {
    allowLocalhost: false,
    trustedDomains: (key) => ({
      baseUrl: void 0,
      handlerPath: "/handler"
    })
  },
  auth: {
    allowSignUp: true,
    password: {
      allowSignIn: false
    },
    otp: {
      allowSignIn: false
    },
    passkey: {
      allowSignIn: false
    },
    oauth: {
      accountMergeStrategy: "link_method",
      providers: (key) => ({
        type: void 0,
        isShared: true,
        allowSignIn: false,
        allowConnectedAccounts: false,
        clientId: void 0,
        clientSecret: void 0,
        facebookConfigId: void 0,
        microsoftTenantId: void 0
      })
    }
  },
  emails: {
    server: {
      isShared: true,
      provider: "smtp",
      host: void 0,
      port: void 0,
      username: void 0,
      password: void 0,
      senderName: void 0,
      senderEmail: void 0
    },
    selectedThemeId: import_emails.DEFAULT_EMAIL_THEME_ID,
    themes: (0, import_objects.typedAssign)((key) => ({
      displayName: "Unnamed Theme",
      tsxSource: "Error: Theme config is missing TypeScript source code."
    }), import_emails.DEFAULT_EMAIL_THEMES),
    templates: (0, import_objects.typedAssign)((key) => ({
      displayName: "Unnamed Template",
      tsxSource: "Error: Template config is missing TypeScript source code.",
      themeId: void 0
    }), import_emails.DEFAULT_EMAIL_TEMPLATES)
  },
  payments: {
    testMode: true,
    autoPay: void 0,
    catalogs: (key) => ({
      displayName: void 0
    }),
    products: (key) => ({
      displayName: key,
      catalogId: void 0,
      customerType: "user",
      freeTrial: void 0,
      serverOnly: false,
      stackable: void 0,
      isAddOnTo: false,
      prices: (key2) => ({
        ...(0, import_objects.typedFromEntries)(import_currency_constants.SUPPORTED_CURRENCIES.map((currency) => [currency.code, void 0])),
        interval: void 0,
        serverOnly: false,
        freeTrial: void 0
      }),
      includedItems: (key2) => ({
        quantity: 0,
        repeat: "never",
        expires: "when-repeated"
      })
    }),
    items: (key) => ({
      displayName: key,
      customerType: "user"
    })
  },
  dataVault: {
    stores: (key) => ({
      displayName: "Unnamed Vault"
    })
  }
};
(0, import_types.typeAssertIs)()();
(0, import_types.typeAssertIs)()();
function deepReplaceFunctionsWithObjects(obj) {
  return (0, import_objects.mapValues)({ ...obj }, (v) => (0, import_objects.isObjectLike)(v) ? deepReplaceFunctionsWithObjects(v) : v);
}
function applyDefaults(defaults, config) {
  const res = deepReplaceFunctionsWithObjects(defaults);
  outer: for (const [key, mergeValue] of Object.entries(config)) {
    if (mergeValue == null) continue;
    if (!(0, import_objects.isObjectLike)(mergeValue)) {
      (0, import_objects.set)(res, key, mergeValue);
    } else {
      const keyParts = key.split(".");
      let baseValue = defaults;
      for (const [index, part] of keyParts.entries()) {
        baseValue = (0, import_objects.has)(baseValue, part) ? (0, import_objects.get)(baseValue, part) : typeof baseValue === "function" ? baseValue(part) : void 0;
        if (baseValue === void 0 || !(0, import_objects.isObjectLike)(baseValue)) {
          (0, import_objects.set)(res, key, mergeValue);
          continue outer;
        }
      }
      (0, import_objects.set)(res, key, applyDefaults(baseValue, mergeValue));
    }
  }
  return res;
}
function applyProjectDefaults(config) {
  return applyDefaults(projectConfigDefaults, config);
}
function applyBranchDefaults(config) {
  return applyDefaults(
    branchConfigDefaults,
    applyDefaults(
      projectConfigDefaults,
      config
    )
  );
}
function applyEnvironmentDefaults(config) {
  return applyDefaults(
    environmentConfigDefaults,
    applyDefaults(
      branchConfigDefaults,
      applyDefaults(
        projectConfigDefaults,
        config
      )
    )
  );
}
function applyOrganizationDefaults(config) {
  return applyDefaults(
    organizationConfigDefaults,
    applyDefaults(
      environmentConfigDefaults,
      applyDefaults(
        branchConfigDefaults,
        applyDefaults(
          projectConfigDefaults,
          config
        )
      )
    )
  );
}
async function sanitizeProjectConfig(config) {
  (0, import_format.assertNormalized)(config);
  const oldSourceOfTruth = config.sourceOfTruth;
  const sourceOfTruth = oldSourceOfTruth.type === "neon" && typeof oldSourceOfTruth.connectionStrings === "object" ? {
    type: "neon",
    connectionStrings: { ...(0, import_objects.filterUndefined)(oldSourceOfTruth.connectionStrings) }
  } : oldSourceOfTruth.type === "postgres" && typeof oldSourceOfTruth.connectionString === "string" ? {
    type: "postgres",
    connectionString: oldSourceOfTruth.connectionString
  } : {
    type: "hosted"
  };
  return {
    ...config,
    sourceOfTruth
  };
}
async function sanitizeBranchConfig(config) {
  (0, import_format.assertNormalized)(config);
  const prepared = await sanitizeProjectConfig(config);
  return {
    ...prepared
  };
}
async function sanitizeEnvironmentConfig(config) {
  (0, import_format.assertNormalized)(config);
  const prepared = await sanitizeBranchConfig(config);
  return {
    ...prepared
  };
}
async function sanitizeOrganizationConfig(config) {
  (0, import_format.assertNormalized)(config);
  const prepared = await sanitizeEnvironmentConfig(config);
  const themes = {
    ...import_emails.DEFAULT_EMAIL_THEMES,
    ...prepared.emails.themes
  };
  const templates = {
    ...import_emails.DEFAULT_EMAIL_TEMPLATES,
    ...config.emails.server.isShared ? {} : prepared.emails.templates
  };
  const products = (0, import_objects.typedFromEntries)((0, import_objects.typedEntries)(prepared.payments.products).map(([key, product]) => {
    const isAddOnTo = product.isAddOnTo === false ? false : (0, import_objects.typedFromEntries)(Object.keys(product.isAddOnTo).map((key2) => [key2, true]));
    const prices = product.prices === "include-by-default" ? "include-by-default" : (0, import_objects.typedFromEntries)((0, import_objects.typedEntries)(product.prices).map(([key2, value]) => {
      const data = { serverOnly: false, ...value ?? {} };
      return [key2, data];
    }));
    return [key, {
      ...product,
      isAddOnTo,
      prices
    }];
  }));
  const appSortIndices = new Map(Object.keys(import_apps_config.ALL_APPS).map((appId, index) => [appId, index]));
  return {
    ...prepared,
    emails: {
      ...prepared.emails,
      selectedThemeId: (0, import_objects.has)(themes, prepared.emails.selectedThemeId) ? prepared.emails.selectedThemeId : import_emails.DEFAULT_EMAIL_THEME_ID,
      themes,
      templates
    },
    payments: {
      ...prepared.payments,
      products
    },
    apps: {
      installed: (0, import_objects.typedFromEntries)(
        (0, import_objects.typedEntries)(prepared.apps.installed).sort(([a], [b]) => appSortIndices.get(a) - appSortIndices.get(b))
      )
    }
  };
}
async function getConfigOverrideErrors(schema, configOverride, options = {}) {
  if (typeof configOverride !== "object" || configOverride === null) {
    return import_results.Result.error("Config override must be a non-null object.");
  }
  if (Object.getPrototypeOf(configOverride) !== Object.getPrototypeOf({})) {
    return import_results.Result.error("Config override must be plain old JavaScript object.");
  }
  const reason = (0, import_format.getInvalidConfigReason)(configOverride, { configName: "override" });
  if (reason) return import_results.Result.error("Invalid config format: " + reason);
  const getSubSchema = (schema2, key) => {
    const keyParts = key.split(".");
    if (!schema2.hasNested(keyParts[0])) {
      return void 0;
    }
    const nestedSchema = schema2.getNested(keyParts[0]);
    if (nestedSchema.meta()?.stackConfigCanNoLongerBeOverridden && !options.allowPropertiesThatCanNoLongerBeOverridden) {
      return void 0;
    }
    if (keyParts.length === 1) {
      return nestedSchema;
    } else {
      return getSubSchema(nestedSchema, keyParts.slice(1).join("."));
    }
  };
  const getRestrictedSchemaBase = (path, schema2) => {
    const schemaInfo = schema2.meta()?.stackSchemaInfo;
    switch (schemaInfo?.type) {
      case "string": {
        const stringSchema = schema2;
        const description = stringSchema.describe();
        let res = (0, import_schema_fields.yupString)();
        if (description.tests.some((t) => t.name === "uuid")) {
          res = res.uuid();
        }
        return res;
      }
      case "number": {
        return (0, import_schema_fields.yupNumber)();
      }
      case "boolean": {
        return (0, import_schema_fields.yupBoolean)();
      }
      case "date": {
        return (0, import_schema_fields.yupDate)();
      }
      case "mixed": {
        return (0, import_schema_fields.yupMixed)();
      }
      case "array": {
        throw new import_errors.StackAssertionError(`Arrays are not supported in config JSON files (besides tuples). Use a record instead.`, { schemaInfo, schema: schema2 });
      }
      case "tuple": {
        return (0, import_schema_fields.yupTuple)(schemaInfo.items.map((s, index) => getRestrictedSchema(path + `[${index}]`, s)));
      }
      case "union": {
        const schemas = schemaInfo.items;
        const nonObjectSchemas = [...schemas.entries()].filter(([index, s]) => s.meta()?.stackSchemaInfo?.type !== "object");
        const objectSchemas = schemas.filter((s) => s.meta()?.stackSchemaInfo?.type === "object");
        const allObjectSchemaKeys = [...new Set(objectSchemas.flatMap((s) => Object.keys(s.fields)))];
        const mergedObjectSchema = (0, import_schema_fields.yupObject)(
          Object.fromEntries(
            allObjectSchemaKeys.map((key) => [key, (0, import_schema_fields.yupUnion)(
              ...objectSchemas.flatMap((s, index) => s.hasNested(key) ? [s.getNested(key)] : [])
            )])
          )
        );
        return (0, import_schema_fields.yupUnion)(
          ...nonObjectSchemas.map(([index, s]) => getRestrictedSchema(path + `|variant-${index}|`, s)),
          ...objectSchemas.length > 0 ? [getRestrictedSchema(path + (nonObjectSchemas.length > 0 ? `|variant|` : ""), mergedObjectSchema)] : []
        );
      }
      case "record": {
        return (0, import_schema_fields.yupRecord)(getRestrictedSchema(path + ".key", schemaInfo.keySchema), getRestrictedSchema(path + ".value", schemaInfo.valueSchema));
      }
      case "object": {
        const objectSchema = schema2;
        return (0, import_schema_fields.yupObject)(
          Object.fromEntries(
            Object.entries(objectSchema.fields).map(([key, value]) => [key, getRestrictedSchema(path + "." + key, value)])
          )
        );
      }
      case "never": {
        return (0, import_schema_fields.yupNever)();
      }
      default: {
        throw new import_errors.StackAssertionError(`Unknown schema info at path ${path}: ${JSON.stringify(schemaInfo)}`, { schemaInfo, schema: schema2 });
      }
    }
  };
  const getRestrictedSchema = (path, schema2) => {
    let restricted = getRestrictedSchemaBase(path, schema2);
    restricted = restricted.nullable();
    const description = schema2.describe();
    if (description.oneOf.length > 0) {
      restricted = restricted.oneOf(description.oneOf);
    }
    if (description.notOneOf.length > 0) {
      restricted = restricted.notOneOf(description.notOneOf);
    }
    return restricted;
  };
  for (const [key, value] of Object.entries(configOverride)) {
    if (value === void 0) continue;
    const subSchema = getSubSchema(schema, key);
    if (!subSchema) {
      const keySplit = key.split(".");
      for (let i = 0; i < keySplit.length; i++) {
        const prefix = keySplit.slice(0, i + 1).join(".");
        const subSchema2 = getSubSchema(schema, prefix);
        if (!subSchema2) {
          return import_results.Result.error(`The key ${JSON.stringify(key)} is not valid (nested object not found in schema: ${JSON.stringify(prefix)}).`);
        }
      }
      throw new import_errors.StackAssertionError("Something weird happened? Sub-schema for key is invalid but no prefix is invalid??", { key, subSchema });
    }
    let restrictedSchema = getRestrictedSchema(key, subSchema);
    try {
      await restrictedSchema.validate(value, {
        strict: true,
        ...{
          // Although `path` is not part of the yup types, it is actually recognized and does the correct thing
          path: key
        },
        context: {
          noUnknownPathPrefixes: [""]
        }
      });
    } catch (error) {
      if (error instanceof yup.ValidationError) {
        return import_results.Result.error(error.message);
      }
      throw error;
    }
  }
  return import_results.Result.ok(null);
}
async function assertNoConfigOverrideErrors(schema, config, options = {}) {
  const res = await getConfigOverrideErrors(schema, config, options);
  if (res.status === "error") throw new import_errors.StackAssertionError(`Config override is invalid \u2014 at a place where it should have already been validated! ${res.error}`, { options, config });
}
(0, import_types.typeAssertIs)()();
(0, import_types.typeAssertExtends)()();
(0, import_types.typeAssertExtends)()();
async function getIncompleteConfigWarnings(schema, incompleteConfig) {
  await assertNoConfigOverrideErrors(schema, incompleteConfig, { allowPropertiesThatCanNoLongerBeOverridden: true });
  let normalized;
  try {
    normalized = (0, import_format.normalize)(incompleteConfig, { onDotIntoNull: "empty-object" });
  } catch (error) {
    if (error instanceof import_format.NormalizationError) {
      return import_results.Result.error(`Config is not normalizable. ` + error.message);
    }
    throw error;
  }
  try {
    await schema.validate(normalized, {
      strict: true,
      context: {
        noUnknownPathPrefixes: [""]
      }
    });
    return import_results.Result.ok(null);
  } catch (error) {
    if (error instanceof yup.ValidationError) {
      return import_results.Result.error(error.message);
    }
    throw error;
  }
}
(0, import_types.typeAssertExtends)()();
(0, import_types.typeAssertExtends)()();
(0, import_types.typeAssertExtends)()();
(0, import_types.typeAssertExtends)()();
(0, import_types.typeAssert)()();
(0, import_types.typeAssert)()();
(0, import_types.typeAssertExtends)()();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  applyBranchDefaults,
  applyEnvironmentDefaults,
  applyOrganizationDefaults,
  applyProjectDefaults,
  assertNoConfigOverrideErrors,
  branchConfigSchema,
  branchPaymentsSchema,
  configLevels,
  environmentConfigSchema,
  getConfigOverrideErrors,
  getIncompleteConfigWarnings,
  migrateConfigOverride,
  organizationConfigSchema,
  projectConfigSchema,
  sanitizeBranchConfig,
  sanitizeEnvironmentConfig,
  sanitizeOrganizationConfig,
  sanitizeProjectConfig
});
//# sourceMappingURL=schema.js.map