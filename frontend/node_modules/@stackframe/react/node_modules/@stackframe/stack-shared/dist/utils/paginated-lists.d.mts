type QueryOptions<Type extends 'next' | 'prev', Cursor, Filter, OrderBy> = {
    filter: Filter;
    orderBy: OrderBy;
    limit: number;
    /**
     * Whether the limit should be treated as an exact value, or an approximate value.
     *
     * If set to 'exact', less items will only be returned if the list item is the first or last item.
     *
     * If set to 'at-least' or 'approximate', the implementation may decide to return more items than the limit requested if doing so comes at no (or negligible) extra cost.
     *
     * If set to 'at-most' or 'approximate', the implementation may decide to return less items than the limit requested if requesting more items would come at a non-negligible extra cost. In this case, if limit > 0, the implementation must still make progress towards the end of the list and the returned cursor must be different from the one passed in.
     *
     * Defaults to 'exact'.
     */
    limitPrecision: 'exact' | 'at-least' | 'at-most' | 'approximate';
} & ([Type] extends [never] ? unknown : [Type] extends ['next'] ? {
    after: Cursor;
} : [Type] extends ['prev'] ? {
    before: Cursor;
} : {
    cursor: Cursor;
});
type ImplQueryOptions<Type extends 'next' | 'prev', Cursor, Filter, OrderBy> = QueryOptions<Type, Cursor, Filter, OrderBy> & {
    limitPrecision: 'approximate';
};
type QueryResult<Item, Cursor> = {
    items: {
        item: Item;
        itemCursor: Cursor;
    }[];
    isFirst: boolean;
    isLast: boolean;
    cursor: Cursor;
};
type ImplQueryResult<Item, Cursor> = {
    items: {
        item: Item;
        itemCursor: Cursor;
    }[];
    isFirst: boolean;
    isLast: boolean;
    cursor: Cursor;
};
declare abstract class PaginatedList<Item, Cursor extends string, Filter extends unknown, OrderBy extends unknown> {
    protected abstract _getFirstCursor(): Cursor;
    protected abstract _getLastCursor(): Cursor;
    protected abstract _compare(orderBy: OrderBy, a: Item, b: Item): number;
    protected abstract _nextOrPrev(type: 'next' | 'prev', options: ImplQueryOptions<'next' | 'prev', Cursor, Filter, OrderBy>): Promise<ImplQueryResult<Item, Cursor>>;
    getFirstCursor(): Cursor;
    getLastCursor(): Cursor;
    compare(orderBy: OrderBy, a: Item, b: Item): number;
    nextOrPrev(type: 'next' | 'prev', options: QueryOptions<'next' | 'prev', Cursor, Filter, OrderBy>): Promise<QueryResult<Item, Cursor>>;
    next({ after, ...rest }: QueryOptions<'next', Cursor, Filter, OrderBy>): Promise<QueryResult<Item, Cursor>>;
    prev({ before, ...rest }: QueryOptions<'prev', Cursor, Filter, OrderBy>): Promise<QueryResult<Item, Cursor>>;
    flatMap<Item2, Cursor2 extends string, Filter2 extends unknown, OrderBy2 extends unknown>(options: {
        itemMapper: (itemEntry: {
            item: Item;
            itemCursor: Cursor;
        }, filter: Filter2, orderBy: OrderBy2) => {
            item: Item2;
            itemCursor: Cursor2;
        }[];
        compare: (orderBy: OrderBy2, a: Item2, b: Item2) => number;
        newCursorFromOldCursor: (cursor: Cursor) => Cursor2;
        oldCursorFromNewCursor: (cursor: Cursor2) => Cursor;
        oldFilterFromNewFilter: (filter: Filter2) => Filter;
        oldOrderByFromNewOrderBy: (orderBy: OrderBy2) => OrderBy;
        estimateItemsToFetch: (options: {
            filter: Filter2;
            orderBy: OrderBy2;
            limit: number;
        }) => number;
    }): PaginatedList<Item2, Cursor2, Filter2, OrderBy2>;
    map<Item2, Filter2 extends unknown, OrderBy2 extends unknown>(options: {
        itemMapper: (item: Item) => Item2;
        oldItemFromNewItem: (item: Item2) => Item;
        oldFilterFromNewFilter: (filter: Filter2) => Filter;
        oldOrderByFromNewOrderBy: (orderBy: OrderBy2) => OrderBy;
    }): PaginatedList<Item2, Cursor, Filter2, OrderBy2>;
    filter<Filter2 extends unknown>(options: {
        filter: (item: Item, filter: Filter2) => boolean;
        oldFilterFromNewFilter: (filter: Filter2) => Filter;
        estimateItemsToFetch: (options: {
            filter: Filter2;
            orderBy: OrderBy;
            limit: number;
        }) => number;
    }): PaginatedList<Item, Cursor, Filter2, OrderBy>;
    addFilter<AddedFilter extends unknown>(options: {
        filter: (item: Item, filter: Filter & AddedFilter) => boolean;
        estimateItemsToFetch: (options: {
            filter: Filter & AddedFilter;
            orderBy: OrderBy;
            limit: number;
        }) => number;
    }): PaginatedList<Item, Cursor, Filter & AddedFilter, OrderBy>;
    static merge<Item, Filter extends unknown, OrderBy extends unknown>(...lists: PaginatedList<Item, any, Filter, OrderBy>[]): PaginatedList<Item, string, Filter, OrderBy>;
    static empty(): {
        _getFirstCursor(): "first";
        _getLastCursor(): "last";
        _compare(orderBy: any, a: any, b: any): number;
        _nextOrPrev(type: 'next' | 'prev', options: ImplQueryOptions<'next' | 'prev', string, any, any>): Promise<{
            items: never[];
            isFirst: boolean;
            isLast: boolean;
            cursor: "first";
        }>;
        getFirstCursor(): "first" | "last";
        getLastCursor(): "first" | "last";
        compare(orderBy: any, a: never, b: never): number;
        nextOrPrev(type: "next" | "prev", options: QueryOptions<"next" | "prev", "first" | "last", any, any>): Promise<QueryResult<never, "first" | "last">>;
        next({ after, ...rest }: QueryOptions<"next", "first" | "last", any, any>): Promise<QueryResult<never, "first" | "last">>;
        prev({ before, ...rest }: QueryOptions<"prev", "first" | "last", any, any>): Promise<QueryResult<never, "first" | "last">>;
        flatMap<Item2, Cursor2 extends string, Filter2 extends unknown, OrderBy2 extends unknown>(options: {
            itemMapper: (itemEntry: {
                item: never;
                itemCursor: "first" | "last";
            }, filter: Filter2, orderBy: OrderBy2) => {
                item: Item2;
                itemCursor: Cursor2;
            }[];
            compare: (orderBy: OrderBy2, a: Item2, b: Item2) => number;
            newCursorFromOldCursor: (cursor: "first" | "last") => Cursor2;
            oldCursorFromNewCursor: (cursor: Cursor2) => "first" | "last";
            oldFilterFromNewFilter: (filter: Filter2) => any;
            oldOrderByFromNewOrderBy: (orderBy: OrderBy2) => any;
            estimateItemsToFetch: (options: {
                filter: Filter2;
                orderBy: OrderBy2;
                limit: number;
            }) => number;
        }): PaginatedList<Item2, Cursor2, Filter2, OrderBy2>;
        map<Item2_1, Filter2_1 extends unknown, OrderBy2_1 extends unknown>(options: {
            itemMapper: (item: never) => Item2_1;
            oldItemFromNewItem: (item: Item2_1) => never;
            oldFilterFromNewFilter: (filter: Filter2_1) => any;
            oldOrderByFromNewOrderBy: (orderBy: OrderBy2_1) => any;
        }): PaginatedList<Item2_1, "first" | "last", Filter2_1, OrderBy2_1>;
        filter<Filter2_2 extends unknown>(options: {
            filter: (item: never, filter: Filter2_2) => boolean;
            oldFilterFromNewFilter: (filter: Filter2_2) => any;
            estimateItemsToFetch: (options: {
                filter: Filter2_2;
                orderBy: any;
                limit: number;
            }) => number;
        }): PaginatedList<never, "first" | "last", Filter2_2, any>;
        addFilter<AddedFilter extends unknown>(options: {
            filter: (item: never, filter: any) => boolean;
            estimateItemsToFetch: (options: {
                filter: any;
                orderBy: any;
                limit: number;
            }) => number;
        }): PaginatedList<never, "first" | "last", any, any>;
    };
}
declare class ArrayPaginatedList<Item> extends PaginatedList<Item, `${number}`, (item: Item) => boolean, (a: Item, b: Item) => number> {
    private readonly array;
    constructor(array: Item[]);
    _getFirstCursor(): "0";
    _getLastCursor(): `${number}`;
    _compare(orderBy: (a: Item, b: Item) => number, a: Item, b: Item): number;
    _nextOrPrev(type: 'next' | 'prev', options: ImplQueryOptions<'next' | 'prev', `${number}`, (item: Item) => boolean, (a: Item, b: Item) => number>): Promise<{
        items: {
            item: Item;
            itemCursor: `${number}`;
        }[];
        isFirst: boolean;
        isLast: boolean;
        cursor: `${number}`;
    }>;
}

export { ArrayPaginatedList, PaginatedList };
