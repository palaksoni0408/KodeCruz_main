// src/utils/urls.tsx
import { generateSecureRandomString } from "./crypto.js";
import { templateIdentity } from "./strings.js";
function createUrlIfValid(...args) {
  try {
    return new URL(...args);
  } catch (e) {
    return null;
  }
}
function isValidUrl(url2) {
  return !!createUrlIfValid(url2);
}
function isValidHostname(hostname) {
  if (!hostname || hostname.startsWith(".") || hostname.endsWith(".") || hostname.includes("..")) {
    return false;
  }
  const url2 = createUrlIfValid(`https://${hostname}`);
  if (!url2) return false;
  return url2.hostname === hostname;
}
function isValidHostnameWithWildcards(hostname) {
  if (!hostname) return false;
  const hasWildcard = hostname.includes("*");
  if (!hasWildcard) {
    return isValidHostname(hostname);
  }
  if (hostname.startsWith(".") || hostname.endsWith(".")) {
    return false;
  }
  if (hostname.includes("..")) {
    return false;
  }
  const testHostname = hostname.replace(/\*+/g, "wildcard");
  if (!/^[a-zA-Z0-9.-]+$/.test(testHostname)) {
    return false;
  }
  const segments = hostname.split(/\*+/);
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    if (segment === "") continue;
    if (i === 0 && segment.startsWith(".")) {
      return false;
    }
    if (i === segments.length - 1 && segment.endsWith(".")) {
      return false;
    }
    if (segment.includes("..")) {
      return false;
    }
  }
  return true;
}
function matchHostnamePattern(pattern, hostname) {
  if (!pattern.includes("*")) {
    return pattern === hostname;
  }
  let regexPattern = pattern.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
  const doubleWildcardPlaceholder = "\0DOUBLE_WILDCARD\0";
  regexPattern = regexPattern.replace(/\*\*/g, doubleWildcardPlaceholder);
  regexPattern = regexPattern.replace(/\*/g, "[^.]*");
  regexPattern = regexPattern.replace(new RegExp(doubleWildcardPlaceholder, "g"), ".*");
  regexPattern = "^" + regexPattern + "$";
  try {
    const regex = new RegExp(regexPattern);
    return regex.test(hostname);
  } catch {
    return false;
  }
}
function isLocalhost(urlOrString) {
  const url2 = createUrlIfValid(urlOrString);
  if (!url2) return false;
  if (url2.hostname === "localhost" || url2.hostname.endsWith(".localhost")) return true;
  if (url2.hostname.match(/^127\.\d+\.\d+\.\d+$/)) return true;
  return false;
}
function isRelative(url2) {
  const randomDomain = `${generateSecureRandomString()}.stack-auth.example.com`;
  const u = createUrlIfValid(url2, `https://${randomDomain}`);
  if (!u) return false;
  if (u.host !== randomDomain) return false;
  if (u.protocol !== "https:") return false;
  return true;
}
function getRelativePart(url2) {
  return url2.pathname + url2.search + url2.hash;
}
function url(strings, ...values) {
  return new URL(urlString(strings, ...values));
}
function urlString(strings, ...values) {
  return templateIdentity(strings, ...values.map(encodeURIComponent));
}
function isChildUrl(parentUrl, maybeChildUrl) {
  return parentUrl.origin === maybeChildUrl.origin && isChildPath(parentUrl.pathname, maybeChildUrl.pathname) && [...parentUrl.searchParams].every(([key, value]) => maybeChildUrl.searchParams.get(key) === value) && (!parentUrl.hash || parentUrl.hash === maybeChildUrl.hash);
}
function isChildPath(parentPath, maybeChildPath) {
  parentPath = parentPath.endsWith("/") ? parentPath : parentPath + "/";
  maybeChildPath = maybeChildPath.endsWith("/") ? maybeChildPath : maybeChildPath + "/";
  return maybeChildPath.startsWith(parentPath);
}
export {
  createUrlIfValid,
  getRelativePart,
  isChildPath,
  isChildUrl,
  isLocalhost,
  isRelative,
  isValidHostname,
  isValidHostnameWithWildcards,
  isValidUrl,
  matchHostnamePattern,
  url,
  urlString
};
//# sourceMappingURL=urls.js.map