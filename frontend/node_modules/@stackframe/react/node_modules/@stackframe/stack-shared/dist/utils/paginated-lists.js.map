{"version":3,"sources":["../../src/utils/paginated-lists.tsx"],"sourcesContent":["import { range } from \"./arrays\";\nimport { StackAssertionError } from \"./errors\";\n\ntype QueryOptions<Type extends 'next' | 'prev', Cursor, Filter, OrderBy> =\n  & {\n    filter: Filter,\n    orderBy: OrderBy,\n    limit: number,\n    /**\n     * Whether the limit should be treated as an exact value, or an approximate value.\n     *\n     * If set to 'exact', less items will only be returned if the list item is the first or last item.\n     *\n     * If set to 'at-least' or 'approximate', the implementation may decide to return more items than the limit requested if doing so comes at no (or negligible) extra cost.\n     *\n     * If set to 'at-most' or 'approximate', the implementation may decide to return less items than the limit requested if requesting more items would come at a non-negligible extra cost. In this case, if limit > 0, the implementation must still make progress towards the end of the list and the returned cursor must be different from the one passed in.\n     *\n     * Defaults to 'exact'.\n     */\n    limitPrecision: 'exact' | 'at-least' | 'at-most' | 'approximate',\n  }\n  & ([Type] extends [never] ? unknown\n    : [Type] extends ['next'] ? { after: Cursor }\n    : [Type] extends ['prev'] ? { before: Cursor }\n    : { cursor: Cursor });\n\ntype ImplQueryOptions<Type extends 'next' | 'prev', Cursor, Filter, OrderBy> = QueryOptions<Type, Cursor, Filter, OrderBy> & { limitPrecision: 'approximate' }\n\ntype QueryResult<Item, Cursor> = { items: { item: Item, itemCursor: Cursor }[], isFirst: boolean, isLast: boolean, cursor: Cursor }\n\ntype ImplQueryResult<Item, Cursor> = { items: { item: Item, itemCursor: Cursor }[], isFirst: boolean, isLast: boolean, cursor: Cursor }\n\nexport abstract class PaginatedList<\n  Item,\n  Cursor extends string,\n  Filter extends unknown,\n  OrderBy extends unknown,\n> {\n  // Abstract methods\n\n  protected abstract _getFirstCursor(): Cursor;\n  protected abstract _getLastCursor(): Cursor;\n  protected abstract _compare(orderBy: OrderBy, a: Item, b: Item): number;\n  protected abstract _nextOrPrev(type: 'next' | 'prev', options: ImplQueryOptions<'next' | 'prev', Cursor, Filter, OrderBy>): Promise<ImplQueryResult<Item, Cursor>>;\n\n  // Implementations\n  public getFirstCursor(): Cursor { return this._getFirstCursor(); }\n  public getLastCursor(): Cursor { return this._getLastCursor(); }\n  public compare(orderBy: OrderBy, a: Item, b: Item): number { return this._compare(orderBy, a, b); }\n\n  async nextOrPrev(type: 'next' | 'prev', options: QueryOptions<'next' | 'prev', Cursor, Filter, OrderBy>): Promise<QueryResult<Item, Cursor>> {\n    let result: { item: Item, itemCursor: Cursor }[] = [];\n    let includesFirst = false;\n    let includesLast = false;\n    let cursor = options.cursor;\n    let limitRemaining = options.limit;\n    while (limitRemaining > 0 || (type === \"next\" && includesLast) || (type === \"prev\" && includesFirst)) {\n      const iterationRes = await this._nextOrPrev(type, {\n        cursor,\n        limit: options.limit,\n        limitPrecision: \"approximate\",\n        filter: options.filter,\n        orderBy: options.orderBy,\n      });\n      result[type === \"next\" ? \"push\" : \"unshift\"](...iterationRes.items);\n      limitRemaining -= iterationRes.items.length;\n      includesFirst ||= iterationRes.isFirst;\n      includesLast ||= iterationRes.isLast;\n      cursor = iterationRes.cursor;\n      if ([\"approximate\", \"at-most\"].includes(options.limitPrecision)) break;\n    }\n\n    // Assert that the result is sorted\n    for (let i = 1; i < result.length; i++) {\n      if (this._compare(options.orderBy, result[i].item, result[i - 1].item) < 0) {\n        throw new StackAssertionError(\"Paginated list result is not sorted; something is wrong with the implementation\", {\n          i,\n          options,\n          result,\n        });\n      }\n    }\n\n    if ([\"exact\", \"at-most\"].includes(options.limitPrecision) && result.length > options.limit) {\n      if (type === \"next\") {\n        result = result.slice(0, options.limit);\n        includesLast = false;\n        if (options.limit > 0) cursor = result[result.length - 1].itemCursor;\n      } else {\n        result = result.slice(result.length - options.limit);\n        includesFirst = false;\n        if (options.limit > 0) cursor = result[0].itemCursor;\n      }\n    }\n    return { items: result, isFirst: includesFirst, isLast: includesLast, cursor };\n  }\n  public async next({ after, ...rest }: QueryOptions<'next', Cursor, Filter, OrderBy>): Promise<QueryResult<Item, Cursor>> {\n    return await this.nextOrPrev(\"next\", {\n      ...rest,\n      cursor: after,\n    });\n  }\n  public async prev({ before, ...rest }: QueryOptions<'prev', Cursor, Filter, OrderBy>): Promise<QueryResult<Item, Cursor>> {\n    return await this.nextOrPrev(\"prev\", {\n      ...rest,\n      cursor: before,\n    });\n  }\n\n  // Utility methods below\n\n  flatMap<Item2, Cursor2 extends string, Filter2 extends unknown, OrderBy2 extends unknown>(options: {\n    itemMapper: (itemEntry: { item: Item, itemCursor: Cursor }, filter: Filter2, orderBy: OrderBy2) => { item: Item2, itemCursor: Cursor2 }[],\n    compare: (orderBy: OrderBy2, a: Item2, b: Item2) => number,\n    newCursorFromOldCursor: (cursor: Cursor) => Cursor2,\n    oldCursorFromNewCursor: (cursor: Cursor2) => Cursor,\n    oldFilterFromNewFilter: (filter: Filter2) => Filter,\n    oldOrderByFromNewOrderBy: (orderBy: OrderBy2) => OrderBy,\n    estimateItemsToFetch: (options: { filter: Filter2, orderBy: OrderBy2, limit: number }) => number,\n  }): PaginatedList<Item2, Cursor2, Filter2, OrderBy2> {\n    const that = this;\n    class FlatMapPaginatedList extends PaginatedList<Item2, Cursor2, Filter2, OrderBy2> {\n      override _getFirstCursor(): Cursor2 { return options.newCursorFromOldCursor(that.getFirstCursor()); }\n      override _getLastCursor(): Cursor2 { return options.newCursorFromOldCursor(that.getLastCursor()); }\n\n      override _compare(orderBy: OrderBy2, a: Item2, b: Item2): number {\n        return options.compare(orderBy, a, b);\n      }\n\n      override async _nextOrPrev(type: 'next' | 'prev', { limit, filter, orderBy, cursor }: ImplQueryOptions<'next' | 'prev', Cursor2, Filter2, OrderBy2>) {\n        const estimatedItems = options.estimateItemsToFetch({ limit, filter, orderBy });\n        const original = await that.nextOrPrev(type, {\n          limit: estimatedItems,\n          limitPrecision: \"approximate\",\n          cursor: options.oldCursorFromNewCursor(cursor),\n          filter: options.oldFilterFromNewFilter(filter),\n          orderBy: options.oldOrderByFromNewOrderBy(orderBy),\n        });\n        const mapped = original.items.flatMap(itemEntry => options.itemMapper(\n        itemEntry,\n        filter,\n        orderBy,\n      ));\n        return {\n          items: mapped,\n          isFirst: original.isFirst,\n          isLast: original.isLast,\n          cursor: options.newCursorFromOldCursor(original.cursor),\n        };\n      }\n    }\n    return new FlatMapPaginatedList();\n  }\n\n  map<Item2, Filter2 extends unknown, OrderBy2 extends unknown>(options: {\n    itemMapper: (item: Item) => Item2,\n    oldItemFromNewItem: (item: Item2) => Item,\n    oldFilterFromNewFilter: (filter: Filter2) => Filter,\n    oldOrderByFromNewOrderBy: (orderBy: OrderBy2) => OrderBy,\n  }): PaginatedList<Item2, Cursor, Filter2, OrderBy2> {\n    return this.flatMap({\n      itemMapper: (itemEntry, filter, orderBy) => {\n        return [{ item: options.itemMapper(itemEntry.item), itemCursor: itemEntry.itemCursor }];\n      },\n      compare: (orderBy, a, b) => this.compare(options.oldOrderByFromNewOrderBy(orderBy), options.oldItemFromNewItem(a), options.oldItemFromNewItem(b)),\n      newCursorFromOldCursor: (cursor) => cursor,\n      oldCursorFromNewCursor: (cursor) => cursor,\n      oldFilterFromNewFilter: (filter) => options.oldFilterFromNewFilter(filter),\n      oldOrderByFromNewOrderBy: (orderBy) => options.oldOrderByFromNewOrderBy(orderBy),\n      estimateItemsToFetch: (options) => options.limit,\n    });\n  }\n\n  filter<Filter2 extends unknown>(options: {\n    filter: (item: Item, filter: Filter2) => boolean,\n    oldFilterFromNewFilter: (filter: Filter2) => Filter,\n    estimateItemsToFetch: (options: { filter: Filter2, orderBy: OrderBy, limit: number }) => number,\n  }): PaginatedList<Item, Cursor, Filter2, OrderBy> {\n    return this.flatMap({\n      itemMapper: (itemEntry, filter, orderBy) => (options.filter(itemEntry.item, filter) ? [itemEntry] : []),\n      compare: (orderBy, a, b) => this.compare(orderBy, a, b),\n      newCursorFromOldCursor: (cursor) => cursor,\n      oldCursorFromNewCursor: (cursor) => cursor,\n      oldFilterFromNewFilter: (filter) => options.oldFilterFromNewFilter(filter),\n      oldOrderByFromNewOrderBy: (orderBy) => orderBy,\n      estimateItemsToFetch: (o) => options.estimateItemsToFetch(o),\n    });\n  }\n\n  addFilter<AddedFilter extends unknown>(options: {\n    filter: (item: Item, filter: Filter & AddedFilter) => boolean,\n    estimateItemsToFetch: (options: { filter: Filter & AddedFilter, orderBy: OrderBy, limit: number }) => number,\n  }): PaginatedList<Item, Cursor, Filter & AddedFilter, OrderBy> {\n    return this.filter({\n      filter: (item, filter) => options.filter(item, filter),\n      oldFilterFromNewFilter: (filter) => filter,\n      estimateItemsToFetch: (o) => options.estimateItemsToFetch(o),\n    });\n  }\n\n  static merge<\n    Item,\n    Filter extends unknown,\n    OrderBy extends unknown,\n  >(\n    ...lists: PaginatedList<Item, any, Filter, OrderBy>[]\n  ): PaginatedList<Item, string, Filter, OrderBy> {\n    class MergePaginatedList extends PaginatedList<Item, string, Filter, OrderBy> {\n      override _getFirstCursor() { return JSON.stringify(lists.map(list => list.getFirstCursor())); }\n      override _getLastCursor() { return JSON.stringify(lists.map(list => list.getLastCursor())); }\n      override _compare(orderBy: OrderBy, a: Item, b: Item): number {\n        const listsResults = lists.map(list => list.compare(orderBy, a, b));\n        if (!listsResults.every(result => result === listsResults[0])) {\n          throw new StackAssertionError(\"Lists have different compare results; make sure that they use the same compare function\", { lists, listsResults });\n        }\n        return listsResults[0];\n      }\n\n      override async _nextOrPrev(type: 'next' | 'prev', { limit, filter, orderBy, cursor }: ImplQueryOptions<'next' | 'prev', \"first\" | \"last\" | `[${string}]`, Filter, OrderBy>) {\n        const cursors = JSON.parse(cursor);\n        const fetchedLists = await Promise.all(lists.map(async (list, i) => {\n          return await list.nextOrPrev(type, {\n            limit,\n            filter,\n            orderBy,\n            cursor: cursors[i],\n            limitPrecision: \"at-least\",\n          });\n        }));\n        const combinedItems = fetchedLists.flatMap((list, i) => list.items.map((itemEntry) => ({ itemEntry, listIndex: i })));\n        const sortedItems = [...combinedItems].sort((a, b) => this._compare(orderBy, a.itemEntry.item, b.itemEntry.item));\n        const lastCursorForEachList = sortedItems.reduce((acc, item) => {\n          acc[item.listIndex] = item.itemEntry.itemCursor;\n          return acc;\n        }, range(lists.length).map((i) => cursors[i]));\n        return {\n          items: sortedItems.map((item) => item.itemEntry),\n          isFirst: sortedItems.every((item) => item.listIndex === 0),\n          isLast: sortedItems.every((item) => item.listIndex === lists.length - 1),\n          cursor: JSON.stringify(lastCursorForEachList),\n        };\n      }\n    }\n    return new MergePaginatedList();\n  }\n\n  static empty() {\n    class EmptyPaginatedList extends PaginatedList<never, \"first\" | \"last\", any, any> {\n      override _getFirstCursor() { return \"first\" as const; }\n      override _getLastCursor() { return \"last\" as const; }\n      override _compare(orderBy: any, a: any, b: any): number {\n        return 0;\n      }\n      override async _nextOrPrev(type: 'next' | 'prev', options: ImplQueryOptions<'next' | 'prev', string, any, any>) {\n        return { items: [], isFirst: true, isLast: true, cursor: \"first\" as const };\n      }\n    }\n    return new EmptyPaginatedList();\n  }\n}\n\nexport class ArrayPaginatedList<Item> extends PaginatedList<Item, `${number}`, (item: Item) => boolean, (a: Item, b: Item) => number> {\n  constructor(private readonly array: Item[]) {\n    super();\n  }\n\n  override _getFirstCursor() { return \"0\" as const; }\n  override _getLastCursor() { return `${this.array.length - 1}` as const; }\n  override _compare(orderBy: (a: Item, b: Item) => number, a: Item, b: Item): number {\n    return orderBy(a, b);\n  }\n\n  override async _nextOrPrev(type: 'next' | 'prev', options: ImplQueryOptions<'next' | 'prev', `${number}`, (item: Item) => boolean, (a: Item, b: Item) => number>) {\n    const filteredArray = this.array.filter(options.filter);\n    const sortedArray = [...filteredArray].sort((a, b) => this._compare(options.orderBy, a, b));\n    const itemEntriesArray = sortedArray.map((item, index) => ({ item, itemCursor: `${index}` as const }));\n    const oldCursor = Number(options.cursor);\n    const newCursor = Math.max(0, Math.min(this.array.length - 1, oldCursor + (type === \"next\" ? 1 : -1) * options.limit));\n    return {\n      items: itemEntriesArray.slice(Math.min(oldCursor, newCursor), Math.max(oldCursor, newCursor)),\n      isFirst: oldCursor === 0 || newCursor === 0,\n      isLast: oldCursor === this.array.length - 1 || newCursor === this.array.length - 1,\n      cursor: `${newCursor}` as const,\n    };\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAsB;AACtB,oBAAoC;AA+B7B,IAAe,gBAAf,MAAe,eAKpB;AAAA;AAAA,EASO,iBAAyB;AAAE,WAAO,KAAK,gBAAgB;AAAA,EAAG;AAAA,EAC1D,gBAAwB;AAAE,WAAO,KAAK,eAAe;AAAA,EAAG;AAAA,EACxD,QAAQ,SAAkB,GAAS,GAAiB;AAAE,WAAO,KAAK,SAAS,SAAS,GAAG,CAAC;AAAA,EAAG;AAAA,EAElG,MAAM,WAAW,MAAuB,SAAqG;AAC3I,QAAI,SAA+C,CAAC;AACpD,QAAI,gBAAgB;AACpB,QAAI,eAAe;AACnB,QAAI,SAAS,QAAQ;AACrB,QAAI,iBAAiB,QAAQ;AAC7B,WAAO,iBAAiB,KAAM,SAAS,UAAU,gBAAkB,SAAS,UAAU,eAAgB;AACpG,YAAM,eAAe,MAAM,KAAK,YAAY,MAAM;AAAA,QAChD;AAAA,QACA,OAAO,QAAQ;AAAA,QACf,gBAAgB;AAAA,QAChB,QAAQ,QAAQ;AAAA,QAChB,SAAS,QAAQ;AAAA,MACnB,CAAC;AACD,aAAO,SAAS,SAAS,SAAS,SAAS,EAAE,GAAG,aAAa,KAAK;AAClE,wBAAkB,aAAa,MAAM;AACrC,wBAAkB,aAAa;AAC/B,uBAAiB,aAAa;AAC9B,eAAS,aAAa;AACtB,UAAI,CAAC,eAAe,SAAS,EAAE,SAAS,QAAQ,cAAc,EAAG;AAAA,IACnE;AAGA,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAI,KAAK,SAAS,QAAQ,SAAS,OAAO,CAAC,EAAE,MAAM,OAAO,IAAI,CAAC,EAAE,IAAI,IAAI,GAAG;AAC1E,cAAM,IAAI,kCAAoB,mFAAmF;AAAA,UAC/G;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAEA,QAAI,CAAC,SAAS,SAAS,EAAE,SAAS,QAAQ,cAAc,KAAK,OAAO,SAAS,QAAQ,OAAO;AAC1F,UAAI,SAAS,QAAQ;AACnB,iBAAS,OAAO,MAAM,GAAG,QAAQ,KAAK;AACtC,uBAAe;AACf,YAAI,QAAQ,QAAQ,EAAG,UAAS,OAAO,OAAO,SAAS,CAAC,EAAE;AAAA,MAC5D,OAAO;AACL,iBAAS,OAAO,MAAM,OAAO,SAAS,QAAQ,KAAK;AACnD,wBAAgB;AAChB,YAAI,QAAQ,QAAQ,EAAG,UAAS,OAAO,CAAC,EAAE;AAAA,MAC5C;AAAA,IACF;AACA,WAAO,EAAE,OAAO,QAAQ,SAAS,eAAe,QAAQ,cAAc,OAAO;AAAA,EAC/E;AAAA,EACA,MAAa,KAAK,EAAE,OAAO,GAAG,KAAK,GAAsF;AACvH,WAAO,MAAM,KAAK,WAAW,QAAQ;AAAA,MACnC,GAAG;AAAA,MACH,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAAA,EACA,MAAa,KAAK,EAAE,QAAQ,GAAG,KAAK,GAAsF;AACxH,WAAO,MAAM,KAAK,WAAW,QAAQ;AAAA,MACnC,GAAG;AAAA,MACH,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAAA;AAAA,EAIA,QAA0F,SAQrC;AACnD,UAAM,OAAO;AAAA,IACb,MAAM,6BAA6B,eAAiD;AAAA,MACzE,kBAA2B;AAAE,eAAO,QAAQ,uBAAuB,KAAK,eAAe,CAAC;AAAA,MAAG;AAAA,MAC3F,iBAA0B;AAAE,eAAO,QAAQ,uBAAuB,KAAK,cAAc,CAAC;AAAA,MAAG;AAAA,MAEzF,SAAS,SAAmB,GAAU,GAAkB;AAC/D,eAAO,QAAQ,QAAQ,SAAS,GAAG,CAAC;AAAA,MACtC;AAAA,MAEA,MAAe,YAAY,MAAuB,EAAE,OAAO,QAAQ,SAAS,OAAO,GAAkE;AACnJ,cAAM,iBAAiB,QAAQ,qBAAqB,EAAE,OAAO,QAAQ,QAAQ,CAAC;AAC9E,cAAM,WAAW,MAAM,KAAK,WAAW,MAAM;AAAA,UAC3C,OAAO;AAAA,UACP,gBAAgB;AAAA,UAChB,QAAQ,QAAQ,uBAAuB,MAAM;AAAA,UAC7C,QAAQ,QAAQ,uBAAuB,MAAM;AAAA,UAC7C,SAAS,QAAQ,yBAAyB,OAAO;AAAA,QACnD,CAAC;AACD,cAAM,SAAS,SAAS,MAAM,QAAQ,eAAa,QAAQ;AAAA,UAC3D;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AACC,eAAO;AAAA,UACL,OAAO;AAAA,UACP,SAAS,SAAS;AAAA,UAClB,QAAQ,SAAS;AAAA,UACjB,QAAQ,QAAQ,uBAAuB,SAAS,MAAM;AAAA,QACxD;AAAA,MACF;AAAA,IACF;AACA,WAAO,IAAI,qBAAqB;AAAA,EAClC;AAAA,EAEA,IAA8D,SAKV;AAClD,WAAO,KAAK,QAAQ;AAAA,MAClB,YAAY,CAAC,WAAW,QAAQ,YAAY;AAC1C,eAAO,CAAC,EAAE,MAAM,QAAQ,WAAW,UAAU,IAAI,GAAG,YAAY,UAAU,WAAW,CAAC;AAAA,MACxF;AAAA,MACA,SAAS,CAAC,SAAS,GAAG,MAAM,KAAK,QAAQ,QAAQ,yBAAyB,OAAO,GAAG,QAAQ,mBAAmB,CAAC,GAAG,QAAQ,mBAAmB,CAAC,CAAC;AAAA,MAChJ,wBAAwB,CAAC,WAAW;AAAA,MACpC,wBAAwB,CAAC,WAAW;AAAA,MACpC,wBAAwB,CAAC,WAAW,QAAQ,uBAAuB,MAAM;AAAA,MACzE,0BAA0B,CAAC,YAAY,QAAQ,yBAAyB,OAAO;AAAA,MAC/E,sBAAsB,CAACA,aAAYA,SAAQ;AAAA,IAC7C,CAAC;AAAA,EACH;AAAA,EAEA,OAAgC,SAIkB;AAChD,WAAO,KAAK,QAAQ;AAAA,MAClB,YAAY,CAAC,WAAW,QAAQ,YAAa,QAAQ,OAAO,UAAU,MAAM,MAAM,IAAI,CAAC,SAAS,IAAI,CAAC;AAAA,MACrG,SAAS,CAAC,SAAS,GAAG,MAAM,KAAK,QAAQ,SAAS,GAAG,CAAC;AAAA,MACtD,wBAAwB,CAAC,WAAW;AAAA,MACpC,wBAAwB,CAAC,WAAW;AAAA,MACpC,wBAAwB,CAAC,WAAW,QAAQ,uBAAuB,MAAM;AAAA,MACzE,0BAA0B,CAAC,YAAY;AAAA,MACvC,sBAAsB,CAAC,MAAM,QAAQ,qBAAqB,CAAC;AAAA,IAC7D,CAAC;AAAA,EACH;AAAA,EAEA,UAAuC,SAGwB;AAC7D,WAAO,KAAK,OAAO;AAAA,MACjB,QAAQ,CAAC,MAAM,WAAW,QAAQ,OAAO,MAAM,MAAM;AAAA,MACrD,wBAAwB,CAAC,WAAW;AAAA,MACpC,sBAAsB,CAAC,MAAM,QAAQ,qBAAqB,CAAC;AAAA,IAC7D,CAAC;AAAA,EACH;AAAA,EAEA,OAAO,SAKF,OAC2C;AAAA,IAC9C,MAAM,2BAA2B,eAA6C;AAAA,MACnE,kBAAkB;AAAE,eAAO,KAAK,UAAU,MAAM,IAAI,UAAQ,KAAK,eAAe,CAAC,CAAC;AAAA,MAAG;AAAA,MACrF,iBAAiB;AAAE,eAAO,KAAK,UAAU,MAAM,IAAI,UAAQ,KAAK,cAAc,CAAC,CAAC;AAAA,MAAG;AAAA,MACnF,SAAS,SAAkB,GAAS,GAAiB;AAC5D,cAAM,eAAe,MAAM,IAAI,UAAQ,KAAK,QAAQ,SAAS,GAAG,CAAC,CAAC;AAClE,YAAI,CAAC,aAAa,MAAM,YAAU,WAAW,aAAa,CAAC,CAAC,GAAG;AAC7D,gBAAM,IAAI,kCAAoB,2FAA2F,EAAE,OAAO,aAAa,CAAC;AAAA,QAClJ;AACA,eAAO,aAAa,CAAC;AAAA,MACvB;AAAA,MAEA,MAAe,YAAY,MAAuB,EAAE,OAAO,QAAQ,SAAS,OAAO,GAAyF;AAC1K,cAAM,UAAU,KAAK,MAAM,MAAM;AACjC,cAAM,eAAe,MAAM,QAAQ,IAAI,MAAM,IAAI,OAAO,MAAM,MAAM;AAClE,iBAAO,MAAM,KAAK,WAAW,MAAM;AAAA,YACjC;AAAA,YACA;AAAA,YACA;AAAA,YACA,QAAQ,QAAQ,CAAC;AAAA,YACjB,gBAAgB;AAAA,UAClB,CAAC;AAAA,QACH,CAAC,CAAC;AACF,cAAM,gBAAgB,aAAa,QAAQ,CAAC,MAAM,MAAM,KAAK,MAAM,IAAI,CAAC,eAAe,EAAE,WAAW,WAAW,EAAE,EAAE,CAAC;AACpH,cAAM,cAAc,CAAC,GAAG,aAAa,EAAE,KAAK,CAAC,GAAG,MAAM,KAAK,SAAS,SAAS,EAAE,UAAU,MAAM,EAAE,UAAU,IAAI,CAAC;AAChH,cAAM,wBAAwB,YAAY,OAAO,CAAC,KAAK,SAAS;AAC9D,cAAI,KAAK,SAAS,IAAI,KAAK,UAAU;AACrC,iBAAO;AAAA,QACT,OAAG,qBAAM,MAAM,MAAM,EAAE,IAAI,CAAC,MAAM,QAAQ,CAAC,CAAC,CAAC;AAC7C,eAAO;AAAA,UACL,OAAO,YAAY,IAAI,CAAC,SAAS,KAAK,SAAS;AAAA,UAC/C,SAAS,YAAY,MAAM,CAAC,SAAS,KAAK,cAAc,CAAC;AAAA,UACzD,QAAQ,YAAY,MAAM,CAAC,SAAS,KAAK,cAAc,MAAM,SAAS,CAAC;AAAA,UACvE,QAAQ,KAAK,UAAU,qBAAqB;AAAA,QAC9C;AAAA,MACF;AAAA,IACF;AACA,WAAO,IAAI,mBAAmB;AAAA,EAChC;AAAA,EAEA,OAAO,QAAQ;AAAA,IACb,MAAM,2BAA2B,eAAiD;AAAA,MACvE,kBAAkB;AAAE,eAAO;AAAA,MAAkB;AAAA,MAC7C,iBAAiB;AAAE,eAAO;AAAA,MAAiB;AAAA,MAC3C,SAAS,SAAc,GAAQ,GAAgB;AACtD,eAAO;AAAA,MACT;AAAA,MACA,MAAe,YAAY,MAAuB,SAA8D;AAC9G,eAAO,EAAE,OAAO,CAAC,GAAG,SAAS,MAAM,QAAQ,MAAM,QAAQ,QAAiB;AAAA,MAC5E;AAAA,IACF;AACA,WAAO,IAAI,mBAAmB;AAAA,EAChC;AACF;AAEO,IAAM,qBAAN,cAAuC,cAAwF;AAAA,EACpI,YAA6B,OAAe;AAC1C,UAAM;AADqB;AAAA,EAE7B;AAAA,EAES,kBAAkB;AAAE,WAAO;AAAA,EAAc;AAAA,EACzC,iBAAiB;AAAE,WAAO,GAAG,KAAK,MAAM,SAAS,CAAC;AAAA,EAAa;AAAA,EAC/D,SAAS,SAAuC,GAAS,GAAiB;AACjF,WAAO,QAAQ,GAAG,CAAC;AAAA,EACrB;AAAA,EAEA,MAAe,YAAY,MAAuB,SAAgH;AAChK,UAAM,gBAAgB,KAAK,MAAM,OAAO,QAAQ,MAAM;AACtD,UAAM,cAAc,CAAC,GAAG,aAAa,EAAE,KAAK,CAAC,GAAG,MAAM,KAAK,SAAS,QAAQ,SAAS,GAAG,CAAC,CAAC;AAC1F,UAAM,mBAAmB,YAAY,IAAI,CAAC,MAAM,WAAW,EAAE,MAAM,YAAY,GAAG,KAAK,GAAY,EAAE;AACrG,UAAM,YAAY,OAAO,QAAQ,MAAM;AACvC,UAAM,YAAY,KAAK,IAAI,GAAG,KAAK,IAAI,KAAK,MAAM,SAAS,GAAG,aAAa,SAAS,SAAS,IAAI,MAAM,QAAQ,KAAK,CAAC;AACrH,WAAO;AAAA,MACL,OAAO,iBAAiB,MAAM,KAAK,IAAI,WAAW,SAAS,GAAG,KAAK,IAAI,WAAW,SAAS,CAAC;AAAA,MAC5F,SAAS,cAAc,KAAK,cAAc;AAAA,MAC1C,QAAQ,cAAc,KAAK,MAAM,SAAS,KAAK,cAAc,KAAK,MAAM,SAAS;AAAA,MACjF,QAAQ,GAAG,SAAS;AAAA,IACtB;AAAA,EACF;AACF;","names":["options"]}